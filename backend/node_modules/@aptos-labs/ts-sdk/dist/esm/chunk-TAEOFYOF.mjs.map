{"version":3,"sources":["../../src/core/crypto/keyless.ts","../../src/core/crypto/federatedKeyless.ts","../../src/core/crypto/singleKey.ts","../../src/core/crypto/multiKey.ts","../../src/core/crypto/multiEd25519.ts","../../src/transactions/authenticator/account.ts","../../src/transactions/transactionBuilder/signingMessage.ts","../../src/transactions/instances/moduleId.ts","../../src/transactions/typeTag/index.ts","../../src/transactions/instances/transactionPayload.ts","../../src/transactions/instances/rawTransaction.ts","../../src/transactions/authenticator/transaction.ts","../../src/transactions/instances/signedTransaction.ts","../../src/transactions/instances/simpleTransaction.ts","../../src/transactions/instances/multiAgentTransaction.ts","../../src/account/Ed25519Account.ts","../../src/account/SingleKeyAccount.ts","../../src/account/Account.ts","../../src/account/EphemeralKeyPair.ts","../../src/account/AbstractKeylessAccount.ts","../../src/account/KeylessAccount.ts","../../src/account/FederatedKeylessAccount.ts","../../src/account/MultiKeyAccount.ts","../../src/account/MultiEd25519Account.ts","../../src/account/utils.ts","../../src/account/AccountUtils.ts","../../src/account/AbstractedAccount.ts","../../src/account/DerivableAbstractedAccount.ts","../../src/transactions/transactionBuilder/transactionBuilder.ts","../../src/transactions/typeTag/parser.ts","../../src/transactions/transactionBuilder/helpers.ts","../../src/transactions/transactionBuilder/remoteAbi.ts","../../src/transactions/scriptComposer/index.ts","../../src/internal/transactionSubmission.ts","../../src/internal/account.ts","../../src/internal/view.ts","../../src/internal/abstraction.ts","../../src/api/account/abstraction.ts","../../src/api/account.ts","../../src/internal/coin.ts","../../src/api/coin.ts","../../src/internal/digitalAsset.ts","../../src/api/digitalAsset.ts","../../src/internal/event.ts","../../src/api/event.ts","../../src/internal/faucet.ts","../../src/api/faucet.ts","../../src/internal/fungibleAsset.ts","../../src/api/fungibleAsset.ts","../../src/api/general.ts","../../src/internal/ans.ts","../../src/api/ans.ts","../../src/internal/staking.ts","../../src/api/staking.ts","../../src/api/transactionSubmission/build.ts","../../src/api/transactionSubmission/simulate.ts","../../src/api/transactionSubmission/submit.ts","../../src/api/transactionSubmission/management.ts","../../src/transactions/management/accountSequenceNumber.ts","../../src/transactions/management/transactionWorker.ts","../../src/api/transaction.ts","../../src/internal/keyless.ts","../../src/api/keyless.ts","../../src/internal/object.ts","../../src/api/object.ts","../../src/api/aptos.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n// eslint-disable-next-line max-classes-per-file\nimport { JwtPayload, jwtDecode } from \"jwt-decode\";\nimport { sha3_256 } from \"@noble/hashes/sha3\";\nimport { AccountPublicKey, PublicKey } from \"./publicKey\";\nimport { Signature } from \"./signature\";\nimport { Deserializer, Serializable, Serializer } from \"../../bcs\";\nimport { Hex, hexToAsciiString } from \"../hex\";\nimport {\n  HexInput,\n  EphemeralCertificateVariant,\n  AnyPublicKeyVariant,\n  SigningScheme,\n  ZkpVariant,\n  LedgerVersionArg,\n  MoveResource,\n} from \"../../types\";\nimport { EphemeralPublicKey, EphemeralSignature } from \"./ephemeral\";\nimport { bigIntToBytesLE, bytesToBigIntLE, hashStrToField, padAndPackBytesWithLen, poseidonHash } from \"./poseidon\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { Proof } from \"./proof\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"./ed25519\";\nimport {\n  Groth16VerificationKeyResponse,\n  KeylessConfigurationResponse,\n  MoveAnyStruct,\n  PatchedJWKsResponse,\n} from \"../../types/keyless\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport { getAptosFullNode } from \"../../client\";\nimport { memoizeAsync } from \"../../utils/memoize\";\nimport { AccountAddress, AccountAddressInput } from \"../accountAddress\";\nimport { base64UrlToBytes, getErrorMessage, nowInSeconds } from \"../../utils\";\nimport { KeylessError, KeylessErrorType } from \"../../errors\";\nimport { bn254 } from \"@noble/curves/bn254\";\nimport { bytesToNumberBE } from \"@noble/curves/abstract/utils\";\nimport { FederatedKeylessPublicKey } from \"./federatedKeyless\";\nimport { encode } from \"js-base64\";\nimport { generateSigningMessage } from \"../..\";\nimport { ProjPointType } from \"@noble/curves/abstract/weierstrass\";\nimport { Fp2 } from \"@noble/curves/abstract/tower\";\n\n/**\n * @group Implementation\n * @category Serialization\n */\nexport const EPK_HORIZON_SECS = 10000000;\n/**\n * @group Implementation\n * @category Serialization\n */\nexport const MAX_AUD_VAL_BYTES = 120;\n/**\n * @group Implementation\n * @category Serialization\n */\nexport const MAX_UID_KEY_BYTES = 30;\n/**\n * @group Implementation\n * @category Serialization\n */\nexport const MAX_UID_VAL_BYTES = 330;\n/**\n * @group Implementation\n * @category Serialization\n */\nexport const MAX_ISS_VAL_BYTES = 120;\n/**\n * @group Implementation\n * @category Serialization\n */\nexport const MAX_EXTRA_FIELD_BYTES = 350;\n/**\n * @group Implementation\n * @category Serialization\n */\nexport const MAX_JWT_HEADER_B64_BYTES = 300;\n/**\n * @group Implementation\n * @category Serialization\n */\nexport const MAX_COMMITED_EPK_BYTES = 93;\n\n/**\n * Represents a Keyless Public Key used for authentication.\n *\n * This class encapsulates the public key functionality for keyless authentication,\n * including methods for generating and verifying signatures, as well as serialization\n * and deserialization of the key. The KeylessPublicKey is represented in the SDK\n * as `AnyPublicKey`.\n * @group Implementation\n * @category Serialization\n */\nexport class KeylessPublicKey extends AccountPublicKey {\n  /**\n   * The number of bytes that `idCommitment` should be\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly ID_COMMITMENT_LENGTH: number = 32;\n\n  /**\n   * The value of the 'iss' claim on the JWT which identifies the OIDC provider.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly iss: string;\n\n  /**\n   * A value representing a cryptographic commitment to a user identity.\n   *\n   * It is calculated from the aud, uidKey, uidVal, pepper.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly idCommitment: Uint8Array;\n\n  /**\n   * Constructs an instance with the specified parameters for cryptographic operations.\n   *\n   * @param args - The parameters required to initialize the instance.\n   * @param args.alphaG1 - The hex representation of the alpha G1 value.\n   * @param args.betaG2 - The hex representation of the beta G2 value.\n   * @param args.deltaG2 - The hex representation of the delta G2 value.\n   * @param args.gammaAbcG1 - An array containing two hex representations for gamma ABC G1 values.\n   * @param args.gammaG2 - The hex representation of the gamma G2 value.\n   * @group Implementation\n   * @category Serialization\n   */\n  // TODO: Fix the JSDoc for the below values\n  constructor(iss: string, idCommitment: HexInput) {\n    super();\n    const idcBytes = Hex.fromHexInput(idCommitment).toUint8Array();\n    if (idcBytes.length !== KeylessPublicKey.ID_COMMITMENT_LENGTH) {\n      throw new Error(`Id Commitment length in bytes should be ${KeylessPublicKey.ID_COMMITMENT_LENGTH}`);\n    }\n    this.iss = iss;\n    this.idCommitment = idcBytes;\n  }\n\n  /**\n   * Get the authentication key for the keyless public key.\n   *\n   * @returns AuthenticationKey - The authentication key derived from the keyless public key.\n   * @group Implementation\n   * @category Serialization\n   */\n  authKey(): AuthenticationKey {\n    const serializer = new Serializer();\n    serializer.serializeU32AsUleb128(AnyPublicKeyVariant.Keyless);\n    serializer.serializeFixedBytes(this.bcsToBytes());\n    return AuthenticationKey.fromSchemeAndBytes({\n      scheme: SigningScheme.SingleKey,\n      input: serializer.toUint8Array(),\n    });\n  }\n\n  /**\n   * Verifies the validity of a signature for a given message.\n   *\n   * @param args - The arguments for signature verification.\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature to verify against the message.\n   * @param args.jwk - The JWK to use for verification.\n   * @param args.keylessConfig - The keyless configuration to use for verification.\n   * @returns true if the signature is valid; otherwise, false.\n   * @group Implementation\n   * @category Serialization\n   */\n  verifySignature(args: {\n    message: HexInput;\n    signature: Signature;\n    jwk: MoveJWK;\n    keylessConfig: KeylessConfiguration;\n  }): boolean {\n    try {\n      verifyKeylessSignatureWithJwkAndConfig({ ...args, publicKey: this });\n      return true;\n    } catch (error) {\n      if (error instanceof KeylessError) {\n        return false;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Verifies a keyless signature for a given message.  It will fetch the keyless configuration and the JWK to\n   * use for verification from the appropriate network as defined by the aptosConfig.\n   *\n   * @param args.aptosConfig The aptos config to use for fetching the keyless configuration.\n   * @param args.message The message to verify the signature against.\n   * @param args.signature The signature to verify.\n   * @param args.options.throwErrorWithReason Whether to throw an error with the reason for the failure instead of returning false.\n   * @returns true if the signature is valid\n   */\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: Signature;\n    options?: { throwErrorWithReason?: boolean };\n  }): Promise<boolean> {\n    return verifyKeylessSignature({\n      ...args,\n      publicKey: this,\n    });\n  }\n\n  /**\n   * Serializes the current instance into a format suitable for transmission or storage.\n   * This function ensures that all relevant fields are properly serialized, including the proof and optional fields.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @param serializer.proof - The proof to be serialized.\n   * @param serializer.expHorizonSecs - The expiration horizon in seconds.\n   * @param serializer.extraField - An optional additional field for serialization.\n   * @param serializer.overrideAudVal - An optional override value for auditing.\n   * @param serializer.trainingWheelsSignature - An optional signature for training wheels.\n   * @group Implementation\n   * @category Serialization\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeStr(this.iss);\n    serializer.serializeBytes(this.idCommitment);\n  }\n\n  /**\n   * Deserializes a ZeroKnowledgeSig object from the provided deserializer.\n   * This function allows you to reconstruct a ZeroKnowledgeSig instance from its serialized form.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @returns A new instance of ZeroKnowledgeSig.\n   * @group Implementation\n   * @category Serialization\n   */\n  static deserialize(deserializer: Deserializer): KeylessPublicKey {\n    const iss = deserializer.deserializeStr();\n    const addressSeed = deserializer.deserializeBytes();\n    return new KeylessPublicKey(iss, addressSeed);\n  }\n\n  /**\n   * Loads a KeylessPublicKey instance from the provided deserializer.\n   * This function is used to deserialize the necessary components to create a KeylessPublicKey.\n   *\n   * @param deserializer - The deserializer used to extract the string and byte data.\n   * @param deserializer.deserializeStr - A method to deserialize a string value.\n   * @param deserializer.deserializeBytes - A method to deserialize byte data.\n   * @returns A new instance of KeylessPublicKey.\n   * @group Implementation\n   * @category Serialization\n   */\n  static load(deserializer: Deserializer): KeylessPublicKey {\n    const iss = deserializer.deserializeStr();\n    const addressSeed = deserializer.deserializeBytes();\n    return new KeylessPublicKey(iss, addressSeed);\n  }\n\n  /**\n   * Determines if the provided public key is an instance of KeylessPublicKey.\n   *\n   * @param publicKey - The public key to check.\n   * @returns A boolean indicating whether the public key is a KeylessPublicKey instance.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isPublicKey(publicKey: PublicKey): publicKey is KeylessPublicKey {\n    return publicKey instanceof KeylessPublicKey;\n  }\n\n  /**\n   * Creates a KeylessPublicKey from the JWT components plus pepper\n   *\n   * @param args.iss the iss of the identity\n   * @param args.uidKey the key to use to get the uidVal in the JWT token\n   * @param args.uidVal the value of the uidKey in the JWT token\n   * @param args.aud the client ID of the application\n   * @param args.pepper The pepper used to maintain privacy of the account\n   * @returns KeylessPublicKey\n   * @group Implementation\n   * @category Serialization\n   */\n  static create(args: {\n    iss: string;\n    uidKey: string;\n    uidVal: string;\n    aud: string;\n    pepper: HexInput;\n  }): KeylessPublicKey {\n    computeIdCommitment(args);\n    return new KeylessPublicKey(args.iss, computeIdCommitment(args));\n  }\n\n  /**\n   * Creates a KeylessPublicKey instance from a JWT and a pepper value.\n   * This function is useful for generating a public key that can be used for authentication based on the provided JWT claims and pepper.\n   *\n   * @param args - The arguments for creating the KeylessPublicKey.\n   * @param args.jwt - The JSON Web Token to decode.\n   * @param args.pepper - The pepper value used in the key creation process.\n   * @param args.uidKey - An optional key to retrieve the unique identifier from the JWT payload, defaults to \"sub\".\n   * @returns A KeylessPublicKey instance created from the provided JWT and pepper.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromJwtAndPepper(args: { jwt: string; pepper: HexInput; uidKey?: string }): KeylessPublicKey {\n    const { jwt, pepper, uidKey = \"sub\" } = args;\n    const jwtPayload = jwtDecode<JwtPayload & { [key: string]: string }>(jwt);\n    if (typeof jwtPayload.iss !== \"string\") {\n      throw new Error(\"iss was not found\");\n    }\n    if (typeof jwtPayload.aud !== \"string\") {\n      throw new Error(\"aud was not found or an array of values\");\n    }\n    const uidVal = jwtPayload[uidKey];\n    return KeylessPublicKey.create({ iss: jwtPayload.iss, uidKey, uidVal, aud: jwtPayload.aud, pepper });\n  }\n\n  /**\n   * Checks if the provided public key is a valid instance by verifying its structure and types.\n   *\n   * @param publicKey - The public key to validate.\n   * @returns A boolean indicating whether the public key is a valid instance.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isInstance(publicKey: PublicKey) {\n    return (\n      \"iss\" in publicKey &&\n      typeof publicKey.iss === \"string\" &&\n      \"idCommitment\" in publicKey &&\n      publicKey.idCommitment instanceof Uint8Array\n    );\n  }\n}\n\nexport async function verifyKeylessSignature(args: {\n  publicKey: KeylessPublicKey | FederatedKeylessPublicKey;\n  aptosConfig: AptosConfig;\n  message: HexInput;\n  signature: Signature;\n  keylessConfig?: KeylessConfiguration;\n  jwk?: MoveJWK;\n  options?: { throwErrorWithReason?: boolean };\n}): Promise<boolean> {\n  const {\n    aptosConfig,\n    publicKey,\n    message,\n    signature,\n    jwk,\n    keylessConfig = await getKeylessConfig({ aptosConfig }),\n    options,\n  } = args;\n  try {\n    if (!(signature instanceof KeylessSignature)) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.SIGNATURE_TYPE_INVALID,\n        details: \"Not a keyless signature\",\n      });\n    }\n    verifyKeylessSignatureWithJwkAndConfig({\n      message,\n      publicKey,\n      signature,\n      jwk: jwk ? jwk : await fetchJWK({ aptosConfig, publicKey, kid: signature.getJwkKid() }),\n      keylessConfig,\n    });\n    return true;\n  } catch (error) {\n    if (options?.throwErrorWithReason) {\n      throw error;\n    }\n    return false;\n  }\n}\n\n/**\n * Syncronously verifies a keyless signature for a given message.  You need to provide the keyless configuration and the\n * JWK to use for verification.\n *\n * @param args.message The message to verify the signature against.\n * @param args.signature The signature to verify.\n * @param args.keylessConfig The keyless configuration.\n * @param args.jwk The JWK to use for verification.\n * @returns true if the signature is valid\n * @throws KeylessError if the signature is invalid\n */\nexport function verifyKeylessSignatureWithJwkAndConfig(args: {\n  publicKey: KeylessPublicKey | FederatedKeylessPublicKey;\n  message: HexInput;\n  signature: Signature;\n  keylessConfig: KeylessConfiguration;\n  jwk: MoveJWK;\n}): void {\n  const { publicKey, message, signature, keylessConfig, jwk } = args;\n  const { verificationKey, maxExpHorizonSecs, trainingWheelsPubkey } = keylessConfig;\n  if (!(signature instanceof KeylessSignature)) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.SIGNATURE_TYPE_INVALID,\n      details: \"Not a keyless signature\",\n    });\n  }\n  if (!(signature.ephemeralCertificate.signature instanceof ZeroKnowledgeSig)) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.SIGNATURE_TYPE_INVALID,\n      details: \"Unsupported ephemeral certificate variant\",\n    });\n  }\n  const zkSig = signature.ephemeralCertificate.signature;\n  if (!(zkSig.proof.proof instanceof Groth16Zkp)) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.SIGNATURE_TYPE_INVALID,\n      details: \"Unsupported proof variant for ZeroKnowledgeSig\",\n    });\n  }\n  const groth16Proof = zkSig.proof.proof;\n  if (signature.expiryDateSecs < nowInSeconds()) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.SIGNATURE_EXPIRED,\n      details: \"The expiryDateSecs is in the past\",\n    });\n  }\n  if (zkSig.expHorizonSecs > maxExpHorizonSecs) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.MAX_EXPIRY_HORIZON_EXCEEDED,\n    });\n  }\n  if (!signature.ephemeralPublicKey.verifySignature({ message, signature: signature.ephemeralSignature })) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.EPHEMERAL_SIGNATURE_VERIFICATION_FAILED,\n    });\n  }\n  const publicInputsHash = getPublicInputsHash({ publicKey, signature, jwk, keylessConfig });\n  if (!verificationKey.verifyProof({ publicInputsHash, groth16Proof })) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.PROOF_VERIFICATION_FAILED,\n    });\n  }\n  if (trainingWheelsPubkey) {\n    if (!zkSig.trainingWheelsSignature) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.TRAINING_WHEELS_SIGNATURE_MISSING,\n      });\n    }\n    const proofAndStatement = new Groth16ProofAndStatement(groth16Proof, publicInputsHash);\n    if (\n      !trainingWheelsPubkey.verifySignature({\n        message: proofAndStatement.hash(),\n        signature: zkSig.trainingWheelsSignature,\n      })\n    ) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.TRAINING_WHEELS_SIGNATURE_VERIFICATION_FAILED,\n      });\n    }\n  }\n}\n\n/**\n * Get the public inputs hash for the keyless signature.\n *\n * @param args.signature The signature\n * @param args.jwk The JWK to use for the public inputs hash\n * @param args.keylessConfig The keyless configuration which defines the byte lengths to use when hashing fields.\n * @returns The public inputs hash\n */\nfunction getPublicInputsHash(args: {\n  publicKey: KeylessPublicKey | FederatedKeylessPublicKey;\n  signature: KeylessSignature;\n  jwk: MoveJWK;\n  keylessConfig: KeylessConfiguration;\n}): bigint {\n  const { publicKey, signature, jwk, keylessConfig } = args;\n  const innerKeylessPublicKey = publicKey instanceof KeylessPublicKey ? publicKey : publicKey.keylessPublicKey;\n  if (!(signature.ephemeralCertificate.signature instanceof ZeroKnowledgeSig)) {\n    throw new Error(\"Signature is not a ZeroKnowledgeSig\");\n  }\n  const proof = signature.ephemeralCertificate.signature;\n  const fields = [];\n  fields.push(\n    ...padAndPackBytesWithLen(signature.ephemeralPublicKey.toUint8Array(), keylessConfig.maxCommitedEpkBytes),\n  );\n  fields.push(bytesToBigIntLE(innerKeylessPublicKey.idCommitment));\n  fields.push(signature.expiryDateSecs);\n  fields.push(proof.expHorizonSecs);\n  fields.push(hashStrToField(innerKeylessPublicKey.iss, keylessConfig.maxIssValBytes));\n  if (!proof.extraField) {\n    fields.push(0n);\n    fields.push(hashStrToField(\" \", keylessConfig.maxExtraFieldBytes));\n  } else {\n    fields.push(1n);\n    fields.push(hashStrToField(proof.extraField, keylessConfig.maxExtraFieldBytes));\n  }\n  fields.push(hashStrToField(encode(signature.jwtHeader, true) + \".\", keylessConfig.maxJwtHeaderB64Bytes));\n  fields.push(jwk.toScalar());\n  if (!proof.overrideAudVal) {\n    fields.push(hashStrToField(\"\", MAX_AUD_VAL_BYTES));\n    fields.push(0n);\n  } else {\n    fields.push(hashStrToField(proof.overrideAudVal, MAX_AUD_VAL_BYTES));\n    fields.push(1n);\n  }\n  return poseidonHash(fields);\n}\n\n/**\n * Fetches the JWK from the issuer's well-known JWKS endpoint.\n *\n * @param args.publicKey The keyless public key which contains the issuer the address to fetch the JWK from (0x1 if not federated).\n * @param args.kid The kid of the JWK to fetch\n * @returns A JWK matching the `kid` in the JWT header.\n * @throws {KeylessError} If the JWK cannot be fetched\n */\nexport async function fetchJWK(args: {\n  aptosConfig: AptosConfig;\n  publicKey: KeylessPublicKey | FederatedKeylessPublicKey;\n  kid: string;\n}): Promise<MoveJWK> {\n  const { aptosConfig, publicKey, kid } = args;\n  const keylessPubKey = publicKey instanceof KeylessPublicKey ? publicKey : publicKey.keylessPublicKey;\n  const { iss } = keylessPubKey;\n\n  let allJWKs: Map<string, MoveJWK[]>;\n  const jwkAddr = publicKey instanceof FederatedKeylessPublicKey ? publicKey.jwkAddress : undefined;\n  try {\n    allJWKs = await getKeylessJWKs({ aptosConfig, jwkAddr });\n  } catch (error) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.FULL_NODE_JWKS_LOOKUP_ERROR,\n      error,\n      details: `Failed to fetch ${jwkAddr ? \"Federated\" : \"Patched\"}JWKs ${jwkAddr ? `for address ${jwkAddr}` : \"0x1\"}`,\n    });\n  }\n\n  // Find the corresponding JWK set by `iss`\n  const jwksForIssuer = allJWKs.get(iss);\n\n  if (jwksForIssuer === undefined) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.INVALID_JWT_ISS_NOT_RECOGNIZED,\n      details: `JWKs for issuer ${iss} not found.`,\n    });\n  }\n\n  // Find the corresponding JWK by `kid`\n  const jwk = jwksForIssuer.find((key) => key.kid === kid);\n\n  if (jwk === undefined) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.INVALID_JWT_JWK_NOT_FOUND,\n      details: `JWK with kid '${kid}' for issuer '${iss}' not found.`,\n    });\n  }\n\n  return jwk;\n}\n\nfunction computeIdCommitment(args: { uidKey: string; uidVal: string; aud: string; pepper: HexInput }): Uint8Array {\n  const { uidKey, uidVal, aud, pepper } = args;\n\n  const fields = [\n    bytesToBigIntLE(Hex.fromHexInput(pepper).toUint8Array()),\n    hashStrToField(aud, MAX_AUD_VAL_BYTES),\n    hashStrToField(uidVal, MAX_UID_VAL_BYTES),\n    hashStrToField(uidKey, MAX_UID_KEY_BYTES),\n  ];\n\n  return bigIntToBytesLE(poseidonHash(fields), KeylessPublicKey.ID_COMMITMENT_LENGTH);\n}\n\n/**\n * Represents a signature of a message signed via a Keyless Account, utilizing proofs or a JWT token for authentication.\n * @group Implementation\n * @category Serialization\n */\nexport class KeylessSignature extends Signature {\n  /**\n   * The inner signature ZeroKnowledgeSignature or OpenIdSignature\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly ephemeralCertificate: EphemeralCertificate;\n\n  /**\n   * The jwt header in the token used to create the proof/signature.  In json string representation.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly jwtHeader: string;\n\n  /**\n   * The expiry timestamp in seconds of the EphemeralKeyPair used to sign\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly expiryDateSecs: number;\n\n  /**\n   * The ephemeral public key used to verify the signature\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly ephemeralPublicKey: EphemeralPublicKey;\n\n  /**\n   * The signature resulting from signing with the private key of the EphemeralKeyPair\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly ephemeralSignature: EphemeralSignature;\n\n  constructor(args: {\n    jwtHeader: string;\n    ephemeralCertificate: EphemeralCertificate;\n    expiryDateSecs: number;\n    ephemeralPublicKey: EphemeralPublicKey;\n    ephemeralSignature: EphemeralSignature;\n  }) {\n    super();\n    const { jwtHeader, ephemeralCertificate, expiryDateSecs, ephemeralPublicKey, ephemeralSignature } = args;\n    this.jwtHeader = jwtHeader;\n    this.ephemeralCertificate = ephemeralCertificate;\n    this.expiryDateSecs = expiryDateSecs;\n    this.ephemeralPublicKey = ephemeralPublicKey;\n    this.ephemeralSignature = ephemeralSignature;\n  }\n\n  /**\n   * Get the kid of the JWT used to derive the Keyless Account used to sign.\n   *\n   * @returns the kid as a string\n   */\n  getJwkKid(): string {\n    return parseJwtHeader(this.jwtHeader).kid;\n  }\n\n  serialize(serializer: Serializer): void {\n    this.ephemeralCertificate.serialize(serializer);\n    serializer.serializeStr(this.jwtHeader);\n    serializer.serializeU64(this.expiryDateSecs);\n    this.ephemeralPublicKey.serialize(serializer);\n    this.ephemeralSignature.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): KeylessSignature {\n    const ephemeralCertificate = EphemeralCertificate.deserialize(deserializer);\n    const jwtHeader = deserializer.deserializeStr();\n    const expiryDateSecs = deserializer.deserializeU64();\n    const ephemeralPublicKey = EphemeralPublicKey.deserialize(deserializer);\n    const ephemeralSignature = EphemeralSignature.deserialize(deserializer);\n    return new KeylessSignature({\n      jwtHeader,\n      expiryDateSecs: Number(expiryDateSecs),\n      ephemeralCertificate,\n      ephemeralPublicKey,\n      ephemeralSignature,\n    });\n  }\n\n  static getSimulationSignature(): KeylessSignature {\n    return new KeylessSignature({\n      jwtHeader: \"{}\",\n      ephemeralCertificate: new EphemeralCertificate(\n        new ZeroKnowledgeSig({\n          proof: new ZkProof(\n            new Groth16Zkp({ a: new Uint8Array(32), b: new Uint8Array(64), c: new Uint8Array(32) }),\n            ZkpVariant.Groth16,\n          ),\n          expHorizonSecs: 0,\n        }),\n        EphemeralCertificateVariant.ZkProof,\n      ),\n      expiryDateSecs: 0,\n      ephemeralPublicKey: new EphemeralPublicKey(new Ed25519PublicKey(new Uint8Array(32))),\n      ephemeralSignature: new EphemeralSignature(new Ed25519Signature(new Uint8Array(64))),\n    });\n  }\n\n  static isSignature(signature: Signature): signature is KeylessSignature {\n    return signature instanceof KeylessSignature;\n  }\n}\n\n/**\n * Represents an ephemeral certificate containing a signature, specifically a ZeroKnowledgeSig.\n * This class can be extended to support additional signature types, such as OpenIdSignature.\n *\n * @extends Signature\n * @group Implementation\n * @category Serialization\n */\nexport class EphemeralCertificate extends Signature {\n  public readonly signature: Signature;\n\n  /**\n   * Index of the underlying enum variant\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly variant: EphemeralCertificateVariant;\n\n  constructor(signature: Signature, variant: EphemeralCertificateVariant) {\n    super();\n    this.signature = signature;\n    this.variant = variant;\n  }\n\n  /**\n   * Get the public key in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the public key\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.signature.toUint8Array();\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(this.variant);\n    this.signature.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): EphemeralCertificate {\n    const variant = deserializer.deserializeUleb128AsU32();\n    switch (variant) {\n      case EphemeralCertificateVariant.ZkProof:\n        return new EphemeralCertificate(ZeroKnowledgeSig.deserialize(deserializer), variant);\n      default:\n        throw new Error(`Unknown variant index for EphemeralCertificate: ${variant}`);\n    }\n  }\n}\n\n/**\n * Represents a fixed-size byte array of 32 bytes, extending the Serializable class.\n * This class is used for handling and serializing G1 bytes in cryptographic operations.\n *\n * @extends Serializable\n * @group Implementation\n * @category Serialization\n */\nclass G1Bytes extends Serializable {\n  private static readonly B = bn254.fields.Fp.create(3n);\n\n  data: Uint8Array;\n\n  constructor(data: HexInput) {\n    super();\n    this.data = Hex.fromHexInput(data).toUint8Array();\n    if (this.data.length !== 32) {\n      throw new Error(\"Input needs to be 32 bytes\");\n    }\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeFixedBytes(this.data);\n  }\n\n  static deserialize(deserializer: Deserializer): G1Bytes {\n    const bytes = deserializer.deserializeFixedBytes(32);\n    return new G1Bytes(bytes);\n  }\n\n  // Convert the projective coordinates to strings\n  toArray(): string[] {\n    const point = this.toProjectivePoint();\n    return [point.x.toString(), point.y.toString(), point.pz.toString()];\n  }\n\n  /**\n   * Converts the G1 bytes to a projective point.\n   * @returns The projective point.\n   */\n  toProjectivePoint(): ProjPointType<bigint> {\n    const bytes = new Uint8Array(this.data);\n    // Reverse the bytes to convert from little-endian to big-endian.\n    bytes.reverse();\n    // This gets the flag bit to determine which y to use.\n    const yFlag = (bytes[0] & 0x80) >> 7;\n    const { Fp } = bn254.fields;\n    const x = Fp.create(bytesToBn254FpBE(bytes));\n    const y = Fp.sqrt(Fp.add(Fp.pow(x, 3n), G1Bytes.B));\n    const negY = Fp.neg(y);\n    const yToUse = y > negY === (yFlag === 1) ? y : negY;\n    return bn254.G1.ProjectivePoint.fromAffine({\n      x: x,\n      y: yToUse,\n    });\n  }\n}\n\nfunction bytesToBn254FpBE(bytes: Uint8Array): bigint {\n  if (bytes.length !== 32) {\n    throw new Error(\"Input should be 32 bytes\");\n  }\n  // Clear the first two bits of the first byte which removes any flags.\n  const result = new Uint8Array(bytes);\n  result[0] = result[0] & 0x3f; // 0x3F = 00111111 in binary\n  return bytesToNumberBE(result);\n}\n\n/**\n * Represents a 64-byte G2 element in a cryptographic context.\n * This class provides methods for serialization and deserialization of G2 bytes.\n *\n * @extends Serializable\n * @group Implementation\n * @category Serialization\n */\nclass G2Bytes extends Serializable {\n  /**\n   * The constant b value used in G2 point calculations\n   */\n  private static readonly B = bn254.fields.Fp2.fromBigTuple([\n    19485874751759354771024239261021720505790618469301721065564631296452457478373n,\n    266929791119991161246907387137283842545076965332900288569378510910307636690n,\n  ]);\n\n  data: Uint8Array;\n\n  constructor(data: HexInput) {\n    super();\n    this.data = Hex.fromHexInput(data).toUint8Array();\n    if (this.data.length !== 64) {\n      throw new Error(\"Input needs to be 64 bytes\");\n    }\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeFixedBytes(this.data);\n  }\n\n  static deserialize(deserializer: Deserializer): G2Bytes {\n    const bytes = deserializer.deserializeFixedBytes(64);\n    return new G2Bytes(bytes);\n  }\n\n  // Convert the projective coordinates to strings\n  toArray(): [string, string][] {\n    const point = this.toProjectivePoint();\n    return [\n      [\n        point.x.c0.toString(), // x real part\n        point.x.c1.toString(),\n      ], // x imaginary part\n      [\n        point.y.c0.toString(), // y real part\n        point.y.c1.toString(),\n      ], // y imaginary part\n      [\n        point.pz.c0.toString(), // z real part\n        point.pz.c1.toString(),\n      ], // z imaginary part\n    ];\n  }\n\n  toProjectivePoint(): ProjPointType<Fp2> {\n    const bytes = new Uint8Array(this.data);\n    // Reverse the bytes to convert from little-endian to big-endian for each part of x.\n    const x0 = bytes.slice(0, 32).reverse();\n    const x1 = bytes.slice(32, 64).reverse();\n    // This gets the flag bit to determine which y to use.\n    const yFlag = (x1[0] & 0x80) >> 7;\n    const { Fp2 } = bn254.fields;\n    const x = Fp2.fromBigTuple([bytesToBn254FpBE(x0), bytesToBn254FpBE(x1)]);\n    const y = Fp2.sqrt(Fp2.add(Fp2.pow(x, 3n), G2Bytes.B));\n    const negY = Fp2.neg(y);\n    const isYGreaterThanNegY = y.c1 > negY.c1 || (y.c1 === negY.c1 && y.c0 > negY.c0);\n    const yToUse = isYGreaterThanNegY === (yFlag === 1) ? y : negY;\n    return bn254.G2.ProjectivePoint.fromAffine({\n      x: x,\n      y: yToUse,\n    });\n  }\n}\n\n/**\n * Represents a Groth16 zero-knowledge proof, consisting of three proof points in compressed serialization format.\n * The points are the compressed serialization of affine representation of the proof.\n *\n * @extends Proof\n * @group Implementation\n * @category Serialization\n */\nexport class Groth16Zkp extends Proof {\n  /**\n   * The bytes of G1 proof point a\n   * @group Implementation\n   * @category Serialization\n   */\n  a: G1Bytes;\n\n  /**\n   * The bytes of G2 proof point b\n   * @group Implementation\n   * @category Serialization\n   */\n  b: G2Bytes;\n\n  /**\n   * The bytes of G1 proof point c\n   * @group Implementation\n   * @category Serialization\n   */\n  c: G1Bytes;\n\n  constructor(args: { a: HexInput; b: HexInput; c: HexInput }) {\n    super();\n    const { a, b, c } = args;\n    this.a = new G1Bytes(a);\n    this.b = new G2Bytes(b);\n    this.c = new G1Bytes(c);\n  }\n\n  serialize(serializer: Serializer): void {\n    this.a.serialize(serializer);\n    this.b.serialize(serializer);\n    this.c.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): Groth16Zkp {\n    const a = G1Bytes.deserialize(deserializer).bcsToBytes();\n    const b = G2Bytes.deserialize(deserializer).bcsToBytes();\n    const c = G1Bytes.deserialize(deserializer).bcsToBytes();\n    return new Groth16Zkp({ a, b, c });\n  }\n\n  toSnarkJsJson() {\n    return {\n      protocol: \"groth16\",\n      curve: \"bn128\",\n      pi_a: this.a.toArray(),\n      pi_b: this.b.toArray(),\n      pi_c: this.c.toArray(),\n    };\n  }\n}\n\n/**\n * Represents a Groth16 proof and statement, consisting of a Groth16 proof and a public inputs hash.\n * This is used to generate the signing message for the training wheels signature.\n *\n * @extends Serializable\n * @group Implementation\n * @category Serialization\n */\nexport class Groth16ProofAndStatement extends Serializable {\n  /**\n   * The Groth16 proof\n   * @group Implementation\n   * @category Serialization\n   */\n  proof: Groth16Zkp;\n\n  /**\n   * The public inputs hash as a 32 byte Uint8Array\n   * @group Implementation\n   * @category Serialization\n   */\n  publicInputsHash: Uint8Array;\n\n  /**\n   * The domain separator prefix used when hashing.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly domainSeparator = \"APTOS::Groth16ProofAndStatement\";\n\n  constructor(proof: Groth16Zkp, publicInputsHash: HexInput | bigint) {\n    super();\n    this.proof = proof;\n    this.publicInputsHash =\n      typeof publicInputsHash === \"bigint\"\n        ? bigIntToBytesLE(publicInputsHash, 32)\n        : Hex.fromHexInput(publicInputsHash).toUint8Array();\n    if (this.publicInputsHash.length !== 32) {\n      throw new Error(\"Invalid public inputs hash\");\n    }\n  }\n\n  serialize(serializer: Serializer): void {\n    this.proof.serialize(serializer);\n    serializer.serializeFixedBytes(this.publicInputsHash);\n  }\n\n  static deserialize(deserializer: Deserializer): Groth16ProofAndStatement {\n    return new Groth16ProofAndStatement(Groth16Zkp.deserialize(deserializer), deserializer.deserializeFixedBytes(32));\n  }\n\n  hash(): Uint8Array {\n    return generateSigningMessage(this.bcsToBytes(), this.domainSeparator);\n  }\n}\n\n/**\n * Represents a container for different types of zero-knowledge proofs.\n *\n * @extends Serializable\n * @group Implementation\n * @category Serialization\n */\nexport class ZkProof extends Serializable {\n  public readonly proof: Proof;\n\n  /**\n   * Index of the underlying enum variant\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly variant: ZkpVariant;\n\n  constructor(proof: Proof, variant: ZkpVariant) {\n    super();\n    this.proof = proof;\n    this.variant = variant;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(this.variant);\n    this.proof.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): ZkProof {\n    const variant = deserializer.deserializeUleb128AsU32();\n    switch (variant) {\n      case ZkpVariant.Groth16:\n        return new ZkProof(Groth16Zkp.deserialize(deserializer), variant);\n      default:\n        throw new Error(`Unknown variant index for ZkProof: ${variant}`);\n    }\n  }\n}\n\n/**\n * Represents a zero-knowledge signature, encapsulating the proof and its associated metadata.\n *\n * @extends Signature\n * @group Implementation\n * @category Serialization\n */\nexport class ZeroKnowledgeSig extends Signature {\n  /**\n   * The proof\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly proof: ZkProof;\n\n  /**\n   * The max lifespan of the proof\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly expHorizonSecs: number;\n\n  /**\n   * A key value pair on the JWT token that can be specified on the signature which would reveal the value on chain.\n   * Can be used to assert identity or other attributes.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly extraField?: string;\n\n  /**\n   * The 'aud' value of the recovery service which is set when recovering an account.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly overrideAudVal?: string;\n\n  /**\n   * The training wheels signature\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly trainingWheelsSignature?: EphemeralSignature;\n\n  constructor(args: {\n    proof: ZkProof;\n    expHorizonSecs: number;\n    extraField?: string;\n    overrideAudVal?: string;\n    trainingWheelsSignature?: EphemeralSignature;\n  }) {\n    super();\n    const { proof, expHorizonSecs, trainingWheelsSignature, extraField, overrideAudVal } = args;\n    this.proof = proof;\n    this.expHorizonSecs = expHorizonSecs;\n    this.trainingWheelsSignature = trainingWheelsSignature;\n    this.extraField = extraField;\n    this.overrideAudVal = overrideAudVal;\n  }\n\n  /**\n   * Deserialize a ZeroKnowledgeSig object from its BCS serialization in bytes.\n   *\n   * @param bytes - The bytes representing the serialized ZeroKnowledgeSig.\n   * @returns ZeroKnowledgeSig - The deserialized ZeroKnowledgeSig object.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromBytes(bytes: Uint8Array): ZeroKnowledgeSig {\n    return ZeroKnowledgeSig.deserialize(new Deserializer(bytes));\n  }\n\n  serialize(serializer: Serializer): void {\n    this.proof.serialize(serializer);\n    serializer.serializeU64(this.expHorizonSecs);\n    serializer.serializeOption(this.extraField);\n    serializer.serializeOption(this.overrideAudVal);\n    serializer.serializeOption(this.trainingWheelsSignature);\n  }\n\n  static deserialize(deserializer: Deserializer): ZeroKnowledgeSig {\n    const proof = ZkProof.deserialize(deserializer);\n    const expHorizonSecs = Number(deserializer.deserializeU64());\n    const extraField = deserializer.deserializeOption(\"string\");\n    const overrideAudVal = deserializer.deserializeOption(\"string\");\n    const trainingWheelsSignature = deserializer.deserializeOption(EphemeralSignature);\n    return new ZeroKnowledgeSig({ proof, expHorizonSecs, trainingWheelsSignature, extraField, overrideAudVal });\n  }\n}\n\n/**\n * Represents the on-chain configuration for how Keyless accounts operate.\n *\n * @remarks\n * This class encapsulates the verification key and the maximum lifespan of ephemeral key pairs,\n * which are essential for the functionality of Keyless accounts.\n * @group Implementation\n * @category Serialization\n */\nexport class KeylessConfiguration {\n  /**\n   * The verification key used to verify Groth16 proofs on chain\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly verificationKey: Groth16VerificationKey;\n\n  /**\n   * The maximum lifespan of an ephemeral key pair.  This is configured on chain.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly maxExpHorizonSecs: number;\n\n  /**\n   * The public key of the training wheels account.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly trainingWheelsPubkey?: EphemeralPublicKey;\n\n  /**\n   * The maximum number of bytes that can be used for the extra field.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly maxExtraFieldBytes: number;\n\n  /**\n   * The maximum number of bytes that can be used for the JWT header.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly maxJwtHeaderB64Bytes: number;\n\n  /**\n   * The maximum number of bytes that can be used for the issuer value.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly maxIssValBytes: number;\n\n  /**\n   * The maximum number of bytes that can be used for the committed ephemeral public key.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly maxCommitedEpkBytes: number;\n\n  constructor(args: {\n    verificationKey: Groth16VerificationKey;\n    trainingWheelsPubkey?: HexInput;\n    maxExpHorizonSecs?: number;\n    maxExtraFieldBytes?: number;\n    maxJwtHeaderB64Bytes?: number;\n    maxIssValBytes?: number;\n    maxCommitedEpkBytes?: number;\n  }) {\n    const {\n      verificationKey,\n      trainingWheelsPubkey,\n      maxExpHorizonSecs = EPK_HORIZON_SECS,\n      maxExtraFieldBytes = MAX_EXTRA_FIELD_BYTES,\n      maxJwtHeaderB64Bytes = MAX_JWT_HEADER_B64_BYTES,\n      maxIssValBytes = MAX_ISS_VAL_BYTES,\n      maxCommitedEpkBytes = MAX_COMMITED_EPK_BYTES,\n    } = args;\n\n    this.verificationKey = verificationKey;\n    this.maxExpHorizonSecs = maxExpHorizonSecs;\n    if (trainingWheelsPubkey) {\n      this.trainingWheelsPubkey = new EphemeralPublicKey(new Ed25519PublicKey(trainingWheelsPubkey));\n    }\n    this.maxExtraFieldBytes = maxExtraFieldBytes;\n    this.maxJwtHeaderB64Bytes = maxJwtHeaderB64Bytes;\n    this.maxIssValBytes = maxIssValBytes;\n    this.maxCommitedEpkBytes = maxCommitedEpkBytes;\n  }\n\n  /**\n   * Creates a new KeylessConfiguration instance from a Groth16VerificationKeyResponse and a KeylessConfigurationResponse.\n   * @param res - The Groth16VerificationKeyResponse object containing the verification key data.\n   * @param config - The KeylessConfigurationResponse object containing the configuration data.\n   * @returns A new KeylessConfiguration instance.\n   */\n  static create(res: Groth16VerificationKeyResponse, config: KeylessConfigurationResponse): KeylessConfiguration {\n    return new KeylessConfiguration({\n      verificationKey: new Groth16VerificationKey({\n        alphaG1: res.alpha_g1,\n        betaG2: res.beta_g2,\n        deltaG2: res.delta_g2,\n        gammaAbcG1: res.gamma_abc_g1,\n        gammaG2: res.gamma_g2,\n      }),\n      maxExpHorizonSecs: Number(config.max_exp_horizon_secs),\n      trainingWheelsPubkey: config.training_wheels_pubkey.vec[0],\n      maxExtraFieldBytes: config.max_extra_field_bytes,\n      maxJwtHeaderB64Bytes: config.max_jwt_header_b64_bytes,\n      maxIssValBytes: config.max_iss_val_bytes,\n      maxCommitedEpkBytes: config.max_commited_epk_bytes,\n    });\n  }\n}\n\n/**\n * Represents the verification key stored on-chain used to verify Groth16 proofs.\n * @group Implementation\n * @category Serialization\n */\nexport class Groth16VerificationKey {\n  // The docstrings below are borrowed from ark-groth16\n\n  /**\n   * The `alpha * G`, where `G` is the generator of G1\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly alphaG1: G1Bytes;\n\n  /**\n   * The `alpha * H`, where `H` is the generator of G2\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly betaG2: G2Bytes;\n\n  /**\n   * The `delta * H`, where `H` is the generator of G2\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly deltaG2: G2Bytes;\n\n  /**\n   * The `gamma^{-1} * (beta * a_i + alpha * b_i + c_i) * H`, where H is the generator of G1\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly gammaAbcG1: [G1Bytes, G1Bytes];\n\n  /**\n   * The `gamma * H`, where `H` is the generator of G2\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly gammaG2: G2Bytes;\n\n  constructor(args: {\n    alphaG1: HexInput;\n    betaG2: HexInput;\n    deltaG2: HexInput;\n    gammaAbcG1: [HexInput, HexInput];\n    gammaG2: HexInput;\n  }) {\n    const { alphaG1, betaG2, deltaG2, gammaAbcG1, gammaG2 } = args;\n    this.alphaG1 = new G1Bytes(alphaG1);\n    this.betaG2 = new G2Bytes(betaG2);\n    this.deltaG2 = new G2Bytes(deltaG2);\n    this.gammaAbcG1 = [new G1Bytes(gammaAbcG1[0]), new G1Bytes(gammaAbcG1[1])];\n    this.gammaG2 = new G2Bytes(gammaG2);\n  }\n\n  /**\n   * Calculates the hash of the serialized form of the verification key.\n   * This is useful for comparing verification keys or using them as unique identifiers.\n   *\n   * @returns The SHA3-256 hash of the serialized verification key as a Uint8Array\n   */\n  public hash(): Uint8Array {\n    const serializer = new Serializer();\n    this.serialize(serializer);\n    return sha3_256.create().update(serializer.toUint8Array()).digest();\n  }\n\n  serialize(serializer: Serializer): void {\n    this.alphaG1.serialize(serializer);\n    this.betaG2.serialize(serializer);\n    this.deltaG2.serialize(serializer);\n    this.gammaAbcG1[0].serialize(serializer);\n    this.gammaAbcG1[1].serialize(serializer);\n    this.gammaG2.serialize(serializer);\n  }\n\n  /**\n   * Converts a Groth16VerificationKeyResponse object into a Groth16VerificationKey instance.\n   *\n   * @param res - The Groth16VerificationKeyResponse object containing the verification key data.\n   * @param res.alpha_g1 - The alpha G1 value from the response.\n   * @param res.beta_g2 - The beta G2 value from the response.\n   * @param res.delta_g2 - The delta G2 value from the response.\n   * @param res.gamma_abc_g1 - The gamma ABC G1 value from the response.\n   * @param res.gamma_g2 - The gamma G2 value from the response.\n   * @returns A Groth16VerificationKey instance constructed from the provided response data.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromGroth16VerificationKeyResponse(res: Groth16VerificationKeyResponse): Groth16VerificationKey {\n    return new Groth16VerificationKey({\n      alphaG1: res.alpha_g1,\n      betaG2: res.beta_g2,\n      deltaG2: res.delta_g2,\n      gammaAbcG1: res.gamma_abc_g1,\n      gammaG2: res.gamma_g2,\n    });\n  }\n\n  /**\n   * Verifies a Groth16 proof using the verification key given the public inputs hash and the proof.\n   *\n   * @param args.publicInputsHash The public inputs hash\n   * @param args.groth16Proof The Groth16 proof\n   * @returns true if the proof is valid\n   */\n  verifyProof(args: { publicInputsHash: bigint; groth16Proof: Groth16Zkp }): boolean {\n    const { publicInputsHash, groth16Proof } = args;\n\n    try {\n      // Get proof points\n      const proofA = groth16Proof.a.toProjectivePoint();\n      const proofB = groth16Proof.b.toProjectivePoint();\n      const proofC = groth16Proof.c.toProjectivePoint();\n\n      // Get verification key points\n      const vkAlpha1 = this.alphaG1.toProjectivePoint();\n      const vkBeta2 = this.betaG2.toProjectivePoint();\n      const vkGamma2 = this.gammaG2.toProjectivePoint();\n      const vkDelta2 = this.deltaG2.toProjectivePoint();\n      const vkIC = this.gammaAbcG1.map((g1) => g1.toProjectivePoint());\n\n      const { Fp12 } = bn254.fields;\n\n      // Check that the following pairing equation holds:\n      // e(A_1, B_2) = e(\\alpha_1, \\beta_2) + e(\\ic_0 + public_inputs_hash \\ic_1, \\gamma_2) + e(C_1, \\delta_2)\n      // Where A_1, B_2, C_1 are the proof points and \\alpha_1, \\beta_2, \\gamma_2, \\delta_2, \\ic_0, \\ic_1\n      // are the verification key points\n\n      // \\ic_0 + public_inputs_hash \\ic_1\n      let accum = vkIC[0].add(vkIC[1].multiply(publicInputsHash));\n      // e(\\ic_0 + public_inputs_hash \\ic_1, \\gamma_2)\n      const pairingAccumGamma = bn254.pairing(accum, vkGamma2);\n      // e(A_1, B_2)\n      const pairingAB = bn254.pairing(proofA, proofB);\n      // e(\\alpha_1, \\beta_2)\n      const pairingAlphaBeta = bn254.pairing(vkAlpha1, vkBeta2);\n      // e(C_1, \\delta_2)\n      const pairingCDelta = bn254.pairing(proofC, vkDelta2);\n      // Get the result of the right hand side of the pairing equation\n      const product = Fp12.mul(pairingAlphaBeta, Fp12.mul(pairingAccumGamma, pairingCDelta));\n      // Check if the left hand side equals the right hand side\n      return Fp12.eql(pairingAB, product);\n    } catch (error) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.PROOF_VERIFICATION_FAILED,\n        error,\n        details: \"Error encountered when checking zero knowledge relation\",\n      });\n    }\n  }\n\n  /**\n   * Converts the verification key to a JSON format compatible with snarkjs groth16.verify\n   *\n   * @returns An object containing the verification key in snarkjs format\n   * @group Implementation\n   * @category Serialization\n   */\n  toSnarkJsJson() {\n    return {\n      protocol: \"groth16\",\n      curve: \"bn128\",\n      nPublic: 1,\n      vk_alpha_1: this.alphaG1.toArray(),\n      vk_beta_2: this.betaG2.toArray(),\n      vk_gamma_2: this.gammaG2.toArray(),\n      vk_delta_2: this.deltaG2.toArray(),\n      IC: this.gammaAbcG1.map((g1) => g1.toArray()),\n    };\n  }\n}\n\n/**\n * Retrieves the configuration parameters for Keyless Accounts on the blockchain, including the verifying key and the maximum\n * expiry horizon.\n *\n * @param args - The arguments for retrieving the keyless configuration.\n * @param args.aptosConfig - The Aptos configuration object containing network details.\n * @param args.options - Optional parameters for the request.\n * @param args.options.ledgerVersion - The ledger version to query; if not provided, the latest version will be used.\n * @returns KeylessConfiguration - The configuration object containing the verifying key and maximum expiry horizon.\n * @group Implementation\n * @category Serialization\n */\nexport async function getKeylessConfig(args: {\n  aptosConfig: AptosConfig;\n  options?: LedgerVersionArg;\n}): Promise<KeylessConfiguration> {\n  const { aptosConfig } = args;\n  try {\n    return await memoizeAsync(\n      async () => {\n        const [config, vk] = await Promise.all([\n          getKeylessConfigurationResource(args),\n          getGroth16VerificationKeyResource(args),\n        ]);\n        return KeylessConfiguration.create(vk, config);\n      },\n      `keyless-configuration-${aptosConfig.network}`,\n      1000 * 60 * 5, // 5 minutes\n    )();\n  } catch (error) {\n    if (error instanceof KeylessError) {\n      throw error;\n    }\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.FULL_NODE_OTHER,\n      error,\n    });\n  }\n}\n\n/**\n * Parses a JWT and returns the 'iss', 'aud', and 'uid' values.\n *\n * @param args - The arguments for parsing the JWT.\n * @param args.jwt - The JWT to parse.\n * @param args.uidKey - The key to use for the 'uid' value; defaults to 'sub'.\n * @returns The 'iss', 'aud', and 'uid' values from the JWT.\n */\nexport function getIssAudAndUidVal(args: { jwt: string; uidKey?: string }): {\n  iss: string;\n  aud: string;\n  uidVal: string;\n} {\n  const { jwt, uidKey = \"sub\" } = args;\n  let jwtPayload: JwtPayload & { [key: string]: string };\n  try {\n    jwtPayload = jwtDecode<JwtPayload & { [key: string]: string }>(jwt);\n  } catch (error) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.JWT_PARSING_ERROR,\n      details: `Failed to parse JWT - ${getErrorMessage(error)}`,\n    });\n  }\n  if (typeof jwtPayload.iss !== \"string\") {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.JWT_PARSING_ERROR,\n      details: \"JWT is missing 'iss' in the payload. This should never happen.\",\n    });\n  }\n  if (typeof jwtPayload.aud !== \"string\") {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.JWT_PARSING_ERROR,\n      details: \"JWT is missing 'aud' in the payload or 'aud' is an array of values.\",\n    });\n  }\n  const uidVal = jwtPayload[uidKey];\n  return { iss: jwtPayload.iss, aud: jwtPayload.aud, uidVal };\n}\n\n/**\n * Retrieves the KeylessConfiguration set on chain.\n *\n * @param args - The arguments for retrieving the configuration.\n * @param args.aptosConfig - The configuration for connecting to the Aptos network.\n * @param args.options - Optional parameters for the request.\n * @param args.options.ledgerVersion - The ledger version to query; if not provided, it will get the latest version.\n * @returns KeylessConfigurationResponse - The response containing the keyless configuration data.\n * @group Implementation\n * @category Serialization\n */\nasync function getKeylessConfigurationResource(args: {\n  aptosConfig: AptosConfig;\n  options?: LedgerVersionArg;\n}): Promise<KeylessConfigurationResponse> {\n  const { aptosConfig, options } = args;\n  const resourceType = \"0x1::keyless_account::Configuration\";\n  try {\n    const { data } = await getAptosFullNode<{}, MoveResource<KeylessConfigurationResponse>>({\n      aptosConfig,\n      originMethod: \"getKeylessConfigurationResource\",\n      path: `accounts/${AccountAddress.from(\"0x1\").toString()}/resource/${resourceType}`,\n      params: { ledger_version: options?.ledgerVersion },\n    });\n    return data.data;\n  } catch (error) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.FULL_NODE_CONFIG_LOOKUP_ERROR,\n      error,\n    });\n  }\n}\n\n/**\n * Retrieves the Groth16VerificationKey set on the blockchain.\n *\n * @param args - The arguments for retrieving the verification key.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.options - Optional parameters for the request.\n * @param args.options.ledgerVersion - The ledger version to query; if not provided, it will get the latest version.\n * @returns Groth16VerificationKeyResponse - The response containing the Groth16 verification key data.\n * @group Implementation\n * @category Serialization\n */\nasync function getGroth16VerificationKeyResource(args: {\n  aptosConfig: AptosConfig;\n  options?: LedgerVersionArg;\n}): Promise<Groth16VerificationKeyResponse> {\n  const { aptosConfig, options } = args;\n  const resourceType = \"0x1::keyless_account::Groth16VerificationKey\";\n  try {\n    const { data } = await getAptosFullNode<{}, MoveResource<Groth16VerificationKeyResponse>>({\n      aptosConfig,\n      originMethod: \"getGroth16VerificationKeyResource\",\n      path: `accounts/${AccountAddress.from(\"0x1\").toString()}/resource/${resourceType}`,\n      params: { ledger_version: options?.ledgerVersion },\n    });\n    return data.data;\n  } catch (error) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.FULL_NODE_VERIFICATION_KEY_LOOKUP_ERROR,\n      error,\n    });\n  }\n}\n\nexport async function getKeylessJWKs(args: {\n  aptosConfig: AptosConfig;\n  jwkAddr?: AccountAddressInput;\n  options?: LedgerVersionArg;\n}): Promise<Map<string, MoveJWK[]>> {\n  const { aptosConfig, jwkAddr, options } = args;\n  let resource: MoveResource<PatchedJWKsResponse>;\n  if (!jwkAddr) {\n    const resourceType = \"0x1::jwks::PatchedJWKs\";\n    const { data } = await getAptosFullNode<{}, MoveResource<PatchedJWKsResponse>>({\n      aptosConfig,\n      originMethod: \"getKeylessJWKs\",\n      path: `accounts/0x1/resource/${resourceType}`,\n      params: { ledger_version: options?.ledgerVersion },\n    });\n    resource = data;\n  } else {\n    const resourceType = \"0x1::jwks::FederatedJWKs\";\n    const { data } = await getAptosFullNode<{}, MoveResource<PatchedJWKsResponse>>({\n      aptosConfig,\n      originMethod: \"getKeylessJWKs\",\n      path: `accounts/${AccountAddress.from(jwkAddr).toString()}/resource/${resourceType}`,\n      params: { ledger_version: options?.ledgerVersion },\n    });\n    resource = data;\n  }\n\n  // Create a map of issuer to JWK arrays\n  const jwkMap = new Map<string, MoveJWK[]>();\n  for (const entry of resource.data.jwks.entries) {\n    const jwks: MoveJWK[] = [];\n    for (const jwkStruct of entry.jwks) {\n      const { data: jwkData } = jwkStruct.variant;\n      const deserializer = new Deserializer(Hex.fromHexInput(jwkData).toUint8Array());\n      const jwk = MoveJWK.deserialize(deserializer);\n      jwks.push(jwk);\n    }\n    jwkMap.set(hexToAsciiString(entry.issuer), jwks);\n  }\n\n  return jwkMap;\n}\n\nexport class MoveJWK extends Serializable {\n  public kid: string;\n\n  public kty: string;\n\n  public alg: string;\n\n  public e: string;\n\n  public n: string;\n\n  constructor(args: { kid: string; kty: string; alg: string; e: string; n: string }) {\n    super();\n    const { kid, kty, alg, e, n } = args;\n    this.kid = kid;\n    this.kty = kty;\n    this.alg = alg;\n    this.e = e;\n    this.n = n;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeStr(this.kid);\n    serializer.serializeStr(this.kty);\n    serializer.serializeStr(this.alg);\n    serializer.serializeStr(this.e);\n    serializer.serializeStr(this.n);\n  }\n\n  static fromMoveStruct(struct: MoveAnyStruct): MoveJWK {\n    const { data } = struct.variant;\n    const deserializer = new Deserializer(Hex.fromHexInput(data).toUint8Array());\n    return MoveJWK.deserialize(deserializer);\n  }\n\n  toScalar(): bigint {\n    if (this.alg !== \"RS256\") {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.PROOF_VERIFICATION_FAILED,\n        details:\n          \"Failed to convert JWK to scalar when calculating the public inputs hash. Only RSA 256 is supported currently\",\n      });\n    }\n    const uint8Array = base64UrlToBytes(this.n);\n    const chunks = chunkInto24Bytes(uint8Array.reverse());\n    const scalars = chunks.map((chunk) => bytesToBigIntLE(chunk));\n    scalars.push(256n); // Add the modulus size\n    return poseidonHash(scalars);\n  }\n\n  static deserialize(deserializer: Deserializer): MoveJWK {\n    const kid = deserializer.deserializeStr();\n    const kty = deserializer.deserializeStr();\n    const alg = deserializer.deserializeStr();\n    const e = deserializer.deserializeStr();\n    const n = deserializer.deserializeStr();\n    return new MoveJWK({ kid, kty, alg, n, e });\n  }\n}\n\nfunction chunkInto24Bytes(data: Uint8Array): Uint8Array[] {\n  const chunks: Uint8Array[] = [];\n  for (let i = 0; i < data.length; i += 24) {\n    const chunk = data.slice(i, Math.min(i + 24, data.length));\n    // Pad last chunk with zeros if needed\n    if (chunk.length < 24) {\n      const paddedChunk = new Uint8Array(24);\n      paddedChunk.set(chunk);\n      chunks.push(paddedChunk);\n    } else {\n      chunks.push(chunk);\n    }\n  }\n  return chunks;\n}\n\ninterface JwtHeader {\n  kid: string; // Key ID\n}\n/**\n * Safely parses the JWT header.\n * @param jwtHeader The JWT header string\n * @returns Parsed JWT header as an object.\n */\nexport function parseJwtHeader(jwtHeader: string): JwtHeader {\n  try {\n    const header = JSON.parse(jwtHeader);\n    if (header.kid === undefined) {\n      throw new Error(\"JWT header missing kid\");\n    }\n    return header;\n  } catch (error) {\n    throw new Error(\"Failed to parse JWT header.\");\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountPublicKey, PublicKey } from \"./publicKey\";\nimport { Deserializer, Serializer } from \"../../bcs\";\nimport { HexInput, AnyPublicKeyVariant, SigningScheme } from \"../../types\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { AccountAddress, AccountAddressInput } from \"../accountAddress\";\nimport {\n  KeylessConfiguration,\n  KeylessPublicKey,\n  KeylessSignature,\n  MoveJWK,\n  verifyKeylessSignature,\n  verifyKeylessSignatureWithJwkAndConfig,\n} from \"./keyless\";\nimport { AptosConfig } from \"../../api\";\nimport { Signature } from \"..\";\n\n/**\n * Represents the FederatedKeylessPublicKey public key\n *\n * These keys use an on-chain address as a source of truth for the JWK used to verify signatures.\n *\n * FederatedKeylessPublicKey authentication key is represented in the SDK as `AnyPublicKey`.\n * @group Implementation\n * @category Serialization\n */\nexport class FederatedKeylessPublicKey extends AccountPublicKey {\n  /**\n   * The address that contains the JWK set to be used for verification.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly jwkAddress: AccountAddress;\n\n  /**\n   * The inner public key which contains the standard Keyless public key.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly keylessPublicKey: KeylessPublicKey;\n\n  constructor(jwkAddress: AccountAddressInput, keylessPublicKey: KeylessPublicKey) {\n    super();\n    this.jwkAddress = AccountAddress.from(jwkAddress);\n    this.keylessPublicKey = keylessPublicKey;\n  }\n\n  /**\n   * Get the authentication key for the federated keyless public key\n   *\n   * @returns AuthenticationKey\n   * @group Implementation\n   * @category Serialization\n   */\n  authKey(): AuthenticationKey {\n    const serializer = new Serializer();\n    serializer.serializeU32AsUleb128(AnyPublicKeyVariant.FederatedKeyless);\n    serializer.serializeFixedBytes(this.bcsToBytes());\n    return AuthenticationKey.fromSchemeAndBytes({\n      scheme: SigningScheme.SingleKey,\n      input: serializer.toUint8Array(),\n    });\n  }\n\n  /**\n   * Verifies a signed data with a public key\n   *\n   * @param args.message message\n   * @param args.signature The signature\n   * @param args.jwk - The JWK to use for verification.\n   * @param args.keylessConfig - The keyless configuration to use for verification.\n   * @returns true if the signature is valid\n   * @group Implementation\n   * @category Serialization\n   */\n  verifySignature(args: {\n    message: HexInput;\n    signature: Signature;\n    jwk: MoveJWK;\n    keylessConfig: KeylessConfiguration;\n  }): boolean {\n    try {\n      verifyKeylessSignatureWithJwkAndConfig({ ...args, publicKey: this });\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  serialize(serializer: Serializer): void {\n    this.jwkAddress.serialize(serializer);\n    this.keylessPublicKey.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): FederatedKeylessPublicKey {\n    const jwkAddress = AccountAddress.deserialize(deserializer);\n    const keylessPublicKey = KeylessPublicKey.deserialize(deserializer);\n    return new FederatedKeylessPublicKey(jwkAddress, keylessPublicKey);\n  }\n\n  static isPublicKey(publicKey: PublicKey): publicKey is FederatedKeylessPublicKey {\n    return publicKey instanceof FederatedKeylessPublicKey;\n  }\n\n  /**\n   * Verifies a keyless signature for a given message.  It will fetch the keyless configuration and the JWK to\n   * use for verification from the appropriate network as defined by the aptosConfig.\n   *\n   * @param args.aptosConfig The aptos config to use for fetching the keyless configuration.\n   * @param args.message The message to verify the signature against.\n   * @param args.signature The signature to verify.\n   * @param args.options.throwErrorWithReason Whether to throw an error with the reason for the failure instead of returning false.\n   * @returns true if the signature is valid\n   */\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: KeylessSignature;\n    options?: { throwErrorWithReason?: boolean };\n  }): Promise<boolean> {\n    return verifyKeylessSignature({\n      ...args,\n      publicKey: this,\n    });\n  }\n\n  /**\n   * Creates a FederatedKeylessPublicKey from the JWT components plus pepper\n   *\n   * @param args.iss the iss of the identity\n   * @param args.uidKey the key to use to get the uidVal in the JWT token\n   * @param args.uidVal the value of the uidKey in the JWT token\n   * @param args.aud the client ID of the application\n   * @param args.pepper The pepper used to maintain privacy of the account\n   * @returns FederatedKeylessPublicKey\n   * @group Implementation\n   * @category Serialization\n   */\n  static create(args: {\n    iss: string;\n    uidKey: string;\n    uidVal: string;\n    aud: string;\n    pepper: HexInput;\n    jwkAddress: AccountAddressInput;\n  }): FederatedKeylessPublicKey {\n    return new FederatedKeylessPublicKey(args.jwkAddress, KeylessPublicKey.create(args));\n  }\n\n  static fromJwtAndPepper(args: {\n    jwt: string;\n    pepper: HexInput;\n    jwkAddress: AccountAddressInput;\n    uidKey?: string;\n  }): FederatedKeylessPublicKey {\n    return new FederatedKeylessPublicKey(args.jwkAddress, KeylessPublicKey.fromJwtAndPepper(args));\n  }\n\n  static isInstance(publicKey: PublicKey) {\n    return (\n      \"jwkAddress\" in publicKey &&\n      publicKey.jwkAddress instanceof AccountAddress &&\n      \"keylessPublicKey\" in publicKey &&\n      publicKey.keylessPublicKey instanceof KeylessPublicKey\n    );\n  }\n}\n","import { Deserializer, Serializer } from \"../../bcs\";\nimport {\n  AnyPublicKeyVariant,\n  AnySignatureVariant,\n  SigningScheme as AuthenticationKeyScheme,\n  HexInput,\n} from \"../../types\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { Ed25519PrivateKey, Ed25519PublicKey, Ed25519Signature } from \"./ed25519\";\nimport { AccountPublicKey, PublicKey } from \"./publicKey\";\nimport { Secp256k1PrivateKey, Secp256k1PublicKey, Secp256k1Signature } from \"./secp256k1\";\nimport { KeylessPublicKey, KeylessSignature } from \"./keyless\";\nimport { Signature } from \"./signature\";\nimport { FederatedKeylessPublicKey } from \"./federatedKeyless\";\nimport { AptosConfig } from \"../../api\";\n\nexport type PrivateKeyInput = Ed25519PrivateKey | Secp256k1PrivateKey;\n\n/**\n * Represents any public key supported by Aptos.\n *\n * Since [AIP-55](https://github.com/aptos-foundation/AIPs/pull/263) Aptos supports\n * `Legacy` and `Unified` authentication keys.\n *\n * Any unified authentication key is represented in the SDK as `AnyPublicKey`.\n * @group Implementation\n * @category Serialization\n */\nexport class AnyPublicKey extends AccountPublicKey {\n  /**\n   * Reference to the inner public key\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly publicKey: PublicKey;\n\n  /**\n   * Index of the underlying enum variant\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly variant: AnyPublicKeyVariant;\n\n  // region Constructors\n\n  /**\n   * Creates an instance of the signature class based on the provided signature type.\n   * This allows for the handling of different signature variants such as Ed25519, Secp256k1, and Keyless.\n   *\n   * @param publicKey - The publicKey object which determines the variant to be used.\n   * @throws Error if the provided signature type is unsupported.\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(publicKey: PublicKey) {\n    super();\n    this.publicKey = publicKey;\n    if (publicKey instanceof Ed25519PublicKey) {\n      this.variant = AnyPublicKeyVariant.Ed25519;\n    } else if (publicKey instanceof Secp256k1PublicKey) {\n      this.variant = AnyPublicKeyVariant.Secp256k1;\n    } else if (publicKey instanceof KeylessPublicKey) {\n      this.variant = AnyPublicKeyVariant.Keyless;\n    } else if (publicKey instanceof FederatedKeylessPublicKey) {\n      this.variant = AnyPublicKeyVariant.FederatedKeyless;\n    } else {\n      throw new Error(\"Unsupported public key type\");\n    }\n  }\n\n  // endregion\n\n  // region AccountPublicKey\n\n  /**\n   * Verifies the provided signature against the given message.\n   * This function helps ensure the integrity and authenticity of the message by confirming that the signature is valid.\n   *\n   * @param args - The arguments for signature verification.\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature to verify, which must be an instance of AnySignature.\n   * @returns A boolean indicating whether the signature is valid for the given message.\n   * @group Implementation\n   * @category Serialization\n   */\n  verifySignature(args: { message: HexInput; signature: AnySignature }): boolean {\n    const { message, signature } = args;\n    if (this.publicKey instanceof KeylessPublicKey) {\n      throw new Error(\"Use verifySignatureAsync to verify Keyless signatures\");\n    }\n    return this.publicKey.verifySignature({\n      message,\n      signature: signature.signature,\n    });\n  }\n\n  /**\n   * Verifies the provided signature against the given message.\n   * This function helps ensure the integrity and authenticity of the message by confirming that the signature is valid.\n   *\n   * @param args - The arguments for signature verification.\n   * @param args.aptosConfig - The configuration object for connecting to the Aptos network\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature to verify, which must be an instance of AnySignature.\n   * @returns A boolean indicating whether the signature is valid for the given message.\n   * @group Implementation\n   * @category Serialization\n   */\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: Signature;\n    options?: { throwErrorWithReason?: boolean };\n  }): Promise<boolean> {\n    if (!(args.signature instanceof AnySignature)) {\n      if (args.options?.throwErrorWithReason) {\n        throw new Error(\"Signature must be an instance of AnySignature\");\n      }\n      return false;\n    }\n    return await this.publicKey.verifySignatureAsync({\n      ...args,\n      signature: args.signature.signature,\n    });\n  }\n\n  /**\n   * Generates an authentication key from the current instance's byte representation.\n   * This function is essential for creating a unique identifier for authentication purposes.\n   *\n   * @returns {AuthenticationKey} The generated authentication key.\n   * @group Implementation\n   * @category Serialization\n   */\n  authKey(): AuthenticationKey {\n    return AuthenticationKey.fromSchemeAndBytes({\n      scheme: AuthenticationKeyScheme.SingleKey,\n      input: this.toUint8Array(),\n    });\n  }\n\n  /**\n   * Get the signature in bytes (Uint8Array).\n   *\n   * This function is a warning that it will soon return the underlying signature bytes directly.\n   * Use AnySignature.bcsToBytes() instead.\n   *\n   * @returns Uint8Array representation of the signature.\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.bcsToBytes();\n  }\n\n  // endregion\n\n  // region Serializable\n\n  /**\n   * Serializes the current object using the provided serializer.\n   * This function helps in converting the object into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category Serialization\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(this.variant);\n    this.publicKey.serialize(serializer);\n  }\n\n  /**\n   * Deserializes an AnySignature from the provided deserializer.\n   * This function helps in reconstructing the AnySignature object from its serialized form, allowing for further processing or validation.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Serialization\n   */\n  static deserialize(deserializer: Deserializer): AnyPublicKey {\n    const variantIndex = deserializer.deserializeUleb128AsU32();\n    let publicKey: PublicKey;\n    switch (variantIndex) {\n      case AnyPublicKeyVariant.Ed25519:\n        publicKey = Ed25519PublicKey.deserialize(deserializer);\n        break;\n      case AnyPublicKeyVariant.Secp256k1:\n        publicKey = Secp256k1PublicKey.deserialize(deserializer);\n        break;\n      case AnyPublicKeyVariant.Keyless:\n        publicKey = KeylessPublicKey.deserialize(deserializer);\n        break;\n      case AnyPublicKeyVariant.FederatedKeyless:\n        publicKey = FederatedKeylessPublicKey.deserialize(deserializer);\n        break;\n      default:\n        throw new Error(`Unknown variant index for AnyPublicKey: ${variantIndex}`);\n    }\n    return new AnyPublicKey(publicKey);\n  }\n  // endregion\n\n  /**\n   * Determines if the provided public key is an instance of AnyPublicKey.\n   *\n   * @param publicKey - The public key to check.\n   * @deprecated Use `instanceof AnyPublicKey` instead.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isPublicKey(publicKey: AccountPublicKey): publicKey is AnyPublicKey {\n    return publicKey instanceof AnyPublicKey;\n  }\n\n  /**\n   * Determines if the current public key is an instance of Ed25519PublicKey.\n   *\n   * @deprecated use `publicKey instanceof Ed25519PublicKey` instead.\n   * @group Implementation\n   * @category Serialization\n   */\n  isEd25519(): boolean {\n    return this.publicKey instanceof Ed25519PublicKey;\n  }\n\n  /**\n   * Checks if the public key is an instance of Secp256k1PublicKey.\n   *\n   * @deprecated use `publicKey instanceof Secp256k1PublicKey` instead.\n   * @group Implementation\n   * @category Serialization\n   */\n  isSecp256k1PublicKey(): boolean {\n    return this.publicKey instanceof Secp256k1PublicKey;\n  }\n\n  /**\n   * Determines if the provided publicKey is an instance of a valid PublicKey object.\n   *\n   * @param publicKey - The publicKey to be checked for validity.\n   * @param publicKey.publicKey - The actual publicKey object that needs to be validated.\n   * @returns True if the signature is a valid instance; otherwise, false.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isInstance(publicKey: PublicKey): publicKey is AnyPublicKey {\n    return \"publicKey\" in publicKey && \"variant\" in publicKey;\n  }\n}\n\n/**\n * Represents a signature that utilizes the SingleKey authentication scheme.\n * This class is designed to encapsulate various types of signatures, which can\n * only be generated by a `SingleKeySigner` due to the shared authentication mechanism.\n *\n * @extends Signature\n * @group Implementation\n * @category Serialization\n */\nexport class AnySignature extends Signature {\n  public readonly signature: Signature;\n\n  /**\n   * Index of the underlying enum variant\n   * @group Implementation\n   * @category Serialization\n   */\n  private readonly variant: AnySignatureVariant;\n\n  // region Constructors\n\n  constructor(signature: Signature) {\n    super();\n    this.signature = signature;\n\n    if (signature instanceof Ed25519Signature) {\n      this.variant = AnySignatureVariant.Ed25519;\n    } else if (signature instanceof Secp256k1Signature) {\n      this.variant = AnySignatureVariant.Secp256k1;\n    } else if (signature instanceof KeylessSignature) {\n      this.variant = AnySignatureVariant.Keyless;\n    } else {\n      throw new Error(\"Unsupported signature type\");\n    }\n  }\n\n  // endregion\n\n  // region AccountSignature\n\n  toUint8Array(): Uint8Array {\n    // TODO: keep this warning around for a bit, and eventually change this to return `this.signature.toUint8Array()`.\n    // eslint-disable-next-line no-console\n    console.warn(\n      \"[Aptos SDK] Calls to AnySignature.toUint8Array() will soon return the underlying signature bytes. \" +\n        \"Use AnySignature.bcsToBytes() instead.\",\n    );\n    return this.bcsToBytes();\n  }\n\n  // endregion\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(this.variant);\n    this.signature.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): AnySignature {\n    const variantIndex = deserializer.deserializeUleb128AsU32();\n    let signature: Signature;\n    switch (variantIndex) {\n      case AnySignatureVariant.Ed25519:\n        signature = Ed25519Signature.deserialize(deserializer);\n        break;\n      case AnySignatureVariant.Secp256k1:\n        signature = Secp256k1Signature.deserialize(deserializer);\n        break;\n      case AnySignatureVariant.Keyless:\n        signature = KeylessSignature.deserialize(deserializer);\n        break;\n      default:\n        throw new Error(`Unknown variant index for AnySignature: ${variantIndex}`);\n    }\n    return new AnySignature(signature);\n  }\n\n  // endregion\n\n  static isInstance(signature: Signature): signature is AnySignature {\n    return (\n      \"signature\" in signature &&\n      typeof signature.signature === \"object\" &&\n      signature.signature !== null &&\n      \"toUint8Array\" in signature.signature\n    );\n  }\n}\n","import { SigningScheme as AuthenticationKeyScheme, HexInput } from \"../../types\";\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializer } from \"../../bcs/serializer\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { AccountPublicKey, PublicKey, VerifySignatureAsyncArgs } from \"./publicKey\";\nimport { Signature } from \"./signature\";\nimport { AnyPublicKey, AnySignature } from \"./singleKey\";\nimport { AptosConfig } from \"../../api\";\n\n/**\n * Counts the number of set bits (1s) in a byte.\n * This function can help you determine the population count of a given byte value.\n *\n * @param byte - The byte value for which to count the number of set bits.\n * @group Implementation\n * @category Serialization\n */\n/* eslint-disable no-bitwise */\nfunction bitCount(byte: number) {\n  let n = byte;\n  n -= (n >> 1) & 0x55555555;\n  n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n  return (((n + (n >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24;\n}\n/* eslint-enable no-bitwise */\n\nexport abstract class AbstractMultiKey extends AccountPublicKey {\n  publicKeys: PublicKey[];\n\n  constructor(args: { publicKeys: PublicKey[] }) {\n    super();\n    this.publicKeys = args.publicKeys;\n  }\n\n  /**\n   * Create a bitmap that holds the mapping from the original public keys\n   * to the signatures passed in\n   *\n   * @param args.bits array of the index mapping to the matching public keys\n   * @returns Uint8array bit map\n   * @group Implementation\n   * @category Serialization\n   */\n  createBitmap(args: { bits: number[] }): Uint8Array {\n    const { bits } = args;\n    // Bits are read from left to right. e.g. 0b10000000 represents the first bit is set in one byte.\n    // The decimal value of 0b10000000 is 128.\n    const firstBitInByte = 128;\n    const bitmap = new Uint8Array([0, 0, 0, 0]);\n\n    // Check if duplicates exist in bits\n    const dupCheckSet = new Set();\n\n    bits.forEach((bit: number, idx: number) => {\n      if (idx + 1 > this.publicKeys.length) {\n        throw new Error(`Signature index ${idx + 1} is out of public keys range, ${this.publicKeys.length}.`);\n      }\n\n      if (dupCheckSet.has(bit)) {\n        throw new Error(`Duplicate bit ${bit} detected.`);\n      }\n\n      dupCheckSet.add(bit);\n\n      const byteOffset = Math.floor(bit / 8);\n\n      let byte = bitmap[byteOffset];\n\n      // eslint-disable-next-line no-bitwise\n      byte |= firstBitInByte >> bit % 8;\n\n      bitmap[byteOffset] = byte;\n    });\n\n    return bitmap;\n  }\n\n  /**\n   * Get the index of the provided public key.\n   *\n   * This function retrieves the index of a specified public key within the MultiKey.\n   * If the public key does not exist, it throws an error.\n   *\n   * @param publicKey - The public key to find the index for.\n   * @returns The corresponding index of the public key, if it exists.\n   * @throws Error - If the public key is not found in the MultiKey.\n   * @group Implementation\n   * @category Serialization\n   */\n  getIndex(publicKey: PublicKey): number {\n    const index = this.publicKeys.findIndex((pk) => pk.toString() === publicKey.toString());\n\n    if (index !== -1) {\n      return index;\n    }\n    throw new Error(`Public key ${publicKey} not found in multi key set ${this.publicKeys}`);\n  }\n}\n\n/**\n * Represents a multi-key authentication scheme for accounts, allowing multiple public keys\n * to be associated with a single account. This class enforces a minimum number of valid signatures\n * required to authorize actions, ensuring enhanced security for multi-agent accounts.\n *\n * The public keys of each individual agent can be any type of public key supported by Aptos.\n * Since [AIP-55](https://github.com/aptos-foundation/AIPs/pull/263), Aptos supports\n * `Legacy` and `Unified` authentication keys.\n * @group Implementation\n * @category Serialization\n */\nexport class MultiKey extends AbstractMultiKey {\n  /**\n   * List of any public keys\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly publicKeys: AnyPublicKey[];\n\n  /**\n   * The minimum number of valid signatures required, for the number of public keys specified\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly signaturesRequired: number;\n\n  /**\n   * Signature for a K-of-N multi-sig transaction.\n   * This constructor initializes a multi-signature transaction with the provided signatures and bitmap.\n   *\n   * @param args An object containing the parameters for the multi-signature transaction.\n   * @param args.signatures A list of signatures.\n   * @param args.bitmap A bitmap represented as a Uint8Array or an array of numbers, where each bit indicates whether a\n   * corresponding signature is present. A maximum of 32 signatures is supported, and the length of the bitmap must be 4 bytes.\n   *\n   * @throws Error if the number of signatures exceeds the maximum supported, if the bitmap length is incorrect, or if the number\n   * of signatures does not match the bitmap.\n   * @group Implementation\n   * @category Serialization\n   */\n  // region Constructors\n  constructor(args: { publicKeys: Array<PublicKey>; signaturesRequired: number }) {\n    const { publicKeys, signaturesRequired } = args;\n    super({ publicKeys });\n\n    // Validate number of public keys is greater than signature required\n    if (signaturesRequired < 1) {\n      throw new Error(\"The number of required signatures needs to be greater than 0\");\n    }\n\n    // Validate number of public keys is greater than signature required\n    if (publicKeys.length < signaturesRequired) {\n      throw new Error(\n        `Provided ${publicKeys.length} public keys is smaller than the ${signaturesRequired} required signatures`,\n      );\n    }\n\n    // Make sure that all keys are normalized to the SingleKey authentication scheme\n    this.publicKeys = publicKeys.map((publicKey) =>\n      publicKey instanceof AnyPublicKey ? publicKey : new AnyPublicKey(publicKey),\n    );\n\n    this.signaturesRequired = signaturesRequired;\n  }\n\n  // endregion\n\n  // region AccountPublicKey\n\n  /**\n   * Verifies the provided signature against the given message.\n   * This function helps ensure the integrity and authenticity of the message by checking if the signature is valid.\n   *\n   * Note: This function will fail if a keyless signature is used.  Use `verifySignatureAsync` instead.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature to verify.\n   * @group Implementation\n   * @category Serialization\n   */\n  verifySignature(args: { message: HexInput; signature: MultiKeySignature }): boolean {\n    const { message, signature } = args;\n    if (signature.signatures.length !== this.signaturesRequired) {\n      throw new Error(\"The number of signatures does not match the number of required signatures\");\n    }\n    const signerIndices = signature.bitMapToSignerIndices();\n    for (let i = 0; i < signature.signatures.length; i += 1) {\n      const singleSignature = signature.signatures[i];\n      const publicKey = this.publicKeys[signerIndices[i]];\n      if (!publicKey.verifySignature({ message, signature: singleSignature })) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Verifies the provided signature against the given message.\n   * This function helps ensure the integrity and authenticity of the message by checking if the signature is valid.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.aptosConfig - The Aptos configuration to use\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature to verify.\n   * @group Implementation\n   * @category Serialization\n   */\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: Signature;\n    options?: { throwErrorWithReason?: boolean };\n  }): Promise<boolean> {\n    const { signature } = args;\n    try {\n      if (!(signature instanceof MultiKeySignature)) {\n        throw new Error(\"Signature is not a MultiKeySignature\");\n      }\n      if (signature.signatures.length !== this.signaturesRequired) {\n        throw new Error(\"The number of signatures does not match the number of required signatures\");\n      }\n      const signerIndices = signature.bitMapToSignerIndices();\n      for (let i = 0; i < signature.signatures.length; i += 1) {\n        const singleSignature = signature.signatures[i];\n        const publicKey = this.publicKeys[signerIndices[i]];\n        if (!(await publicKey.verifySignatureAsync({ ...args, signature: singleSignature }))) {\n          return false;\n        }\n      }\n      return true;\n    } catch (error) {\n      if (args.options?.throwErrorWithReason) {\n        throw error;\n      }\n      return false;\n    }\n  }\n\n  /**\n   * Generates an authentication key based on the current instance's byte representation.\n   * This key can be used for secure authentication processes within the system.\n   *\n   * @returns {AuthenticationKey} The generated authentication key.\n   * @group Implementation\n   * @category Serialization\n   */\n  authKey(): AuthenticationKey {\n    return AuthenticationKey.fromSchemeAndBytes({\n      scheme: AuthenticationKeyScheme.MultiKey,\n      input: this.toUint8Array(),\n    });\n  }\n\n  // endregion\n\n  // region Serializable\n\n  /**\n   * Serializes the object by writing its signatures and bitmap to the provided serializer.\n   * This allows the object to be converted into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category Serialization\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeVector(this.publicKeys);\n    serializer.serializeU8(this.signaturesRequired);\n  }\n\n  /**\n   * Deserializes a MultiKeySignature from the provided deserializer.\n   * This function retrieves the signatures and bitmap necessary for creating a MultiKeySignature object.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Serialization\n   */\n  static deserialize(deserializer: Deserializer): MultiKey {\n    const keys = deserializer.deserializeVector(AnyPublicKey);\n    const signaturesRequired = deserializer.deserializeU8();\n\n    return new MultiKey({ publicKeys: keys, signaturesRequired });\n  }\n\n  // endregion\n\n  /**\n   * Get the index of the provided public key.\n   *\n   * This function retrieves the index of a specified public key within the MultiKey.\n   * If the public key does not exist, it throws an error.\n   *\n   * @param publicKey - The public key to find the index for.\n   * @returns The corresponding index of the public key, if it exists.\n   * @throws Error - If the public key is not found in the MultiKey.\n   * @group Implementation\n   */\n  getIndex(publicKey: PublicKey): number {\n    const anyPublicKey = publicKey instanceof AnyPublicKey ? publicKey : new AnyPublicKey(publicKey);\n    return super.getIndex(anyPublicKey);\n  }\n\n  public static isInstance(value: PublicKey): value is MultiKey {\n    return \"publicKeys\" in value && \"signaturesRequired\" in value;\n  }\n}\n\n/**\n * Represents a multi-signature transaction using Ed25519 signatures.\n * This class allows for the creation and management of a K-of-N multi-signature scheme,\n * where a specified number of signatures are required to authorize a transaction.\n *\n * It includes functionality to validate the number of signatures against a bitmap,\n * which indicates which public keys have signed the transaction.\n * @group Implementation\n * @category Serialization\n */\nexport class MultiKeySignature extends Signature {\n  /**\n   * Number of bytes in the bitmap representing who signed the transaction (32-bits)\n   * @group Implementation\n   * @category Serialization\n   */\n  static BITMAP_LEN: number = 4;\n\n  /**\n   * Maximum number of Ed25519 signatures supported\n   * @group Implementation\n   * @category Serialization\n   */\n  static MAX_SIGNATURES_SUPPORTED = MultiKeySignature.BITMAP_LEN * 8;\n\n  /**\n   * The list of underlying Ed25519 signatures\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly signatures: AnySignature[];\n\n  /**\n   * 32-bit Bitmap representing who signed the transaction\n   *\n   * This is represented where each public key can be masked to determine whether the message was signed by that key.\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly bitmap: Uint8Array;\n\n  /**\n   * Signature for a K-of-N multi-sig transaction.\n   *\n   * @see {@link\n   * https://aptos.dev/integration/creating-a-signed-transaction/#multisignature-transactions | Creating a Signed Transaction}\n   *\n   * @param args.signatures A list of signatures\n   * @param args.bitmap 4 bytes, at most 32 signatures are supported. If Nth bit value is `1`, the Nth\n   * signature should be provided in `signatures`. Bits are read from left to right\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(args: { signatures: Array<Signature | AnySignature>; bitmap: Uint8Array | number[] }) {\n    super();\n    const { signatures, bitmap } = args;\n\n    if (signatures.length > MultiKeySignature.MAX_SIGNATURES_SUPPORTED) {\n      throw new Error(`The number of signatures cannot be greater than ${MultiKeySignature.MAX_SIGNATURES_SUPPORTED}`);\n    }\n\n    // Make sure that all signatures are normalized to the SingleKey authentication scheme\n    this.signatures = signatures.map((signature) =>\n      signature instanceof AnySignature ? signature : new AnySignature(signature),\n    );\n\n    if (!(bitmap instanceof Uint8Array)) {\n      this.bitmap = MultiKeySignature.createBitmap({ bits: bitmap });\n    } else if (bitmap.length !== MultiKeySignature.BITMAP_LEN) {\n      throw new Error(`\"bitmap\" length should be ${MultiKeySignature.BITMAP_LEN}`);\n    } else {\n      this.bitmap = bitmap;\n    }\n\n    const nSignatures = this.bitmap.reduce((acc, byte) => acc + bitCount(byte), 0);\n    if (nSignatures !== this.signatures.length) {\n      throw new Error(`Expecting ${nSignatures} signatures from the bitmap, but got ${this.signatures.length}`);\n    }\n  }\n\n  /**\n   * Helper method to create a bitmap out of the specified bit positions\n   * @param args.bits The bitmap positions that should be set. A position starts at index 0.\n   * Valid position should range between 0 and 31.\n   * @example\n   * Here's an example of valid `bits`\n   * ```\n   * [0, 2, 31]\n   * ```\n   * `[0, 2, 31]` means the 1st, 3rd and 32nd bits should be set in the bitmap.\n   * The result bitmap should be 0b1010000000000000000000000000001\n   *\n   * @returns bitmap that is 32bit long\n   * @group Implementation\n   * @category Serialization\n   */\n  static createBitmap(args: { bits: number[] }): Uint8Array {\n    const { bits } = args;\n    // Bits are read from left to right. e.g. 0b10000000 represents the first bit is set in one byte.\n    // The decimal value of 0b10000000 is 128.\n    const firstBitInByte = 128;\n    const bitmap = new Uint8Array([0, 0, 0, 0]);\n\n    // Check if duplicates exist in bits\n    const dupCheckSet = new Set();\n\n    bits.forEach((bit: number) => {\n      if (bit >= MultiKeySignature.MAX_SIGNATURES_SUPPORTED) {\n        throw new Error(`Cannot have a signature larger than ${MultiKeySignature.MAX_SIGNATURES_SUPPORTED - 1}.`);\n      }\n\n      if (dupCheckSet.has(bit)) {\n        throw new Error(\"Duplicate bits detected.\");\n      }\n\n      dupCheckSet.add(bit);\n\n      const byteOffset = Math.floor(bit / 8);\n\n      let byte = bitmap[byteOffset];\n\n      // eslint-disable-next-line no-bitwise\n      byte |= firstBitInByte >> bit % 8;\n\n      bitmap[byteOffset] = byte;\n    });\n\n    return bitmap;\n  }\n\n  /**\n   * Converts the bitmap to an array of signer indices.\n   *\n   * Example:\n   *\n   * bitmap: [0b10001000, 0b01000000, 0b00000000, 0b00000000]\n   * signerIndices: [0, 4, 9]\n   *\n   * @returns An array of signer indices.\n   * @group Implementation\n   * @category Serialization\n   */\n  bitMapToSignerIndices(): number[] {\n    const signerIndices: number[] = [];\n    for (let i = 0; i < this.bitmap.length; i += 1) {\n      const byte = this.bitmap[i];\n      for (let bit = 0; bit < 8; bit += 1) {\n        if ((byte & (128 >> bit)) !== 0) {\n          signerIndices.push(i * 8 + bit);\n        }\n      }\n    }\n    return signerIndices;\n  }\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    // Note: we should not need to serialize the vector length, as it can be derived from the bitmap\n    serializer.serializeVector(this.signatures);\n    serializer.serializeBytes(this.bitmap);\n  }\n\n  static deserialize(deserializer: Deserializer): MultiKeySignature {\n    const signatures = deserializer.deserializeVector(AnySignature);\n    const bitmap = deserializer.deserializeBytes();\n    return new MultiKeySignature({ signatures, bitmap });\n  }\n\n  // endregion\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AptosConfig } from \"../../api\";\nimport { Deserializer, Serializer } from \"../../bcs\";\nimport { SigningScheme as AuthenticationKeyScheme, HexInput } from \"../../types\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"./ed25519\";\nimport { AbstractMultiKey } from \"./multiKey\";\nimport { Signature } from \"./signature\";\n\n/**\n * Represents the public key of a K-of-N Ed25519 multi-sig transaction.\n *\n * A K-of-N multi-sig transaction requires at least K out of N authorized signers to sign the transaction\n * for it to be executed. This class encapsulates the logic for managing the public keys and the threshold\n * for valid signatures.\n *\n * @see {@link https://aptos.dev/integration/creating-a-signed-transaction/ | Creating a Signed Transaction}\n * @group Implementation\n * @category Serialization\n */\nexport class MultiEd25519PublicKey extends AbstractMultiKey {\n  /**\n   * Maximum number of public keys supported\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly MAX_KEYS = 32;\n\n  /**\n   * Minimum number of public keys needed\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly MIN_KEYS = 2;\n\n  /**\n   * Minimum threshold for the number of valid signatures required\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly MIN_THRESHOLD = 1;\n\n  /**\n   * List of Ed25519 public keys for this LegacyMultiEd25519PublicKey\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly publicKeys: Ed25519PublicKey[];\n\n  /**\n   * The minimum number of valid signatures required, for the number of public keys specified\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly threshold: number;\n\n  /**\n   * Public key for a K-of-N multi-sig transaction. A K-of-N multi-sig transaction means that for such a\n   * transaction to be executed, at least K out of the N authorized signers have signed the transaction\n   * and passed the check conducted by the chain.\n   *\n   * @see {@link\n   * https://aptos.dev/integration/creating-a-signed-transaction/ | Creating a Signed Transaction}\n   * @param args - A wrapper to let you choose the param order.\n   * @param args.publicKeys A list of public keys\n   * @param args.threshold At least \"threshold\" signatures must be valid\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(args: { publicKeys: Ed25519PublicKey[]; threshold: number }) {\n    const { publicKeys, threshold } = args;\n    super({ publicKeys });\n\n    // Validate number of public keys\n    if (publicKeys.length > MultiEd25519PublicKey.MAX_KEYS || publicKeys.length < MultiEd25519PublicKey.MIN_KEYS) {\n      throw new Error(\n        `Must have between ${MultiEd25519PublicKey.MIN_KEYS} and ` +\n          `${MultiEd25519PublicKey.MAX_KEYS} public keys, inclusive`,\n      );\n    }\n\n    // Validate threshold: must be between 1 and the number of public keys, inclusive\n    if (threshold < MultiEd25519PublicKey.MIN_THRESHOLD || threshold > publicKeys.length) {\n      throw new Error(\n        `Threshold must be between ${MultiEd25519PublicKey.MIN_THRESHOLD} and ${publicKeys.length}, inclusive`,\n      );\n    }\n\n    this.publicKeys = publicKeys;\n    this.threshold = threshold;\n  }\n\n  // region AccountPublicKey\n\n  /**\n   * Verifies a multi-signature against a given message.\n   * This function ensures that the provided signatures meet the required threshold and are valid for the given message.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.message - The message that was signed.\n   * @param args.signature - The multi-signature containing multiple signatures and a bitmap indicating which signatures are valid.\n   * @returns True if the signature is valid; otherwise, false.\n   * @throws Error if the bitmap and signatures length mismatch or if there are not enough valid signatures.\n   * @group Implementation\n   * @category Serialization\n   */\n  verifySignature(args: { message: HexInput; signature: Signature }): boolean {\n    const { message, signature } = args;\n    if (!(signature instanceof MultiEd25519Signature)) {\n      return false;\n    }\n\n    const indices: number[] = [];\n    for (let i = 0; i < 4; i += 1) {\n      for (let j = 0; j < 8; j += 1) {\n        // eslint-disable-next-line no-bitwise\n        const bitIsSet = (signature.bitmap[i] & (1 << (7 - j))) !== 0;\n        if (bitIsSet) {\n          const index = i * 8 + j;\n          indices.push(index);\n        }\n      }\n    }\n\n    if (indices.length !== signature.signatures.length) {\n      throw new Error(\"Bitmap and signatures length mismatch\");\n    }\n\n    if (indices.length < this.threshold) {\n      throw new Error(\"Not enough signatures\");\n    }\n\n    for (let i = 0; i < indices.length; i += 1) {\n      const publicKey = this.publicKeys[indices[i]];\n      if (!publicKey.verifySignature({ message, signature: signature.signatures[i] })) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: Signature;\n  }): Promise<boolean> {\n    return this.verifySignature(args);\n  }\n\n  /**\n   * Generates an authentication key based on the current instance's byte representation.\n   * This function is essential for creating a secure authentication key that can be used for various cryptographic operations.\n   *\n   * @returns {AuthenticationKey} The generated authentication key.\n   * @group Implementation\n   * @category Serialization\n   */\n  authKey(): AuthenticationKey {\n    return AuthenticationKey.fromSchemeAndBytes({\n      scheme: AuthenticationKeyScheme.MultiEd25519,\n      input: this.toUint8Array(),\n    });\n  }\n\n  /**\n   * Converts a PublicKeys into Uint8Array (bytes) with: bytes = p1_bytes | ... | pn_bytes | threshold\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    const bytes = new Uint8Array(this.publicKeys.length * Ed25519PublicKey.LENGTH + 1);\n    this.publicKeys.forEach((k: Ed25519PublicKey, i: number) => {\n      bytes.set(k.toUint8Array(), i * Ed25519PublicKey.LENGTH);\n    });\n\n    bytes[this.publicKeys.length * Ed25519PublicKey.LENGTH] = this.threshold;\n\n    return bytes;\n  }\n\n  // endregion\n\n  // region Serializable\n\n  /**\n   * Serializes the current instance into bytes using the provided serializer.\n   * This allows for the conversion of the instance's data into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer used to convert the instance into bytes.\n   * @group Implementation\n   * @category Serialization\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n\n  /**\n   * Deserializes a MultiEd25519Signature from the provided deserializer.\n   * This function helps in reconstructing a MultiEd25519Signature object from its serialized byte representation.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Serialization\n   */\n  static deserialize(deserializer: Deserializer): MultiEd25519PublicKey {\n    const bytes = deserializer.deserializeBytes();\n    const threshold = bytes[bytes.length - 1];\n\n    const keys: Ed25519PublicKey[] = [];\n\n    for (let i = 0; i < bytes.length - 1; i += Ed25519PublicKey.LENGTH) {\n      const begin = i;\n      keys.push(new Ed25519PublicKey(bytes.subarray(begin, begin + Ed25519PublicKey.LENGTH)));\n    }\n    return new MultiEd25519PublicKey({ publicKeys: keys, threshold });\n  }\n\n  // endregion\n\n  /**\n   * Get the index of the provided public key.\n   *\n   * This function retrieves the index of a specified public key within the MultiKey.\n   * If the public key does not exist, it throws an error.\n   *\n   * @param publicKey - The public key to find the index for.\n   * @returns The corresponding index of the public key, if it exists.\n   * @throws Error - If the public key is not found in the MultiKey.\n   * @group Implementation\n   */\n  getIndex(publicKey: Ed25519PublicKey): number {\n    return super.getIndex(publicKey);\n  }\n}\n\n/**\n * Represents the signature of a K-of-N Ed25519 multi-sig transaction.\n *\n * @see {@link https://aptos.dev/integration/creating-a-signed-transaction/#multisignature-transactions | Creating a Signed Transaction}\n * @group Implementation\n * @category Serialization\n */\nexport class MultiEd25519Signature extends Signature {\n  /**\n   * Maximum number of Ed25519 signatures supported\n   * @group Implementation\n   * @category Serialization\n   */\n  static MAX_SIGNATURES_SUPPORTED = 32;\n\n  /**\n   * Number of bytes in the bitmap representing who signed the transaction (32-bits)\n   * @group Implementation\n   * @category Serialization\n   */\n  static BITMAP_LEN: number = 4;\n\n  /**\n   * The list of underlying Ed25519 signatures\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly signatures: Ed25519Signature[];\n\n  /**\n   * 32-bit Bitmap representing who signed the transaction\n   *\n   * This is represented where each public key can be masked to determine whether the message was signed by that key.\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly bitmap: Uint8Array;\n\n  /**\n   * Signature for a K-of-N multi-sig transaction.\n   *\n   * @see {@link\n   * https://aptos.dev/integration/creating-a-signed-transaction/#multisignature-transactions | Creating a Signed Transaction}\n   *\n   * @param args.signatures A list of signatures\n   * @param args.bitmap 4 bytes, at most 32 signatures are supported. If Nth bit value is `1`, the Nth\n   * signature should be provided in `signatures`. Bits are read from left to right.\n   * Alternatively, you can specify an array of bitmap positions.\n   * Valid position should range between 0 and 31.\n   * @see MultiEd25519Signature.createBitmap\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(args: { signatures: Ed25519Signature[]; bitmap: Uint8Array | number[] }) {\n    super();\n    const { signatures, bitmap } = args;\n\n    if (signatures.length > MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED) {\n      throw new Error(\n        `The number of signatures cannot be greater than ${MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED}`,\n      );\n    }\n    this.signatures = signatures;\n\n    if (!(bitmap instanceof Uint8Array)) {\n      this.bitmap = MultiEd25519Signature.createBitmap({ bits: bitmap });\n    } else if (bitmap.length !== MultiEd25519Signature.BITMAP_LEN) {\n      throw new Error(`\"bitmap\" length should be ${MultiEd25519Signature.BITMAP_LEN}`);\n    } else {\n      this.bitmap = bitmap;\n    }\n  }\n\n  // region AccountSignature\n\n  /**\n   * Converts a MultiSignature into Uint8Array (bytes) with `bytes = s1_bytes | ... | sn_bytes | bitmap`\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    const bytes = new Uint8Array(this.signatures.length * Ed25519Signature.LENGTH + MultiEd25519Signature.BITMAP_LEN);\n    this.signatures.forEach((k: Ed25519Signature, i: number) => {\n      bytes.set(k.toUint8Array(), i * Ed25519Signature.LENGTH);\n    });\n\n    bytes.set(this.bitmap, this.signatures.length * Ed25519Signature.LENGTH);\n\n    return bytes;\n  }\n\n  // endregion\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): MultiEd25519Signature {\n    const bytes = deserializer.deserializeBytes();\n    const bitmap = bytes.subarray(bytes.length - 4);\n\n    const signatures: Ed25519Signature[] = [];\n\n    for (let i = 0; i < bytes.length - bitmap.length; i += Ed25519Signature.LENGTH) {\n      const begin = i;\n      signatures.push(new Ed25519Signature(bytes.subarray(begin, begin + Ed25519Signature.LENGTH)));\n    }\n    return new MultiEd25519Signature({ signatures, bitmap });\n  }\n\n  // endregion\n\n  /**\n   * Helper method to create a bitmap out of the specified bit positions.\n   * This function allows you to set specific bits in a 32-bit long bitmap based on the provided positions.\n   *\n   * @param args The arguments for creating the bitmap.\n   * @param args.bits The bitmap positions that should be set. A position starts at index 0. Valid positions should range between 0 and 31.\n   *\n   * @example\n   * Here's an example of valid `bits`\n   * ```\n   * [0, 2, 31]\n   * ```\n   * `[0, 2, 31]` means the 1st, 3rd and 32nd bits should be set in the bitmap.\n   * The result bitmap should be 0b1010000000000000000000000000001\n   *\n   * @returns bitmap that is 32 bits long.\n   * @group Implementation\n   * @category Serialization\n   */\n  static createBitmap(args: { bits: number[] }): Uint8Array {\n    const { bits } = args;\n    // Bits are read from left to right. e.g. 0b10000000 represents the first bit is set in one byte.\n    // The decimal value of 0b10000000 is 128.\n    const firstBitInByte = 128;\n    const bitmap = new Uint8Array([0, 0, 0, 0]);\n\n    // Check if duplicates exist in bits\n    const dupCheckSet = new Set();\n\n    bits.forEach((bit: number, index) => {\n      if (bit >= MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED) {\n        throw new Error(`Cannot have a signature larger than ${MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED - 1}.`);\n      }\n\n      if (dupCheckSet.has(bit)) {\n        throw new Error(\"Duplicate bits detected.\");\n      }\n\n      if (index > 0 && bit <= bits[index - 1]) {\n        throw new Error(\"The bits need to be sorted in ascending order.\");\n      }\n\n      dupCheckSet.add(bit);\n\n      const byteOffset = Math.floor(bit / 8);\n\n      let byte = bitmap[byteOffset];\n\n      // eslint-disable-next-line no-bitwise\n      byte |= firstBitInByte >> bit % 8;\n\n      bitmap[byteOffset] = byte;\n    });\n\n    return bitmap;\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { Serializer, Deserializer, Serializable } from \"../../bcs\";\nimport { AnyPublicKey, AnySignature } from \"../../core/crypto\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"../../core/crypto/ed25519\";\nimport { MultiEd25519PublicKey, MultiEd25519Signature } from \"../../core/crypto/multiEd25519\";\nimport { MultiKey, MultiKeySignature } from \"../../core/crypto/multiKey\";\nimport { AccountAuthenticatorVariant, HexInput, MoveFunctionId } from \"../../types\";\nimport { AbstractionAuthDataVariant } from \"../../types/abstraction\";\nimport { AccountAddress, Hex } from \"../../core\";\nimport { getFunctionParts, isValidFunctionInfo } from \"../../utils/helpers\";\n\n/**\n * Represents an account authenticator that can handle multiple authentication variants.\n * This class serves as a base for different types of account authenticators, allowing for serialization\n * and deserialization of various authenticator types.\n *\n * @extends Serializable\n * @group Implementation\n * @category Transactions\n */\nexport abstract class AccountAuthenticator extends Serializable {\n  abstract serialize(serializer: Serializer): void;\n\n  /**\n   * Deserializes an AccountAuthenticator from the provided deserializer.\n   * This function helps in reconstructing the AccountAuthenticator object based on the variant index.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static deserialize(deserializer: Deserializer): AccountAuthenticator {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case AccountAuthenticatorVariant.Ed25519:\n        return AccountAuthenticatorEd25519.load(deserializer);\n      case AccountAuthenticatorVariant.MultiEd25519:\n        return AccountAuthenticatorMultiEd25519.load(deserializer);\n      case AccountAuthenticatorVariant.SingleKey:\n        return AccountAuthenticatorSingleKey.load(deserializer);\n      case AccountAuthenticatorVariant.MultiKey:\n        return AccountAuthenticatorMultiKey.load(deserializer);\n      case AccountAuthenticatorVariant.NoAccountAuthenticator:\n        return AccountAuthenticatorNoAccountAuthenticator.load(deserializer);\n      case AccountAuthenticatorVariant.Abstraction:\n        return AccountAuthenticatorAbstraction.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for AccountAuthenticator: ${index}`);\n    }\n  }\n\n  /**\n   * Determines if the current instance is an Ed25519 account authenticator.\n   *\n   * @returns {boolean} True if the instance is of type AccountAuthenticatorEd25519, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isEd25519(): this is AccountAuthenticatorEd25519 {\n    return this instanceof AccountAuthenticatorEd25519;\n  }\n\n  /**\n   * Determines if the current instance is of type AccountAuthenticatorMultiEd25519.\n   *\n   * @returns {boolean} True if the instance is a multi-signature Ed25519 account authenticator, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isMultiEd25519(): this is AccountAuthenticatorMultiEd25519 {\n    return this instanceof AccountAuthenticatorMultiEd25519;\n  }\n\n  /**\n   * Determines if the current instance is of the type AccountAuthenticatorSingleKey.\n   *\n   * @returns {boolean} True if the instance is an AccountAuthenticatorSingleKey, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isSingleKey(): this is AccountAuthenticatorSingleKey {\n    return this instanceof AccountAuthenticatorSingleKey;\n  }\n\n  /**\n   * Determine if the current instance is of type AccountAuthenticatorMultiKey.\n   *\n   * @returns {boolean} Returns true if the instance is an AccountAuthenticatorMultiKey, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isMultiKey(): this is AccountAuthenticatorMultiKey {\n    return this instanceof AccountAuthenticatorMultiKey;\n  }\n}\n\n/**\n * Represents an Ed25519 transaction authenticator for multi-signer transactions.\n * This class encapsulates the account's Ed25519 public key and signature.\n *\n * @param public_key - The Ed25519 public key associated with the account.\n * @param signature - The Ed25519 signature for the account.\n * @group Implementation\n * @category Transactions\n */\nexport class AccountAuthenticatorEd25519 extends AccountAuthenticator {\n  public readonly public_key: Ed25519PublicKey;\n\n  public readonly signature: Ed25519Signature;\n\n  /**\n   * Creates an instance of the class with the specified public keys and signatures.\n   *\n   * @param public_key The public key used for verification.\n   * @param signature The signatures corresponding to the public keys.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(public_key: Ed25519PublicKey, signature: Ed25519Signature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n\n  /**\n   * Serializes the account authenticator data into the provided serializer.\n   * This function captures the multi-key variant, public keys, and signatures for serialization.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category Transactions\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(AccountAuthenticatorVariant.Ed25519);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n\n  /**\n   * Loads an instance of AccountAuthenticatorMultiKey from the provided deserializer.\n   * This function helps in reconstructing the authenticator object using the deserialized public keys and signatures.\n   *\n   * @param deserializer - The deserializer used to extract the necessary data for loading the authenticator.\n   * @group Implementation\n   * @category Transactions\n   */\n  static load(deserializer: Deserializer): AccountAuthenticatorEd25519 {\n    const public_key = Ed25519PublicKey.deserialize(deserializer);\n    const signature = Ed25519Signature.deserialize(deserializer);\n    return new AccountAuthenticatorEd25519(public_key, signature);\n  }\n}\n\n/**\n * Represents a transaction authenticator for Multi Ed25519, designed for multi-signer transactions.\n *\n * @param public_key - The MultiEd25519 public key of the account.\n * @param signature - The MultiEd25519 signature of the account.\n * @group Implementation\n * @category Transactions\n */\nexport class AccountAuthenticatorMultiEd25519 extends AccountAuthenticator {\n  public readonly public_key: MultiEd25519PublicKey;\n\n  public readonly signature: MultiEd25519Signature;\n\n  constructor(public_key: MultiEd25519PublicKey, signature: MultiEd25519Signature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(AccountAuthenticatorVariant.MultiEd25519);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): AccountAuthenticatorMultiEd25519 {\n    const public_key = MultiEd25519PublicKey.deserialize(deserializer);\n    const signature = MultiEd25519Signature.deserialize(deserializer);\n    return new AccountAuthenticatorMultiEd25519(public_key, signature);\n  }\n}\n\n/**\n * Represents an account authenticator that utilizes a single key for signing.\n * This class is designed to handle authentication using a public key and its corresponding signature.\n *\n * @param public_key - The public key used for authentication.\n * @param signature - The signature associated with the public key.\n * @group Implementation\n * @category Transactions\n */\nexport class AccountAuthenticatorSingleKey extends AccountAuthenticator {\n  public readonly public_key: AnyPublicKey;\n\n  public readonly signature: AnySignature;\n\n  constructor(public_key: AnyPublicKey, signature: AnySignature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(AccountAuthenticatorVariant.SingleKey);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): AccountAuthenticatorSingleKey {\n    const public_key = AnyPublicKey.deserialize(deserializer);\n    const signature = AnySignature.deserialize(deserializer);\n    return new AccountAuthenticatorSingleKey(public_key, signature);\n  }\n}\n\n/**\n * Represents an account authenticator that supports multiple keys and signatures for multi-signature scenarios.\n *\n * @param public_keys - The public keys used for authentication.\n * @param signatures - The signatures corresponding to the public keys.\n * @group Implementation\n * @category Transactions\n */\nexport class AccountAuthenticatorMultiKey extends AccountAuthenticator {\n  public readonly public_keys: MultiKey;\n\n  public readonly signatures: MultiKeySignature;\n\n  constructor(public_keys: MultiKey, signatures: MultiKeySignature) {\n    super();\n    this.public_keys = public_keys;\n    this.signatures = signatures;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(AccountAuthenticatorVariant.MultiKey);\n    this.public_keys.serialize(serializer);\n    this.signatures.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): AccountAuthenticatorMultiKey {\n    const public_keys = MultiKey.deserialize(deserializer);\n    const signatures = MultiKeySignature.deserialize(deserializer);\n    return new AccountAuthenticatorMultiKey(public_keys, signatures);\n  }\n}\n\n/**\n * AccountAuthenticatorNoAccountAuthenticator for no account authenticator\n * It represents the absence of a public key for transaction simulation.\n * It allows skipping the public/auth key check during the simulation.\n */\nexport class AccountAuthenticatorNoAccountAuthenticator extends AccountAuthenticator {\n  // eslint-disable-next-line class-methods-use-this\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(AccountAuthenticatorVariant.NoAccountAuthenticator);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  static load(deserializer: Deserializer): AccountAuthenticatorNoAccountAuthenticator {\n    return new AccountAuthenticatorNoAccountAuthenticator();\n  }\n}\n\nexport class AccountAuthenticatorAbstraction extends AccountAuthenticator {\n  public readonly functionInfo: string;\n\n  public readonly signingMessageDigest: Hex;\n\n  public readonly authenticator: Uint8Array;\n\n  /**\n   * DAA, which is extended of the AA module, requires an account identity\n   */\n  public readonly accountIdentity?: Uint8Array;\n\n  constructor(\n    functionInfo: string,\n    signingMessageDigest: HexInput,\n    authenticator: Uint8Array,\n    accountIdentity?: Uint8Array,\n  ) {\n    super();\n    if (!isValidFunctionInfo(functionInfo)) {\n      throw new Error(`Invalid function info ${functionInfo} passed into AccountAuthenticatorAbstraction`);\n    }\n    this.functionInfo = functionInfo;\n    this.authenticator = authenticator;\n    this.signingMessageDigest = Hex.fromHexInput(Hex.fromHexInput(signingMessageDigest).toUint8Array());\n    this.accountIdentity = accountIdentity;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(AccountAuthenticatorVariant.Abstraction);\n    const { moduleAddress, moduleName, functionName } = getFunctionParts(this.functionInfo as MoveFunctionId);\n    AccountAddress.fromString(moduleAddress).serialize(serializer);\n    serializer.serializeStr(moduleName);\n    serializer.serializeStr(functionName);\n    if (this.accountIdentity) {\n      serializer.serializeU32AsUleb128(AbstractionAuthDataVariant.DerivableV1);\n    } else {\n      serializer.serializeU32AsUleb128(AbstractionAuthDataVariant.V1);\n    }\n    serializer.serializeBytes(this.signingMessageDigest.toUint8Array());\n    if (this.accountIdentity) {\n      serializer.serializeBytes(this.authenticator);\n    } else {\n      serializer.serializeFixedBytes(this.authenticator);\n    }\n\n    if (this.accountIdentity) {\n      serializer.serializeBytes(this.accountIdentity);\n    }\n  }\n\n  static load(deserializer: Deserializer): AccountAuthenticatorAbstraction {\n    const moduleAddress = AccountAddress.deserialize(deserializer);\n    const moduleName = deserializer.deserializeStr();\n    const functionName = deserializer.deserializeStr();\n    const variant = deserializer.deserializeUleb128AsU32();\n    if (variant === AbstractionAuthDataVariant.V1) {\n      const signingMessageDigest = deserializer.deserializeBytes();\n      const authenticator = deserializer.deserializeFixedBytes(deserializer.remaining());\n      return new AccountAuthenticatorAbstraction(\n        `${moduleAddress}::${moduleName}::${functionName}`,\n        signingMessageDigest,\n        authenticator,\n      );\n    }\n    if (variant === AbstractionAuthDataVariant.DerivableV1) {\n      const signingMessageDigest = deserializer.deserializeBytes();\n      const abstractSignature = deserializer.deserializeBytes();\n\n      const abstractPublicKey = deserializer.deserializeBytes();\n      return new AccountAuthenticatorAbstraction(\n        `${moduleAddress}::${moduleName}::${functionName}`,\n        signingMessageDigest,\n        abstractSignature,\n        abstractPublicKey,\n      );\n    }\n    throw new Error(`Unknown variant index for AccountAuthenticatorAbstraction: ${variant}`);\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file handles the generation of the signing message.\n * @group Implementation\n * @category Transactions\n */\nimport { sha3_256 as sha3Hash } from \"@noble/hashes/sha3\";\nimport { RAW_TRANSACTION_SALT, RAW_TRANSACTION_WITH_DATA_SALT } from \"../../utils/const\";\nimport { FeePayerRawTransaction, MultiAgentRawTransaction } from \"../instances\";\nimport { AnyRawTransaction, AnyRawTransactionInstance } from \"../types\";\nimport { Serializable } from \"../../bcs\";\n\n/**\n * Derives the appropriate raw transaction type based on the provided transaction details.\n * This function helps in identifying whether the transaction is a FeePayerRawTransaction,\n * MultiAgentRawTransaction, or a standard RawTransaction.\n *\n * @param transaction - An object representing an Aptos transaction, which may include:\n *   - feePayerAddress - The address of the fee payer (optional).\n *   - secondarySignerAddresses - An array of secondary signer addresses (optional).\n *   - rawTransaction - The raw transaction data.\n *\n * @returns FeePayerRawTransaction | MultiAgentRawTransaction | RawTransaction\n * @group Implementation\n * @category Transactions\n */\nexport function deriveTransactionType(transaction: AnyRawTransaction): AnyRawTransactionInstance {\n  if (transaction.feePayerAddress) {\n    return new FeePayerRawTransaction(\n      transaction.rawTransaction,\n      transaction.secondarySignerAddresses ?? [],\n      transaction.feePayerAddress,\n    );\n  }\n  if (transaction.secondarySignerAddresses) {\n    return new MultiAgentRawTransaction(transaction.rawTransaction, transaction.secondarySignerAddresses);\n  }\n\n  return transaction.rawTransaction;\n}\n\n/**\n * Generates the 'signing message' form of a message to be signed.\n * This function combines a domain separator with the byte representation of the message to create a signing message.\n *\n * @param bytes - The byte representation of the message to be signed and sent to the chain.\n * @param domainSeparator - A domain separator that starts with 'APTOS::'.\n *\n * @returns The Uint8Array of the signing message.\n * @group Implementation\n * @category Transactions\n */\nexport function generateSigningMessage(bytes: Uint8Array, domainSeparator: string): Uint8Array {\n  const hash = sha3Hash.create();\n\n  if (!domainSeparator.startsWith(\"APTOS::\")) {\n    throw new Error(`Domain separator needs to start with 'APTOS::'.  Provided - ${domainSeparator}`);\n  }\n\n  hash.update(domainSeparator);\n\n  const prefix = hash.digest();\n\n  const body = bytes;\n\n  const mergedArray = new Uint8Array(prefix.length + body.length);\n  mergedArray.set(prefix);\n  mergedArray.set(body, prefix.length);\n\n  return mergedArray;\n}\n\n/**\n * @deprecated\n * Use CryptoHashable instead by having your class implement it and call hash() to get the signing message.\n *\n * Generates the 'signing message' form of a serializable value by serializing it and using the constructor name as the domain\n * separator.\n *\n * @param serializable - An object that has a BCS serialized form.\n *\n * @returns The Uint8Array of the signing message.\n * @group Implementation\n * @category Transactions\n */\nexport function generateSigningMessageForSerializable(serializable: Serializable): Uint8Array {\n  return generateSigningMessage(serializable.bcsToBytes(), `APTOS::${serializable.constructor.name}`);\n}\n\n/**\n * Generates the 'signing message' form of a transaction by deriving the type of transaction and applying the appropriate domain\n * separator based on the presence of a fee payer or secondary signers.\n *\n * @param transaction - A transaction that is to be signed, which can include a fee payer address or secondary signer addresses.\n *\n * @returns The Uint8Array of the signing message.\n * @group Implementation\n * @category Transactions\n */\nexport function generateSigningMessageForTransaction(transaction: AnyRawTransaction): Uint8Array {\n  const rawTxn = deriveTransactionType(transaction);\n  if (transaction.feePayerAddress) {\n    return generateSigningMessage(rawTxn.bcsToBytes(), RAW_TRANSACTION_WITH_DATA_SALT);\n  }\n  if (transaction.secondarySignerAddresses) {\n    return generateSigningMessage(rawTxn.bcsToBytes(), RAW_TRANSACTION_WITH_DATA_SALT);\n  }\n  return generateSigningMessage(rawTxn.bcsToBytes(), RAW_TRANSACTION_SALT);\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { AccountAddress } from \"../../core\";\nimport { Identifier } from \"./identifier\";\nimport { MoveModuleId } from \"../../types\";\n\n/**\n * Represents a ModuleId that can be serialized and deserialized.\n * A ModuleId consists of a module address (e.g., \"0x1\") and a module name (e.g., \"coin\").\n * @group Implementation\n * @category Transactions\n */\nexport class ModuleId extends Serializable {\n  public readonly address: AccountAddress;\n\n  public readonly name: Identifier;\n\n  /**\n   * Initializes a new instance of the module with the specified account address and name.\n   *\n   * @param address - The account address, e.g., \"0x1\".\n   * @param name - The module name under the specified address, e.g., \"coin\".\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(address: AccountAddress, name: Identifier) {\n    super();\n    this.address = address;\n    this.name = name;\n  }\n\n  /**\n   * Converts a string literal in the format \"account_address::module_name\" to a ModuleId.\n   * @param moduleId - A string literal representing the module identifier.\n   * @throws Error if the provided moduleId is not in the correct format.\n   * @returns ModuleId - The corresponding ModuleId object.\n   * @group Implementation\n   * @category Transactions\n   */\n  static fromStr(moduleId: MoveModuleId): ModuleId {\n    const parts = moduleId.split(\"::\");\n    if (parts.length !== 2) {\n      throw new Error(\"Invalid module id.\");\n    }\n    return new ModuleId(AccountAddress.fromString(parts[0]), new Identifier(parts[1]));\n  }\n\n  /**\n   * Serializes the address and name properties using the provided serializer.\n   * This function is essential for converting the object's data into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category Transactions\n   */\n  serialize(serializer: Serializer): void {\n    this.address.serialize(serializer);\n    this.name.serialize(serializer);\n  }\n\n  /**\n   * Deserializes a ModuleId from the provided deserializer.\n   * This function retrieves the account address and identifier to construct a ModuleId instance.\n   *\n   * @param deserializer - The deserializer instance used to read the data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static deserialize(deserializer: Deserializer): ModuleId {\n    const address = AccountAddress.deserialize(deserializer);\n    const name = Identifier.deserialize(deserializer);\n    return new ModuleId(address, name);\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable class-methods-use-this */\n/* eslint-disable max-classes-per-file */\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { AccountAddress } from \"../../core\";\nimport { Identifier } from \"../instances/identifier\";\nimport { TypeTagVariants } from \"../../types\";\n\n/**\n * Represents a type tag in the serialization framework, serving as a base class for various specific type tags.\n * This class provides methods for serialization and deserialization of type tags, as well as type checking methods\n * to determine the specific type of the tag at runtime.\n *\n * @extends Serializable\n * @group Implementation\n * @category Transactions\n */\nexport abstract class TypeTag extends Serializable {\n  abstract serialize(serializer: Serializer): void;\n\n  /**\n   * Deserializes a StructTag from the provided deserializer.\n   * This function allows you to reconstruct a StructTag object from its serialized form.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Transactions\n   */\n  deserialize(deserializer: Deserializer): StructTag {\n    const address = AccountAddress.deserialize(deserializer);\n    const moduleName = Identifier.deserialize(deserializer);\n    const name = Identifier.deserialize(deserializer);\n    const typeArgs = deserializer.deserializeVector(TypeTag);\n    return new StructTag(address, moduleName, name, typeArgs);\n  }\n\n  static deserialize(deserializer: Deserializer): TypeTag {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case TypeTagVariants.Bool:\n        return TypeTagBool.load(deserializer);\n      case TypeTagVariants.U8:\n        return TypeTagU8.load(deserializer);\n      case TypeTagVariants.U64:\n        return TypeTagU64.load(deserializer);\n      case TypeTagVariants.U128:\n        return TypeTagU128.load(deserializer);\n      case TypeTagVariants.Address:\n        return TypeTagAddress.load(deserializer);\n      case TypeTagVariants.Signer:\n        return TypeTagSigner.load(deserializer);\n      case TypeTagVariants.Vector:\n        return TypeTagVector.load(deserializer);\n      case TypeTagVariants.Struct:\n        return TypeTagStruct.load(deserializer);\n      case TypeTagVariants.U16:\n        return TypeTagU16.load(deserializer);\n      case TypeTagVariants.U32:\n        return TypeTagU32.load(deserializer);\n      case TypeTagVariants.U256:\n        return TypeTagU256.load(deserializer);\n      case TypeTagVariants.Generic:\n        // This is only used for ABI representation, and cannot actually be used as a type.\n        return TypeTagGeneric.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for TypeTag: ${index}`);\n    }\n  }\n\n  abstract toString(): string;\n\n  /**\n   * Determines if the current instance is of type TypeTagBool.\n   *\n   * @returns {boolean} True if the instance is a TypeTagBool, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isBool(): this is TypeTagBool {\n    return this instanceof TypeTagBool;\n  }\n\n  /**\n   * Determines if the current instance is of type TypeTagAddress.\n   *\n   * @returns {boolean} True if the instance is a TypeTagAddress, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isAddress(): this is TypeTagAddress {\n    return this instanceof TypeTagAddress;\n  }\n\n  /**\n   * Determines if the current instance is of type TypeTagGeneric.\n   *\n   * @returns {boolean} Returns true if the instance is a TypeTagGeneric, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isGeneric(): this is TypeTagGeneric {\n    return this instanceof TypeTagGeneric;\n  }\n\n  /**\n   * Determine if the current instance is a TypeTagSigner.\n   *\n   * @returns {boolean} Returns true if the instance is a TypeTagSigner, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isSigner(): this is TypeTagSigner {\n    return this instanceof TypeTagSigner;\n  }\n\n  /**\n   * Checks if the current instance is a vector type.\n   * This can help determine the specific type of data structure being used.\n   *\n   * @returns {boolean} True if the instance is of type TypeTagVector, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isVector(): this is TypeTagVector {\n    return this instanceof TypeTagVector;\n  }\n\n  /**\n   * Determines if the current instance is a structure type.\n   *\n   * @returns {boolean} True if the instance is of type TypeTagStruct, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isStruct(): this is TypeTagStruct {\n    return this instanceof TypeTagStruct;\n  }\n\n  /**\n   * Determines if the current instance is of type `TypeTagU8`.\n   *\n   * @returns {boolean} Returns true if the instance is of type `TypeTagU8`, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isU8(): this is TypeTagU8 {\n    return this instanceof TypeTagU8;\n  }\n\n  /**\n   * Checks if the current instance is of type TypeTagU16.\n   *\n   * @returns {boolean} True if the instance is TypeTagU16, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isU16(): this is TypeTagU16 {\n    return this instanceof TypeTagU16;\n  }\n\n  /**\n   * Checks if the current instance is of type TypeTagU32.\n   *\n   * @returns {boolean} Returns true if the instance is TypeTagU32, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isU32(): this is TypeTagU32 {\n    return this instanceof TypeTagU32;\n  }\n\n  /**\n   * Checks if the current instance is of type TypeTagU64.\n   *\n   * @returns {boolean} True if the instance is a TypeTagU64, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isU64(): this is TypeTagU64 {\n    return this instanceof TypeTagU64;\n  }\n\n  /**\n   * Determines if the current instance is of the TypeTagU128 type.\n   *\n   * @returns {boolean} True if the instance is of TypeTagU128, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isU128(): this is TypeTagU128 {\n    return this instanceof TypeTagU128;\n  }\n\n  /**\n   * Checks if the current instance is of type TypeTagU256.\n   *\n   * @returns {boolean} Returns true if the instance is of type TypeTagU256, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isU256(): this is TypeTagU256 {\n    return this instanceof TypeTagU256;\n  }\n\n  isPrimitive(): boolean {\n    return (\n      this instanceof TypeTagSigner ||\n      this instanceof TypeTagAddress ||\n      this instanceof TypeTagBool ||\n      this instanceof TypeTagU8 ||\n      this instanceof TypeTagU16 ||\n      this instanceof TypeTagU32 ||\n      this instanceof TypeTagU64 ||\n      this instanceof TypeTagU128 ||\n      this instanceof TypeTagU256\n    );\n  }\n}\n\n/**\n * Represents a boolean type tag in the type system.\n * This class extends the base TypeTag class and provides\n * methods for serialization and deserialization of the boolean\n * type tag.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagBool extends TypeTag {\n  /**\n   * Returns the string representation of the object.\n   *\n   * @returns {string} The string representation of the object.\n   * @group Implementation\n   * @category Transactions\n   */\n  toString(): string {\n    return \"bool\";\n  }\n\n  /**\n   * Serializes the current instance's properties into a provided serializer.\n   * This function ensures that the address, module name, name, and type arguments are properly serialized.\n   *\n   * @param serializer - The serializer instance used to serialize the properties.\n   * @group Implementation\n   * @category Transactions\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Bool);\n  }\n\n  /**\n   * Deserializes a StructTag and returns a new TypeTagStruct instance.\n   *\n   * @param _deserializer - The deserializer used to read the StructTag data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static load(_deserializer: Deserializer): TypeTagBool {\n    return new TypeTagBool();\n  }\n}\n\n/**\n * Represents a type tag for an 8-bit unsigned integer (u8).\n * This class extends the base TypeTag class and provides methods\n * for serialization and deserialization specific to the u8 type.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagU8 extends TypeTag {\n  toString(): string {\n    return \"u8\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U8);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU8 {\n    return new TypeTagU8();\n  }\n}\n\n/**\n * Represents a type tag for unsigned 16-bit integers (u16).\n * This class extends the base TypeTag class and provides methods for serialization and deserialization.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagU16 extends TypeTag {\n  toString(): string {\n    return \"u16\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U16);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU16 {\n    return new TypeTagU16();\n  }\n}\n\n/**\n * Represents a type tag for a 32-bit unsigned integer (u32).\n * This class extends the base TypeTag class and provides methods for serialization\n * and deserialization specific to the u32 type.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagU32 extends TypeTag {\n  toString(): string {\n    return \"u32\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U32);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU32 {\n    return new TypeTagU32();\n  }\n}\n\n/**\n * Represents a type tag for 64-bit unsigned integers (u64).\n * This class extends the base TypeTag class and provides methods for serialization and deserialization.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagU64 extends TypeTag {\n  toString(): string {\n    return \"u64\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U64);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU64 {\n    return new TypeTagU64();\n  }\n}\n\n/**\n * Represents a type tag for the u128 data type.\n * This class extends the base TypeTag class and provides methods for serialization and deserialization.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagU128 extends TypeTag {\n  toString(): string {\n    return \"u128\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U128);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU128 {\n    return new TypeTagU128();\n  }\n}\n\n/**\n * Represents a type tag for the U256 data type.\n * This class extends the base TypeTag class and provides methods for serialization and deserialization.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagU256 extends TypeTag {\n  toString(): string {\n    return \"u256\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U256);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU256 {\n    return new TypeTagU256();\n  }\n}\n\n/**\n * Represents a type tag for an address in the system.\n * This class extends the TypeTag class and provides functionality\n * to serialize the address type and load it from a deserializer.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagAddress extends TypeTag {\n  toString(): string {\n    return \"address\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Address);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagAddress {\n    return new TypeTagAddress();\n  }\n}\n\n/**\n * Represents a type tag for a signer in the system.\n * This class extends the base TypeTag and provides specific functionality\n * related to the signer type.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagSigner extends TypeTag {\n  toString(): string {\n    return \"signer\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Signer);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagSigner {\n    return new TypeTagSigner();\n  }\n}\n\n/**\n * Represents a reference to a type tag in the type system.\n * This class extends the TypeTag class and provides functionality\n * to serialize and deserialize type tag references.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagReference extends TypeTag {\n  toString(): `&${string}` {\n    return `&${this.value.toString()}`;\n  }\n\n  /**\n   * Initializes a new instance of the class with the specified parameters.\n   *\n   * @param value - The TypeTag to reference.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(public readonly value: TypeTag) {\n    super();\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Reference);\n  }\n\n  static load(deserializer: Deserializer): TypeTagReference {\n    const value = TypeTag.deserialize(deserializer);\n    return new TypeTagReference(value);\n  }\n}\n\n/**\n * Represents a generic type tag used for type parameters in entry functions.\n * Generics are not serialized into a real type, so they cannot be used as a type directly.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagGeneric extends TypeTag {\n  toString(): `T${number}` {\n    return `T${this.value}`;\n  }\n\n  constructor(public readonly value: number) {\n    super();\n    if (value < 0) throw new Error(\"Generic type parameter index cannot be negative\");\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Generic);\n    serializer.serializeU32(this.value);\n  }\n\n  static load(deserializer: Deserializer): TypeTagGeneric {\n    const value = deserializer.deserializeU32();\n    return new TypeTagGeneric(value);\n  }\n}\n\n/**\n * Represents a vector type tag, which encapsulates a single type tag value.\n * This class extends the base TypeTag class and provides methods for serialization,\n * deserialization, and string representation of the vector type tag.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagVector extends TypeTag {\n  toString(): `vector<${string}>` {\n    return `vector<${this.value.toString()}>`;\n  }\n\n  constructor(public readonly value: TypeTag) {\n    super();\n  }\n\n  /**\n   * Creates a new TypeTagVector instance with a TypeTagU8 type.\n   *\n   * @returns {TypeTagVector} A new TypeTagVector initialized with TypeTagU8.\n   * @group Implementation\n   * @category Transactions\n   */\n  static u8(): TypeTagVector {\n    return new TypeTagVector(new TypeTagU8());\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Vector);\n    this.value.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TypeTagVector {\n    const value = TypeTag.deserialize(deserializer);\n    return new TypeTagVector(value);\n  }\n}\n\n/**\n * Represents a structured type tag in the system, extending the base TypeTag class.\n * This class encapsulates information about a specific structure, including its address,\n * module name, and type arguments, and provides methods for serialization and type checking.\n *\n * @param value - The StructTag instance containing the details of the structured type.\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagStruct extends TypeTag {\n  toString(): `0x${string}::${string}::${string}` {\n    // Collect type args and add it if there are any\n    let typePredicate = \"\";\n    if (this.value.typeArgs.length > 0) {\n      typePredicate = `<${this.value.typeArgs.map((typeArg) => typeArg.toString()).join(\", \")}>`;\n    }\n\n    return `${this.value.address.toString()}::${this.value.moduleName.identifier}::${\n      this.value.name.identifier\n    }${typePredicate}`;\n  }\n\n  constructor(public readonly value: StructTag) {\n    super();\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Struct);\n    this.value.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TypeTagStruct {\n    const value = StructTag.deserialize(deserializer);\n    return new TypeTagStruct(value);\n  }\n\n  /**\n   * Determines if the provided address, module name, and struct name match the current type tag.\n   *\n   * @param address - The account address to compare against the type tag.\n   * @param moduleName - The name of the module to compare against the type tag.\n   * @param structName - The name of the struct to compare against the type tag.\n   * @returns True if the address, module name, and struct name match the type tag; otherwise, false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isTypeTag(address: AccountAddress, moduleName: string, structName: string): boolean {\n    return (\n      this.value.moduleName.identifier === moduleName &&\n      this.value.name.identifier === structName &&\n      this.value.address.equals(address)\n    );\n  }\n\n  /**\n   * Checks if the provided value is of type string.\n   * This function can help ensure that the data being processed is in the correct format before further operations.\n   *\n   * @returns {boolean} Returns true if the value is a string, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isString(): boolean {\n    return this.isTypeTag(AccountAddress.ONE, \"string\", \"String\");\n  }\n\n  /**\n   * Checks if the specified account address is of type \"option\".\n   *\n   * @returns {boolean} Returns true if the account address is an option type, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isOption(): boolean {\n    return this.isTypeTag(AccountAddress.ONE, \"option\", \"Option\");\n  }\n\n  /**\n   * Checks if the provided value is of type 'object'.\n   * This function helps determine if a value can be treated as an object type in the context of the SDK.\n   *\n   * @returns {boolean} Returns true if the value is an object, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isObject(): boolean {\n    return this.isTypeTag(AccountAddress.ONE, \"object\", \"Object\");\n  }\n\n  /**\n   * Checks if the provided value is a 'DelegationKey' for permissioned signers.\n   *\n   * @returns {boolean} Returns true if the value is a DelegationKey, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isDelegationKey(): boolean {\n    return this.isTypeTag(AccountAddress.ONE, \"permissioned_delegation\", \"DelegationKey\");\n  }\n\n  /**\n   * Checks if the provided value is of type `RateLimiter`.\n   *\n   * @returns {boolean} Returns true if the value is a RateLimiter, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isRateLimiter(): boolean {\n    return this.isTypeTag(AccountAddress.ONE, \"rate_limiter\", \"RateLimiter\");\n  }\n}\n\n/**\n * Represents a structured tag that includes an address, module name,\n * name, and type arguments. This class is used to define and manage\n * structured data types within the SDK.\n *\n * @property {AccountAddress} address - The address associated with the struct tag.\n * @property {Identifier} moduleName - The name of the module that contains the struct.\n * @property {Identifier} name - The name of the struct.\n * @property {Array<TypeTag>} typeArgs - An array of type arguments associated with the struct.\n * @group Implementation\n * @category Transactions\n */\nexport class StructTag extends Serializable {\n  public readonly address: AccountAddress;\n\n  public readonly moduleName: Identifier;\n\n  public readonly name: Identifier;\n\n  public readonly typeArgs: Array<TypeTag>;\n\n  constructor(address: AccountAddress, module_name: Identifier, name: Identifier, type_args: Array<TypeTag>) {\n    super();\n    this.address = address;\n    this.moduleName = module_name;\n    this.name = name;\n    this.typeArgs = type_args;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serialize(this.address);\n    serializer.serialize(this.moduleName);\n    serializer.serialize(this.name);\n    serializer.serializeVector(this.typeArgs);\n  }\n\n  static deserialize(deserializer: Deserializer): StructTag {\n    const address = AccountAddress.deserialize(deserializer);\n    const moduleName = Identifier.deserialize(deserializer);\n    const name = Identifier.deserialize(deserializer);\n    const typeArgs = deserializer.deserializeVector(TypeTag);\n    return new StructTag(address, moduleName, name, typeArgs);\n  }\n}\n\n/**\n * Retrieves the StructTag for the AptosCoin, which represents the Aptos Coin in the Aptos blockchain.\n *\n * @returns {StructTag} The StructTag for the AptosCoin.\n * @group Implementation\n * @category Transactions\n */\nexport function aptosCoinStructTag(): StructTag {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"aptos_coin\"), new Identifier(\"AptosCoin\"), []);\n}\n\n/**\n * Returns a new StructTag representing a string type.\n *\n * @returns {StructTag} A StructTag for the string type.\n * @group Implementation\n * @category Transactions\n */\nexport function stringStructTag(): StructTag {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"string\"), new Identifier(\"String\"), []);\n}\n\n/**\n * Creates a new StructTag for the Option type with the specified type argument.\n * This can help in defining a specific instance of an Option type in your application.\n *\n * @param typeArg - The type tag that specifies the type of the value contained in the Option.\n * @group Implementation\n * @category Transactions\n */\nexport function optionStructTag(typeArg: TypeTag): StructTag {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"option\"), new Identifier(\"Option\"), [typeArg]);\n}\n\n/**\n * Creates a new StructTag for the Object type with the specified type argument.\n * This function helps in defining a structured representation of an Object with a specific type.\n *\n * @param typeArg - The type tag that specifies the type of the Object.\n * @group Implementation\n * @category Transactions\n */\nexport function objectStructTag(typeArg: TypeTag): StructTag {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"object\"), new Identifier(\"Object\"), [typeArg]);\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { EntryFunctionBytes } from \"../../bcs/serializable/entryFunctionBytes\";\nimport { Bool, U128, U16, U256, U32, U64, U8 } from \"../../bcs/serializable/movePrimitives\";\nimport { MoveVector, Serialized } from \"../../bcs/serializable/moveStructs\";\nimport { AccountAddress } from \"../../core\";\nimport { Identifier } from \"./identifier\";\nimport { ModuleId } from \"./moduleId\";\nimport type { EntryFunctionArgument, ScriptFunctionArgument, TransactionArgument } from \"./transactionArgument\";\nimport { MoveModuleId, ScriptTransactionArgumentVariants, TransactionPayloadVariants } from \"../../types\";\nimport { TypeTag } from \"../typeTag\";\n\n/**\n * Deserialize a Script Transaction Argument.\n * This function retrieves and deserializes various types of script transaction arguments based on the provided deserializer.\n *\n * @param deserializer - The deserializer used to read the script transaction argument.\n * @returns The deserialized script transaction argument.\n * @throws Error if the variant index is unknown.\n * @group Implementation\n * @category Transactions\n */\nexport function deserializeFromScriptArgument(deserializer: Deserializer): TransactionArgument {\n  // index enum variant\n  const index = deserializer.deserializeUleb128AsU32();\n  switch (index) {\n    case ScriptTransactionArgumentVariants.U8:\n      return U8.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U64:\n      return U64.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U128:\n      return U128.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.Address:\n      return AccountAddress.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U8Vector:\n      return MoveVector.deserialize(deserializer, U8);\n    case ScriptTransactionArgumentVariants.Bool:\n      return Bool.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U16:\n      return U16.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U32:\n      return U32.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U256:\n      return U256.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.Serialized:\n      return Serialized.deserialize(deserializer);\n    default:\n      throw new Error(`Unknown variant index for ScriptTransactionArgument: ${index}`);\n  }\n}\n\n/**\n * Represents a supported Transaction Payload that can be serialized and deserialized.\n *\n * This class serves as a base for different types of transaction payloads, allowing for\n * their serialization into a format suitable for transmission and deserialization back\n * into their original form.\n * @group Implementation\n * @category Transactions\n */\nexport abstract class TransactionPayload extends Serializable {\n  /**\n   * Serialize a Transaction Payload\n   * @group Implementation\n   * @category Transactions\n   */\n  abstract serialize(serializer: Serializer): void;\n\n  /**\n   * Deserialize a Transaction Payload\n   * @group Implementation\n   * @category Transactions\n   */\n\n  /**\n   * Deserializes a multisig transaction payload from the provided deserializer.\n   * This function enables the reconstruction of a MultiSigTransactionPayload object from its serialized form.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static deserialize(deserializer: Deserializer): TransactionPayload {\n    // index enum variant\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case TransactionPayloadVariants.Script:\n        return TransactionPayloadScript.load(deserializer);\n      case TransactionPayloadVariants.EntryFunction:\n        return TransactionPayloadEntryFunction.load(deserializer);\n      case TransactionPayloadVariants.Multisig:\n        return TransactionPayloadMultiSig.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for TransactionPayload: ${index}`);\n    }\n  }\n}\n\n/**\n * Represents a transaction payload script that can be serialized and deserialized.\n *\n * This class encapsulates a script that defines the logic for a transaction payload.\n *\n * @extends TransactionPayload\n * @group Implementation\n * @category Transactions\n */\nexport class TransactionPayloadScript extends TransactionPayload {\n  public readonly script: Script;\n\n  /**\n   * Initializes a multi-sig account transaction with the provided payload.\n   *\n   * @param script - The payload of the multi-sig transaction. This can only be an EntryFunction for now, but Script might be\n   * supported in the future.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(script: Script) {\n    super();\n    this.script = script;\n  }\n\n  /**\n   * Serializes the transaction payload, enabling future support for multiple types of inner transaction payloads.\n   *\n   * @param serializer - The serializer instance used to serialize the transaction data.\n   * @group Implementation\n   * @category Transactions\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionPayloadVariants.Script);\n    this.script.serialize(serializer);\n  }\n\n  /**\n   * Loads a MultiSig transaction payload from the provided deserializer.\n   * This function helps in reconstructing a MultiSig transaction payload from its serialized form.\n   *\n   * @param deserializer - The deserializer used to read the serialized data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static load(deserializer: Deserializer): TransactionPayloadScript {\n    const script = Script.deserialize(deserializer);\n    return new TransactionPayloadScript(script);\n  }\n}\n\n/**\n * Represents a transaction payload entry function that can be serialized and deserialized.\n *\n * @extends TransactionPayload\n * @group Implementation\n * @category Transactions\n */\nexport class TransactionPayloadEntryFunction extends TransactionPayload {\n  public readonly entryFunction: EntryFunction;\n\n  constructor(entryFunction: EntryFunction) {\n    super();\n    this.entryFunction = entryFunction;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionPayloadVariants.EntryFunction);\n    this.entryFunction.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionPayloadEntryFunction {\n    const entryFunction = EntryFunction.deserialize(deserializer);\n    return new TransactionPayloadEntryFunction(entryFunction);\n  }\n}\n\n/**\n * Represents a multi-signature transaction payload that can be serialized and deserialized.\n * @group Implementation\n * @category Transactions\n */\nexport class TransactionPayloadMultiSig extends TransactionPayload {\n  public readonly multiSig: MultiSig;\n\n  constructor(multiSig: MultiSig) {\n    super();\n    this.multiSig = multiSig;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionPayloadVariants.Multisig);\n    this.multiSig.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionPayloadMultiSig {\n    const value = MultiSig.deserialize(deserializer);\n    return new TransactionPayloadMultiSig(value);\n  }\n}\n\n/**\n * Represents an entry function that can be serialized and deserialized.\n * This class encapsulates the details required to invoke a function within a module,\n * including the module name, function name, type arguments, and function arguments.\n *\n * @param module_name - Fully qualified module name in the format \"account_address::module_name\" (e.g., \"0x1::coin\").\n * @param function_name - The name of the function (e.g., \"transfer\").\n * @param type_args - Type arguments required by the Move function.\n * @param args - Arguments to the Move function.\n * @group Implementation\n * @category Transactions\n */\nexport class EntryFunction {\n  public readonly module_name: ModuleId;\n\n  public readonly function_name: Identifier;\n\n  public readonly type_args: Array<TypeTag>;\n\n  public readonly args: Array<EntryFunctionArgument>;\n\n  /**\n   * Contains the payload to run a function within a module.\n   * @param module_name Fully qualified module name in format \"account_address::module_name\" e.g. \"0x1::coin\"\n   * @param function_name The function name. e.g \"transfer\"\n   * @param type_args Type arguments that move function requires.\n   *\n   * @example\n   * A coin transfer function has one type argument \"CoinType\".\n   * ```\n   * public entry fun transfer<CoinType>(from: &signer, to: address, amount: u64)\n   * ```\n   * @param args arguments to the move function.\n   *\n   * @example\n   * A coin transfer function has three arguments \"from\", \"to\" and \"amount\".\n   * ```\n   * public entry fun transfer<CoinType>(from: &signer, to: address, amount: u64)\n   * ```\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(\n    module_name: ModuleId,\n    function_name: Identifier,\n    type_args: Array<TypeTag>,\n    args: Array<EntryFunctionArgument>,\n  ) {\n    this.module_name = module_name;\n    this.function_name = function_name;\n    this.type_args = type_args;\n    this.args = args;\n  }\n\n  /**\n   * Build an EntryFunction payload from raw primitive values.\n   *\n   * @param module_id - Fully qualified module name in the format \"AccountAddress::module_id\", e.g., \"0x1::coin\".\n   * @param function_name - The name of the function to be called.\n   * @param type_args - Type arguments that the Move function requires.\n   * @param args - Arguments to the Move function.\n   *\n   * @example\n   * A coin transfer function has one type argument \"CoinType\".\n   * ```\n   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64)\n   * ```\n   *\n   * A coin transfer function has three arguments \"from\", \"to\", and \"amount\".\n   * ```\n   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64)\n   * ```\n   *\n   * @returns EntryFunction\n   * @group Implementation\n   * @category Transactions\n   */\n  static build(\n    module_id: MoveModuleId,\n    function_name: string,\n    type_args: Array<TypeTag>,\n    args: Array<EntryFunctionArgument>,\n  ): EntryFunction {\n    return new EntryFunction(ModuleId.fromStr(module_id), new Identifier(function_name), type_args, args);\n  }\n\n  serialize(serializer: Serializer): void {\n    this.module_name.serialize(serializer);\n    this.function_name.serialize(serializer);\n    serializer.serializeVector<TypeTag>(this.type_args);\n    serializer.serializeU32AsUleb128(this.args.length);\n    this.args.forEach((item: EntryFunctionArgument) => {\n      item.serializeForEntryFunction(serializer);\n    });\n  }\n\n  /**\n   * Deserializes an entry function payload with the arguments represented as EntryFunctionBytes instances.\n   * @see EntryFunctionBytes\n   *\n   * NOTE: When you deserialize an EntryFunction payload with this method, the entry function\n   * arguments are populated into the deserialized instance as type-agnostic, raw fixed bytes\n   * in the form of the EntryFunctionBytes class.\n   *\n   * In order to correctly deserialize these arguments as their actual type representations, you\n   * must know the types of the arguments beforehand and deserialize them yourself individually.\n   *\n   * One way you could achieve this is by using the ABIs for an entry function and deserializing each\n   * argument as its given, corresponding type.\n   *\n   * @param deserializer\n   * @returns A deserialized EntryFunction payload for a transaction.\n   *\n   * @group Implementation\n   * @category Transactions\n   */\n  static deserialize(deserializer: Deserializer): EntryFunction {\n    const module_name = ModuleId.deserialize(deserializer);\n    const function_name = Identifier.deserialize(deserializer);\n    const type_args = deserializer.deserializeVector(TypeTag);\n\n    const length = deserializer.deserializeUleb128AsU32();\n    const args: Array<EntryFunctionArgument> = new Array<EntryFunctionBytes>();\n\n    for (let i = 0; i < length; i += 1) {\n      const fixedBytesLength = deserializer.deserializeUleb128AsU32();\n      const fixedBytes = EntryFunctionBytes.deserialize(deserializer, fixedBytesLength);\n      args.push(fixedBytes);\n    }\n\n    return new EntryFunction(module_name, function_name, type_args, args);\n  }\n}\n\n/**\n * Represents a Script that can be serialized and deserialized.\n * Scripts contain the Move bytecode payload that can be submitted to the Aptos chain for execution.\n * @group Implementation\n * @category Transactions\n */\nexport class Script {\n  /**\n   * The move module bytecode\n   * @group Implementation\n   * @category Transactions\n   */\n  public readonly bytecode: Uint8Array;\n\n  /**\n   * The type arguments that the bytecode function requires.\n   * @group Implementation\n   * @category Transactions\n   */\n  public readonly type_args: Array<TypeTag>;\n\n  /**\n   * The arguments that the bytecode function requires.\n   * @group Implementation\n   * @category Transactions\n   */\n  public readonly args: Array<ScriptFunctionArgument>;\n\n  /**\n   * Scripts contain the Move bytecodes payload that can be submitted to Aptos chain for execution.\n   *\n   * @param bytecode The move module bytecode\n   * @param type_args The type arguments that the bytecode function requires.\n   *\n   * @example\n   * A coin transfer function has one type argument \"CoinType\".\n   * ```\n   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64)\n   * ```\n   * @param args The arguments that the bytecode function requires.\n   *\n   * @example\n   * A coin transfer function has three arguments \"from\", \"to\" and \"amount\".\n   * ```\n   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64)\n   * ```\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(bytecode: Uint8Array, type_args: Array<TypeTag>, args: Array<ScriptFunctionArgument>) {\n    this.bytecode = bytecode;\n    this.type_args = type_args;\n    this.args = args;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.bytecode);\n    serializer.serializeVector<TypeTag>(this.type_args);\n    serializer.serializeU32AsUleb128(this.args.length);\n    this.args.forEach((item: ScriptFunctionArgument) => {\n      item.serializeForScriptFunction(serializer);\n    });\n  }\n\n  static deserialize(deserializer: Deserializer): Script {\n    const bytecode = deserializer.deserializeBytes();\n    const type_args = deserializer.deserializeVector(TypeTag);\n    const length = deserializer.deserializeUleb128AsU32();\n    const args = new Array<ScriptFunctionArgument>();\n    for (let i = 0; i < length; i += 1) {\n      // Note that we deserialize directly to the Move value, not its Script argument representation.\n      // We are abstracting away the Script argument representation because knowing about it is\n      // functionally useless.\n      const scriptArgument = deserializeFromScriptArgument(deserializer);\n      args.push(scriptArgument);\n    }\n    return new Script(bytecode, type_args, args);\n  }\n}\n\n/**\n * Represents a MultiSig account that can be serialized and deserialized.\n *\n * This class encapsulates the functionality to manage multi-signature transactions, including the address of the\n * multi-sig account and the associated transaction payload.\n * @group Implementation\n * @category Transactions\n */\nexport class MultiSig {\n  public readonly multisig_address: AccountAddress;\n\n  public readonly transaction_payload?: MultiSigTransactionPayload;\n\n  /**\n   * Contains the payload to run a multi-sig account transaction.\n   *\n   * @param multisig_address The multi-sig account address the transaction will be executed as.\n   *\n   * @param transaction_payload The payload of the multi-sig transaction. This is optional when executing a multi-sig\n   *  transaction whose payload is already stored on chain.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(multisig_address: AccountAddress, transaction_payload?: MultiSigTransactionPayload) {\n    this.multisig_address = multisig_address;\n    this.transaction_payload = transaction_payload;\n  }\n\n  serialize(serializer: Serializer): void {\n    this.multisig_address.serialize(serializer);\n    // Options are encoded with an extra u8 field before the value - 0x0 is none and 0x1 is present.\n    // We use serializeBool below to create this prefix value.\n    if (this.transaction_payload === undefined) {\n      serializer.serializeBool(false);\n    } else {\n      serializer.serializeBool(true);\n      this.transaction_payload.serialize(serializer);\n    }\n  }\n\n  static deserialize(deserializer: Deserializer): MultiSig {\n    const multisig_address = AccountAddress.deserialize(deserializer);\n    const payloadPresent = deserializer.deserializeBool();\n    let transaction_payload;\n    if (payloadPresent) {\n      transaction_payload = MultiSigTransactionPayload.deserialize(deserializer);\n    }\n    return new MultiSig(multisig_address, transaction_payload);\n  }\n}\n\n/**\n * Represents a multi-signature transaction payload that can be serialized and deserialized.\n * This class is designed to encapsulate the transaction payload for multi-sig account transactions\n * as defined in the `multisig_account.move` module. Future enhancements may allow support for script\n * payloads as the `multisig_account.move` module evolves.\n * @group Implementation\n * @category Transactions\n */\nexport class MultiSigTransactionPayload extends Serializable {\n  public readonly transaction_payload: EntryFunction;\n\n  /**\n   * Contains the payload to run a multi-sig account transaction.\n   *\n   * @param transaction_payload The payload of the multi-sig transaction.\n   * This can only be EntryFunction for now but,\n   * Script might be supported in the future.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(transaction_payload: EntryFunction) {\n    super();\n    this.transaction_payload = transaction_payload;\n  }\n\n  serialize(serializer: Serializer): void {\n    /**\n     * We can support multiple types of inner transaction payload in the future.\n     * For now, it's only EntryFunction but if we support more types,\n     * we need to serialize with the right enum values here\n     * @group Implementation\n     * @category Transactions\n     */\n    serializer.serializeU32AsUleb128(0);\n    this.transaction_payload.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): MultiSigTransactionPayload {\n    // TODO: Support other types of payload beside EntryFunction.\n    // This is the enum value indicating which type of payload the multisig tx contains.\n    deserializer.deserializeUleb128AsU32();\n    return new MultiSigTransactionPayload(EntryFunction.deserialize(deserializer));\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { ChainId } from \"./chainId\";\nimport { AccountAddress } from \"../../core\";\nimport { TransactionPayload } from \"./transactionPayload\";\nimport { TransactionVariants } from \"../../types\";\n\n/**\n * Represents a raw transaction that can be serialized and deserialized.\n * Raw transactions contain the metadata and payloads that can be submitted to the Aptos chain for execution.\n * They must be signed before the Aptos chain can execute them.\n * @group Implementation\n * @category Transactions\n */\nexport class RawTransaction extends Serializable {\n  public readonly sender: AccountAddress;\n\n  public readonly sequence_number: bigint;\n\n  public readonly payload: TransactionPayload;\n\n  public readonly max_gas_amount: bigint;\n\n  public readonly gas_unit_price: bigint;\n\n  public readonly expiration_timestamp_secs: bigint;\n\n  public readonly chain_id: ChainId;\n\n  /**\n   * RawTransactions contain the metadata and payloads that can be submitted to Aptos chain for execution.\n   * RawTransactions must be signed before Aptos chain can execute them.\n   *\n   * @param sender The sender Account Address\n   * @param sequence_number Sequence number of this transaction. This must match the sequence number stored in\n   *   the sender's account at the time the transaction executes.\n   * @param payload Instructions for the Aptos Blockchain, including publishing a module,\n   *   execute an entry function or execute a script payload.\n   * @param max_gas_amount Maximum total gas to spend for this transaction. The account must have more\n   *   than this gas or the transaction will be discarded during validation.\n   * @param gas_unit_price Price to be paid per gas unit.\n   * @param expiration_timestamp_secs The blockchain timestamp at which the blockchain would discard this transaction.\n   * @param chain_id The chain ID of the blockchain that this transaction is intended to be run on.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(\n    sender: AccountAddress,\n    sequence_number: bigint,\n    payload: TransactionPayload,\n    max_gas_amount: bigint,\n    gas_unit_price: bigint,\n    expiration_timestamp_secs: bigint,\n    chain_id: ChainId,\n  ) {\n    super();\n    this.sender = sender;\n    this.sequence_number = sequence_number;\n    this.payload = payload;\n    this.max_gas_amount = max_gas_amount;\n    this.gas_unit_price = gas_unit_price;\n    this.expiration_timestamp_secs = expiration_timestamp_secs;\n    this.chain_id = chain_id;\n  }\n\n  /**\n   * Serializes the transaction data, including the fee payer transaction type, raw transaction, secondary signer addresses,\n   * and fee payer address.\n   * This function is essential for preparing the transaction for transmission or storage in a serialized format.\n   *\n   * @param serializer - The serializer instance used to serialize the transaction data.\n   * @group Implementation\n   * @category Transactions\n   */\n  serialize(serializer: Serializer): void {\n    this.sender.serialize(serializer);\n    serializer.serializeU64(this.sequence_number);\n    this.payload.serialize(serializer);\n    serializer.serializeU64(this.max_gas_amount);\n    serializer.serializeU64(this.gas_unit_price);\n    serializer.serializeU64(this.expiration_timestamp_secs);\n    this.chain_id.serialize(serializer);\n  }\n\n  /**\n   * Deserialize a Raw Transaction With Data.\n   * This function retrieves the appropriate raw transaction based on the variant index provided by the deserializer.\n   *\n   * @param deserializer - An instance of the Deserializer used to read the serialized data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static deserialize(deserializer: Deserializer): RawTransaction {\n    const sender = AccountAddress.deserialize(deserializer);\n    const sequence_number = deserializer.deserializeU64();\n    const payload = TransactionPayload.deserialize(deserializer);\n    const max_gas_amount = deserializer.deserializeU64();\n    const gas_unit_price = deserializer.deserializeU64();\n    const expiration_timestamp_secs = deserializer.deserializeU64();\n    const chain_id = ChainId.deserialize(deserializer);\n    return new RawTransaction(\n      sender,\n      sequence_number,\n      payload,\n      max_gas_amount,\n      gas_unit_price,\n      expiration_timestamp_secs,\n      chain_id,\n    );\n  }\n}\n\n/**\n * Represents a raw transaction with associated data that can be serialized and deserialized.\n *\n * @extends Serializable\n * @group Implementation\n * @category Transactions\n */\nexport abstract class RawTransactionWithData extends Serializable {\n  /**\n   * Serialize a Raw Transaction With Data\n   * @group Implementation\n   * @category Transactions\n   */\n  abstract serialize(serializer: Serializer): void;\n\n  /**\n   * Deserialize a Raw Transaction With Data\n   * @group Implementation\n   * @category Transactions\n   */\n  static deserialize(deserializer: Deserializer): RawTransactionWithData {\n    // index enum variant\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case TransactionVariants.MultiAgentTransaction:\n        return MultiAgentRawTransaction.load(deserializer);\n      case TransactionVariants.FeePayerTransaction:\n        return FeePayerRawTransaction.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for RawTransactionWithData: ${index}`);\n    }\n  }\n}\n\n/**\n * Represents a multi-agent transaction that can be serialized and deserialized.\n *\n * @extends RawTransactionWithData\n * @group Implementation\n * @category Transactions\n */\nexport class MultiAgentRawTransaction extends RawTransactionWithData {\n  /**\n   * The raw transaction\n   * @group Implementation\n   * @category Transactions\n   */\n  public readonly raw_txn: RawTransaction;\n\n  /**\n   * The secondary signers on this transaction\n   * @group Implementation\n   * @category Transactions\n   */\n  public readonly secondary_signer_addresses: Array<AccountAddress>;\n\n  constructor(raw_txn: RawTransaction, secondary_signer_addresses: Array<AccountAddress>) {\n    super();\n    this.raw_txn = raw_txn;\n    this.secondary_signer_addresses = secondary_signer_addresses;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionVariants.MultiAgentTransaction);\n    this.raw_txn.serialize(serializer);\n    serializer.serializeVector(this.secondary_signer_addresses);\n  }\n\n  /**\n   * Deserializes a Fee Payer Raw Transaction from the provided deserializer.\n   * This function allows you to reconstruct a Fee Payer Raw Transaction object, which includes the raw transaction data,\n   * secondary signer addresses, and the fee payer address.\n   *\n   * @param deserializer - The deserializer used to read the raw transaction data.\n   * @returns A FeePayerRawTransaction object constructed from the deserialized data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static load(deserializer: Deserializer): MultiAgentRawTransaction {\n    const rawTxn = RawTransaction.deserialize(deserializer);\n    const secondarySignerAddresses = deserializer.deserializeVector(AccountAddress);\n\n    return new MultiAgentRawTransaction(rawTxn, secondarySignerAddresses);\n  }\n}\n\n/**\n * Represents a Fee Payer Transaction that can be serialized and deserialized.\n * @group Implementation\n * @category Transactions\n */\nexport class FeePayerRawTransaction extends RawTransactionWithData {\n  /**\n   * The raw transaction\n   * @group Implementation\n   * @category Transactions\n   */\n  public readonly raw_txn: RawTransaction;\n\n  /**\n   * The secondary signers on this transaction - optional and can be empty\n   * @group Implementation\n   * @category Transactions\n   */\n  public readonly secondary_signer_addresses: Array<AccountAddress>;\n\n  /**\n   * The fee payer account address\n   * @group Implementation\n   * @category Transactions\n   */\n  public readonly fee_payer_address: AccountAddress;\n\n  constructor(\n    raw_txn: RawTransaction,\n    secondary_signer_addresses: Array<AccountAddress>,\n    fee_payer_address: AccountAddress,\n  ) {\n    super();\n    this.raw_txn = raw_txn;\n    this.secondary_signer_addresses = secondary_signer_addresses;\n    this.fee_payer_address = fee_payer_address;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionVariants.FeePayerTransaction);\n    this.raw_txn.serialize(serializer);\n    serializer.serializeVector(this.secondary_signer_addresses);\n    this.fee_payer_address.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): FeePayerRawTransaction {\n    const rawTxn = RawTransaction.deserialize(deserializer);\n    const secondarySignerAddresses = deserializer.deserializeVector(AccountAddress);\n    const feePayerAddress = AccountAddress.deserialize(deserializer);\n\n    return new FeePayerRawTransaction(rawTxn, secondarySignerAddresses, feePayerAddress);\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { AccountAuthenticator } from \"./account\";\nimport { Deserializer, Serializable, Serializer } from \"../../bcs\";\nimport { AccountAddress } from \"../../core\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"../../core/crypto/ed25519\";\nimport { MultiEd25519PublicKey, MultiEd25519Signature } from \"../../core/crypto/multiEd25519\";\nimport { TransactionAuthenticatorVariant } from \"../../types\";\n\n/**\n * Represents an abstract base class for transaction authenticators.\n * This class provides methods for serializing and deserializing different types of transaction authenticators.\n *\n * @extends Serializable\n * @group Implementation\n * @category Transactions\n */\nexport abstract class TransactionAuthenticator extends Serializable {\n  abstract serialize(serializer: Serializer): void;\n\n  /**\n   * Deserializes a TransactionAuthenticator from the provided deserializer.\n   * This function helps in reconstructing the TransactionAuthenticator based on the variant index found in the serialized data.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static deserialize(deserializer: Deserializer): TransactionAuthenticator {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case TransactionAuthenticatorVariant.Ed25519:\n        return TransactionAuthenticatorEd25519.load(deserializer);\n      case TransactionAuthenticatorVariant.MultiEd25519:\n        return TransactionAuthenticatorMultiEd25519.load(deserializer);\n      case TransactionAuthenticatorVariant.MultiAgent:\n        return TransactionAuthenticatorMultiAgent.load(deserializer);\n      case TransactionAuthenticatorVariant.FeePayer:\n        return TransactionAuthenticatorFeePayer.load(deserializer);\n      case TransactionAuthenticatorVariant.SingleSender:\n        return TransactionAuthenticatorSingleSender.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for TransactionAuthenticator: ${index}`);\n    }\n  }\n\n  isEd25519(): this is TransactionAuthenticatorEd25519 {\n    return this instanceof TransactionAuthenticatorEd25519;\n  }\n\n  isMultiEd25519(): this is TransactionAuthenticatorMultiEd25519 {\n    return this instanceof TransactionAuthenticatorMultiEd25519;\n  }\n\n  isMultiAgent(): this is TransactionAuthenticatorMultiAgent {\n    return this instanceof TransactionAuthenticatorMultiAgent;\n  }\n\n  isFeePayer(): this is TransactionAuthenticatorFeePayer {\n    return this instanceof TransactionAuthenticatorFeePayer;\n  }\n\n  isSingleSender(): this is TransactionAuthenticatorSingleSender {\n    return this instanceof TransactionAuthenticatorSingleSender;\n  }\n}\n\n/**\n * Represents a transaction authenticator using Ed25519 for a single signer transaction.\n * This class encapsulates the client's public key and the Ed25519 signature of a raw transaction.\n *\n * @param public_key - The client's public key.\n * @param signature - The Ed25519 signature of a raw transaction.\n * @see {@link https://aptos.dev/integration/creating-a-signed-transaction | Creating a Signed Transaction}\n * for details about generating a signature.\n * @group Implementation\n * @category Transactions\n */\nexport class TransactionAuthenticatorEd25519 extends TransactionAuthenticator {\n  public readonly public_key: Ed25519PublicKey;\n\n  public readonly signature: Ed25519Signature;\n\n  /**\n   * Creates an instance of the class with the specified account authenticator.\n   *\n   * @param public_key - The Ed25519PublicKey that will be used for authentication.\n   * @param signature - The Ed25519Signature that will be used for authentication.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(public_key: Ed25519PublicKey, signature: Ed25519Signature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n\n  /**\n   * Serializes the transaction authenticator by encoding the sender information.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category Transactions\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionAuthenticatorVariant.Ed25519);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n\n  /**\n   * Loads a TransactionAuthenticatorSingleSender instance from the provided deserializer.\n   * This function helps in deserializing the sender information to create a transaction authenticator.\n   *\n   * @param deserializer - The deserializer used to extract the sender data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static load(deserializer: Deserializer): TransactionAuthenticatorEd25519 {\n    const public_key = Ed25519PublicKey.deserialize(deserializer);\n    const signature = Ed25519Signature.deserialize(deserializer);\n    return new TransactionAuthenticatorEd25519(public_key, signature);\n  }\n}\n\n/**\n * Represents a transaction authenticator for multi-signature transactions using Ed25519.\n * This class is used to validate transactions that require multiple signatures from different signers.\n *\n * @param public_key - The public key of the client involved in the transaction.\n * @param signature - The multi-signature of the raw transaction.\n * @group Implementation\n * @category Transactions\n */\nexport class TransactionAuthenticatorMultiEd25519 extends TransactionAuthenticator {\n  public readonly public_key: MultiEd25519PublicKey;\n\n  public readonly signature: MultiEd25519Signature;\n\n  constructor(public_key: MultiEd25519PublicKey, signature: MultiEd25519Signature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionAuthenticatorVariant.MultiEd25519);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionAuthenticatorMultiEd25519 {\n    const public_key = MultiEd25519PublicKey.deserialize(deserializer);\n    const signature = MultiEd25519Signature.deserialize(deserializer);\n    return new TransactionAuthenticatorMultiEd25519(public_key, signature);\n  }\n}\n\n/**\n * Represents a transaction authenticator for a multi-agent transaction.\n *\n * This class manages the authentication process involving a primary sender and multiple secondary signers.\n *\n * @param sender - The authenticator for the sender account.\n * @param secondary_signer_addresses - An array of addresses for the secondary signers.\n * @param secondary_signers - An array of authenticators for the secondary signer accounts.\n * @group Implementation\n * @category Transactions\n */\nexport class TransactionAuthenticatorMultiAgent extends TransactionAuthenticator {\n  public readonly sender: AccountAuthenticator;\n\n  public readonly secondary_signer_addresses: Array<AccountAddress>;\n\n  public readonly secondary_signers: Array<AccountAuthenticator>;\n\n  constructor(\n    sender: AccountAuthenticator,\n    secondary_signer_addresses: Array<AccountAddress>,\n    secondary_signers: Array<AccountAuthenticator>,\n  ) {\n    super();\n    this.sender = sender;\n    this.secondary_signer_addresses = secondary_signer_addresses;\n    this.secondary_signers = secondary_signers;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionAuthenticatorVariant.MultiAgent);\n    this.sender.serialize(serializer);\n    serializer.serializeVector<AccountAddress>(this.secondary_signer_addresses);\n    serializer.serializeVector<AccountAuthenticator>(this.secondary_signers);\n  }\n\n  static load(deserializer: Deserializer): TransactionAuthenticatorMultiAgent {\n    const sender = AccountAuthenticator.deserialize(deserializer);\n    const secondary_signer_addresses = deserializer.deserializeVector(AccountAddress);\n    const secondary_signers = deserializer.deserializeVector(AccountAuthenticator);\n    return new TransactionAuthenticatorMultiAgent(sender, secondary_signer_addresses, secondary_signers);\n  }\n}\n\n/**\n * Represents a transaction authenticator specifically for fee payer transactions.\n * It encapsulates the sender's account authenticator, addresses of secondary signers,\n * their respective authenticators, and the fee payer's account information.\n *\n * @param sender - The authenticator for the sender's account.\n * @param secondary_signer_addresses - An array of addresses for secondary signers.\n * @param secondary_signers - An array of authenticators for secondary signers' accounts.\n * @param fee_payer - An object containing the fee payer's account address and authenticator.\n * @group Implementation\n * @category Transactions\n */\nexport class TransactionAuthenticatorFeePayer extends TransactionAuthenticator {\n  public readonly sender: AccountAuthenticator;\n\n  public readonly secondary_signer_addresses: Array<AccountAddress>;\n\n  public readonly secondary_signers: Array<AccountAuthenticator>;\n\n  public readonly fee_payer: {\n    address: AccountAddress;\n    authenticator: AccountAuthenticator;\n  };\n\n  constructor(\n    sender: AccountAuthenticator,\n    secondary_signer_addresses: Array<AccountAddress>,\n    secondary_signers: Array<AccountAuthenticator>,\n    fee_payer: { address: AccountAddress; authenticator: AccountAuthenticator },\n  ) {\n    super();\n    this.sender = sender;\n    this.secondary_signer_addresses = secondary_signer_addresses;\n    this.secondary_signers = secondary_signers;\n    this.fee_payer = fee_payer;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionAuthenticatorVariant.FeePayer);\n    this.sender.serialize(serializer);\n    serializer.serializeVector<AccountAddress>(this.secondary_signer_addresses);\n    serializer.serializeVector<AccountAuthenticator>(this.secondary_signers);\n    this.fee_payer.address.serialize(serializer);\n    this.fee_payer.authenticator.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionAuthenticatorMultiAgent {\n    const sender = AccountAuthenticator.deserialize(deserializer);\n    const secondary_signer_addresses = deserializer.deserializeVector(AccountAddress);\n    const secondary_signers = deserializer.deserializeVector(AccountAuthenticator);\n    const address = AccountAddress.deserialize(deserializer);\n    const authenticator = AccountAuthenticator.deserialize(deserializer);\n    const fee_payer = { address, authenticator };\n    return new TransactionAuthenticatorFeePayer(sender, secondary_signer_addresses, secondary_signers, fee_payer);\n  }\n}\n\n/**\n * Represents a single sender authenticator for transactions that require a single signer.\n * This class is responsible for managing the authentication of a transaction initiated by a single sender.\n *\n * @param sender - An instance of AccountAuthenticator that represents the account of the sender.\n * @group Implementation\n * @category Transactions\n */\nexport class TransactionAuthenticatorSingleSender extends TransactionAuthenticator {\n  public readonly sender: AccountAuthenticator;\n\n  constructor(sender: AccountAuthenticator) {\n    super();\n    this.sender = sender;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionAuthenticatorVariant.SingleSender);\n    this.sender.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionAuthenticatorSingleSender {\n    const sender = AccountAuthenticator.deserialize(deserializer);\n    return new TransactionAuthenticatorSingleSender(sender);\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { TransactionAuthenticator } from \"../authenticator/transaction\";\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { RawTransaction } from \"./rawTransaction\";\n\n/**\n * Represents a signed transaction that includes a raw transaction and an authenticator.\n * The authenticator contains a client's public key and the signature of the raw transaction.\n *\n * @see {@link https://aptos.dev/integration/creating-a-signed-transaction | Creating a Signed Transaction}\n * @param raw_txn - The raw transaction to be signed.\n * @param authenticator - Contains a client's public key and the signature of the raw transaction.\n * Authenticator can have three variations: single signature, multi-signature, and multi-agent.\n * @see {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/authenticator.rs} for details.\n * @group Implementation\n * @category Transactions\n */\nexport class SignedTransaction extends Serializable {\n  public readonly raw_txn: RawTransaction;\n\n  public readonly authenticator: TransactionAuthenticator;\n\n  /**\n   * Represents a signed transaction that includes a raw transaction and an authenticator.\n   * The authenticator contains a client's public key and the signature of the raw transaction,\n   * which can be of three types: single signature, multi-signature, and multi-agent.\n   *\n   * @param raw_txn The raw transaction to be signed.\n   * @param authenticator Contains a client's public key and the signature of the raw transaction. The authenticator has 3\n   * flavors: single signature, multi-signature and multi-agent.\n   * @see {@link https://aptos.dev/integration/creating-a-signed-transaction | Creating a Signed Transaction}\n   * @see {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/authenticator.rs} for details.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(raw_txn: RawTransaction, authenticator: TransactionAuthenticator) {\n    super();\n    this.raw_txn = raw_txn;\n    this.authenticator = authenticator;\n  }\n\n  /**\n   * Serializes the raw transaction and its authenticator using the provided serializer.\n   * This function is essential for preparing the transaction data for transmission or storage.\n   *\n   * @param serializer - The serializer instance used to serialize the transaction and authenticator.\n   * @group Implementation\n   * @category Transactions\n   */\n  serialize(serializer: Serializer): void {\n    this.raw_txn.serialize(serializer);\n    this.authenticator.serialize(serializer);\n  }\n\n  /**\n   * Deserializes a signed transaction from the provided deserializer.\n   * This function allows you to reconstruct a SignedTransaction object from its serialized form, enabling further processing or validation.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static deserialize(deserializer: Deserializer): SignedTransaction {\n    const raw_txn = RawTransaction.deserialize(deserializer);\n    const authenticator = TransactionAuthenticator.deserialize(deserializer);\n    return new SignedTransaction(raw_txn, authenticator);\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { AccountAddress } from \"../../core\";\nimport { RawTransaction } from \"./rawTransaction\";\n\n/**\n * Represents a simple transaction type that can be submitted to the Aptos chain for execution.\n *\n * This transaction type is designed for a single signer and includes metadata such as the Raw Transaction\n * and an optional sponsor Account Address to cover gas fees.\n *\n * @param rawTransaction - The Raw Transaction.\n * @param feePayerAddress - The optional sponsor Account Address.\n * @group Implementation\n * @category Transactions\n */\nexport class SimpleTransaction extends Serializable {\n  public rawTransaction: RawTransaction;\n\n  public feePayerAddress?: AccountAddress | undefined;\n\n  // We don't really need it, we add it for type checking we do\n  // throughout the SDK\n  public readonly secondarySignerAddresses: undefined;\n\n  /**\n   * SimpleTransaction represents a transaction signed by a single account that\n   * can be submitted to the Aptos chain for execution.\n   *\n   * @param rawTransaction The Raw Transaction.\n   * @param feePayerAddress The optional sponsor Account Address to pay the gas fees.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(rawTransaction: RawTransaction, feePayerAddress?: AccountAddress) {\n    super();\n    this.rawTransaction = rawTransaction;\n    this.feePayerAddress = feePayerAddress;\n  }\n\n  /**\n   * Serializes the transaction data using the provided serializer.\n   * This function ensures that the raw transaction and fee payer address are properly serialized for further processing.\n   *\n   * @param serializer - The serializer instance used to serialize the transaction data.\n   * @group Implementation\n   * @category Transactions\n   */\n  serialize(serializer: Serializer): void {\n    this.rawTransaction.serialize(serializer);\n\n    if (this.feePayerAddress === undefined) {\n      serializer.serializeBool(false);\n    } else {\n      serializer.serializeBool(true);\n      this.feePayerAddress.serialize(serializer);\n    }\n  }\n\n  /**\n   * Deserializes a SimpleTransaction from the given deserializer.\n   * This function helps in reconstructing a SimpleTransaction object from its serialized form.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static deserialize(deserializer: Deserializer): SimpleTransaction {\n    const rawTransaction = RawTransaction.deserialize(deserializer);\n    const feePayerPresent = deserializer.deserializeBool();\n    let feePayerAddress;\n    if (feePayerPresent) {\n      feePayerAddress = AccountAddress.deserialize(deserializer);\n    }\n\n    return new SimpleTransaction(rawTransaction, feePayerAddress);\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { AccountAddress } from \"../../core\";\nimport { RawTransaction } from \"./rawTransaction\";\n\n/**\n * Represents a multi-agent transaction that can be serialized and deserialized.\n * This transaction includes a raw transaction, optional fee payer address, and multiple secondary signer addresses.\n *\n * @param rawTransaction The raw transaction to be executed.\n * @param secondarySignerAddresses An array of secondary signer addresses involved in the transaction.\n * @param feePayerAddress An optional account address that sponsors the transaction's gas fees.\n * @group Implementation\n * @category Transactions\n */\nexport class MultiAgentTransaction extends Serializable {\n  public rawTransaction: RawTransaction;\n\n  public feePayerAddress?: AccountAddress | undefined;\n\n  public secondarySignerAddresses: AccountAddress[];\n\n  /**\n   * Represents a MultiAgentTransaction that can be submitted to the Aptos chain for execution.\n   * This class encapsulates the raw transaction data, the secondary signer addresses, and an optional fee payer address.\n   *\n   * @param rawTransaction The raw transaction data.\n   * @param secondarySignerAddresses An array of secondary signer addresses.\n   * @param feePayerAddress An optional account address that sponsors the gas fees.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(\n    rawTransaction: RawTransaction,\n    secondarySignerAddresses: AccountAddress[],\n    feePayerAddress?: AccountAddress,\n  ) {\n    super();\n    this.rawTransaction = rawTransaction;\n    this.feePayerAddress = feePayerAddress;\n    this.secondarySignerAddresses = secondarySignerAddresses;\n  }\n\n  /**\n   * Serializes the transaction data, including the raw transaction, secondary signer addresses, and fee payer address.\n   * This function is essential for preparing the transaction for transmission or storage in a serialized format.\n   *\n   * @param serializer - The serializer instance used to serialize the transaction data.\n   * @group Implementation\n   * @category Transactions\n   */\n  serialize(serializer: Serializer): void {\n    this.rawTransaction.serialize(serializer);\n\n    serializer.serializeVector<AccountAddress>(this.secondarySignerAddresses);\n\n    if (this.feePayerAddress === undefined) {\n      serializer.serializeBool(false);\n    } else {\n      serializer.serializeBool(true);\n      this.feePayerAddress.serialize(serializer);\n    }\n  }\n\n  /**\n   * Deserializes a MultiAgentTransaction from the provided deserializer.\n   * This function allows you to reconstruct a MultiAgentTransaction object from its serialized form, including any secondary\n   * signer addresses and the fee payer address if present.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static deserialize(deserializer: Deserializer): MultiAgentTransaction {\n    const rawTransaction = RawTransaction.deserialize(deserializer);\n\n    const secondarySignerAddresses = deserializer.deserializeVector(AccountAddress);\n\n    const feePayerPresent = deserializer.deserializeBool();\n    let feePayerAddress;\n    if (feePayerPresent) {\n      feePayerAddress = AccountAddress.deserialize(deserializer);\n    }\n\n    return new MultiAgentTransaction(rawTransaction, secondarySignerAddresses, feePayerAddress);\n  }\n}\n","import { AccountAuthenticatorEd25519 } from \"../transactions/authenticator/account\";\nimport { HexInput, SigningScheme } from \"../types\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { Ed25519PrivateKey, Ed25519PublicKey, Ed25519Signature, Signature } from \"../core/crypto\";\nimport type { Account } from \"./Account\";\nimport { AnyRawTransaction } from \"../transactions/types\";\nimport { generateSigningMessageForTransaction } from \"../transactions/transactionBuilder/signingMessage\";\nimport { AptosConfig } from \"../api\";\n\n/**\n * Arguments required to create an instance of an Ed25519 signer.\n *\n * @param privateKey - The private key used for signing.\n * @param address - Optional account address associated with the signer.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface Ed25519SignerConstructorArgs {\n  privateKey: Ed25519PrivateKey;\n  address?: AccountAddressInput;\n}\n\n/**\n * Arguments for creating an Ed25519 signer from a derivation path.\n *\n * @param path - The derivation path for the Ed25519 key.\n * @param mnemonic - The mnemonic phrase used to generate the key.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface Ed25519SignerFromDerivationPathArgs {\n  path: string;\n  mnemonic: string;\n}\n\n/**\n * Arguments required to verify an Ed25519 signature against a given message.\n *\n * @param message - The message to be verified, represented in hexadecimal format.\n * @param signature - The Ed25519 signature to validate.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface VerifyEd25519SignatureArgs {\n  message: HexInput;\n  signature: Ed25519Signature;\n}\n\n/**\n * Represents an Ed25519 account that provides signing capabilities through an Ed25519 private key.\n * This class allows for the creation of accounts, signing messages and transactions, and verifying signatures.\n *\n * Note: Generating an instance of this class does not create the account on-chain.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport class Ed25519Account implements Account {\n  /**\n   * Private key associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly privateKey: Ed25519PrivateKey;\n\n  readonly publicKey: Ed25519PublicKey;\n\n  readonly accountAddress: AccountAddress;\n\n  readonly signingScheme = SigningScheme.Ed25519;\n\n  // region Constructors\n\n  /**\n   * Creates an instance of the Ed25519Signer with the specified parameters.\n   * This constructor initializes the private key, public key, and account address for the signer.\n   *\n   * @param args - The constructor arguments for the Ed25519Signer.\n   * @param args.privateKey - The private key used for signing.\n   * @param args.address - The optional account address; if not provided, it will derive the address from the public key.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  constructor(args: Ed25519SignerConstructorArgs) {\n    const { privateKey, address } = args;\n    this.privateKey = privateKey;\n    this.publicKey = privateKey.publicKey();\n    this.accountAddress = address ? AccountAddress.from(address) : this.publicKey.authKey().derivedAddress();\n  }\n\n  /**\n   * Generates a new Ed25519 account using a randomly generated private key.\n   * This function is useful for creating a signer that can be used for cryptographic operations.\n   *\n   * @returns {Ed25519Account} The newly generated Ed25519 account.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static generate(): Ed25519Account {\n    const privateKey = Ed25519PrivateKey.generate();\n    return new Ed25519Account({ privateKey });\n  }\n\n  /**\n   * Derives an Ed25519 account using a specified BIP44 path and mnemonic seed phrase.\n   *\n   * @param args - The arguments for deriving the account.\n   * @param args.path - The BIP44 derive hardened path, e.g., m/44'/637'/0'/0'/0'.\n   * Detailed description: {@link https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki}\n   * @param args.mnemonic - The mnemonic seed phrase of the account.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static fromDerivationPath(args: Ed25519SignerFromDerivationPathArgs) {\n    const { path, mnemonic } = args;\n    const privateKey = Ed25519PrivateKey.fromDerivationPath(path, mnemonic);\n    return new Ed25519Account({ privateKey });\n  }\n  // endregion\n\n  // region Account\n  /**\n   * Verify the given message and signature with the public key.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.message - Raw message data in HexInput format.\n   * @param args.signature - Signed message signature.\n   * @returns A boolean indicating whether the signature is valid.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  verifySignature(args: VerifyEd25519SignatureArgs): boolean {\n    return this.publicKey.verifySignature(args);\n  }\n\n  /**\n   * Verify the given message and signature with the public key.\n   *\n   * Ed25519 signatures do not depend on chain state, so this function is equivalent to the synchronous verifySignature method.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.aptosConfig - The configuration object for connecting to the Aptos network\n   * @param args.message - Raw message data in HexInput format.\n   * @param args.signature - Signed message signature.\n   * @returns A boolean indicating whether the signature is valid.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: Signature;\n  }): Promise<boolean> {\n    return this.publicKey.verifySignatureAsync({\n      ...args,\n      signature: args.signature,\n    });\n  }\n\n  /**\n   * Sign a message using the account's Ed25519 private key.\n   * This function returns an AccountAuthenticator containing the signature along with the account's public key.\n   *\n   * @param message - The signing message, represented as hexadecimal input.\n   * @returns An AccountAuthenticator containing the signature and the account's public key.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signWithAuthenticator(message: HexInput): AccountAuthenticatorEd25519 {\n    return new AccountAuthenticatorEd25519(this.publicKey, this.privateKey.sign(message));\n  }\n\n  /**\n   * Sign a transaction using the account's Ed25519 private key.\n   * This function returns an AccountAuthenticator that contains the signature of the transaction along with the account's public key.\n   *\n   * @param transaction - The raw transaction to be signed.\n   * @returns An AccountAuthenticator containing the signature and the public key.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorEd25519 {\n    return new AccountAuthenticatorEd25519(this.publicKey, this.signTransaction(transaction));\n  }\n\n  /**\n   * Sign the given message using the account's Ed25519 private key.\n   * @param message - The message to be signed in HexInput format.\n   * @returns Signature - The resulting signature of the signed message.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  sign(message: HexInput): Ed25519Signature {\n    return this.privateKey.sign(message);\n  }\n\n  /**\n   * Sign the given transaction using the available signing capabilities.\n   * This function helps ensure that the transaction is properly authenticated before submission.\n   *\n   * @param transaction - The transaction to be signed.\n   * @returns Signature - The resulting signature for the transaction.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signTransaction(transaction: AnyRawTransaction): Ed25519Signature {\n    return this.sign(generateSigningMessageForTransaction(transaction));\n  }\n\n  // endregion\n}\n","import { AccountAuthenticatorSingleKey } from \"../transactions/authenticator/account\";\nimport { type HexInput, SigningScheme, SigningSchemeInput } from \"../types\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport {\n  AnyPublicKey,\n  AnySignature,\n  Ed25519PrivateKey,\n  KeylessSignature,\n  PrivateKeyInput,\n  Secp256k1PrivateKey,\n  Signature,\n} from \"../core/crypto\";\nimport type { Account } from \"./Account\";\nimport { generateSigningMessageForTransaction } from \"../transactions/transactionBuilder/signingMessage\";\nimport { AnyRawTransaction } from \"../transactions/types\";\nimport { Ed25519Account } from \"./Ed25519Account\";\nimport { AptosConfig } from \"../api\";\n\n/**\n * An interface which defines if an Account utilizes SingleKey signing.\n *\n * Such an account will use the AnyPublicKey enum to represent its public key when deriving the auth key.\n */\nexport interface SingleKeySigner extends Account {\n  getAnyPublicKey(): AnyPublicKey;\n}\n\nexport function isSingleKeySigner(obj: unknown): obj is SingleKeySigner {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    \"getAnyPublicKey\" in obj &&\n    typeof (obj as any).getAnyPublicKey === \"function\"\n  );\n}\n\nexport type SingleKeySignerOrLegacyEd25519Account = SingleKeySigner | Ed25519Account;\n\n/**\n * Arguments required to create a single key signer.\n *\n * @param privateKey - The private key used for signing.\n * @param address - Optional account address associated with the signer.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface SingleKeySignerConstructorArgs {\n  privateKey: PrivateKeyInput;\n  address?: AccountAddressInput;\n}\n\n/**\n * Arguments for generating a single key signer.\n *\n * @param scheme - The signing scheme to be used.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface SingleKeySignerGenerateArgs {\n  scheme?: SigningSchemeInput;\n}\n\n/**\n * The arguments for generating a single key signer from a specified derivation path.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport type SingleKeySignerFromDerivationPathArgs = SingleKeySignerGenerateArgs & {\n  path: string;\n  mnemonic: string;\n};\n\n/**\n * Arguments required to verify a single key signature for a given message.\n *\n * @param message - The message to be verified, represented in hexadecimal format.\n * @param signature - The signature that corresponds to the message.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface VerifySingleKeySignatureArgs {\n  message: HexInput;\n  signature: AnySignature;\n}\n\n/**\n * Signer implementation for the SingleKey authentication scheme.\n * This class extends a SingleKeyAccount by adding signing capabilities through a valid private key.\n * Currently, the only supported signature schemes are Ed25519 and Secp256k1.\n *\n * Note: Generating a signer instance does not create the account on-chain.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport class SingleKeyAccount implements Account, SingleKeySigner {\n  /**\n   * Private key associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly privateKey: PrivateKeyInput;\n\n  readonly publicKey: AnyPublicKey;\n\n  readonly accountAddress: AccountAddress;\n\n  readonly signingScheme = SigningScheme.SingleKey;\n\n  /**\n   * Creates an instance of the SingleKeySigner using the provided private key and address.\n   * This allows for signing transactions and messages with the specified private key.\n   *\n   * @param args - The constructor arguments for initializing the SingleKeySigner.\n   * @param args.privateKey - The private key used for signing.\n   * @param args.address - The optional account address; if not provided, it will derive the address from the public key.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  constructor(args: SingleKeySignerConstructorArgs) {\n    const { privateKey, address } = args;\n    this.privateKey = privateKey;\n    this.publicKey = new AnyPublicKey(privateKey.publicKey());\n    this.accountAddress = address ? AccountAddress.from(address) : this.publicKey.authKey().derivedAddress();\n  }\n\n  getAnyPublicKey(): AnyPublicKey {\n    return this.publicKey;\n  }\n\n  /**\n   * Derives an account from a randomly generated private key based on the specified signing scheme.\n   * The default generation scheme is Ed25519, but it can also support Secp256k1Ecdsa.\n   *\n   * @param args - The arguments for generating the account.\n   * @param args.scheme - The signing scheme to use for generating the private key. Defaults to SigningSchemeInput.Ed25519.\n   * @returns An account with the generated private key based on the specified signing scheme.\n   * @throws Error if an unsupported signature scheme is provided.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static generate(args: SingleKeySignerGenerateArgs = {}) {\n    const { scheme = SigningSchemeInput.Ed25519 } = args;\n    let privateKey: PrivateKeyInput;\n    switch (scheme) {\n      case SigningSchemeInput.Ed25519:\n        privateKey = Ed25519PrivateKey.generate();\n        break;\n      case SigningSchemeInput.Secp256k1Ecdsa:\n        privateKey = Secp256k1PrivateKey.generate();\n        break;\n      default:\n        throw new Error(`Unsupported signature scheme ${scheme}`);\n    }\n    return new SingleKeyAccount({ privateKey });\n  }\n\n  /**\n   * Derives an account using a specified BIP44 path and mnemonic seed phrase, defaulting to the Ed25519 signature scheme.\n   * This function allows you to create a single key account based on the provided derivation path and mnemonic.\n   *\n   * @param args - The arguments for deriving the account.\n   * @param args.scheme - The signature scheme to derive the private key with. Defaults to Ed25519.\n   * @param args.path - The BIP44 derive hardened path (e.g. m/44'/637'/0'/0'/0') for Ed25519, or non-hardened path\n   * (e.g. m/44'/637'/0'/0/0) for secp256k1.\n   * Detailed description: {@link https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki}\n   * @param args.mnemonic - The mnemonic seed phrase of the account.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static fromDerivationPath(args: SingleKeySignerFromDerivationPathArgs) {\n    const { scheme = SigningSchemeInput.Ed25519, path, mnemonic } = args;\n    let privateKey: PrivateKeyInput;\n    switch (scheme) {\n      case SigningSchemeInput.Ed25519:\n        privateKey = Ed25519PrivateKey.fromDerivationPath(path, mnemonic);\n        break;\n      case SigningSchemeInput.Secp256k1Ecdsa:\n        privateKey = Secp256k1PrivateKey.fromDerivationPath(path, mnemonic);\n        break;\n      default:\n        throw new Error(`Unsupported signature scheme ${scheme}`);\n    }\n    return new SingleKeyAccount({ privateKey });\n  }\n\n  /**\n   * Verify the given message and signature with the public key.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.message - The raw message data in HexInput format.\n   * @param args.signature - The signed message signature.\n   * @returns A boolean indicating whether the signature is valid.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  verifySignature(args: VerifySingleKeySignatureArgs): boolean {\n    return this.publicKey.verifySignature(args);\n  }\n\n  /**\n   * Verify the given message and signature with the account's public key.\n   *\n   * This function checks if the provided signature is valid for the given message using the account's public key.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.message - The raw message data in HexInput format.\n   * @param args.signature - The signed message signature.\n   * @param args.options.throwErrorWithReason - Whether to throw an error with the reason for the verification failure.\n   * @returns A boolean indicating whether the signature is valid for the message.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: Signature;\n    options?: { throwErrorWithReason?: boolean };\n  }): Promise<boolean> {\n    return this.publicKey.verifySignatureAsync({\n      ...args,\n      signature: args.signature,\n    });\n  }\n\n  /**\n   * Sign a message using the account's private key and return an AccountAuthenticator containing the signature along with the\n   * account's public key.\n   * @param message - The signing message, represented as binary input in hexadecimal format.\n   * @returns An instance of AccountAuthenticatorSingleKey containing the signature and the public key.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signWithAuthenticator(message: HexInput): AccountAuthenticatorSingleKey {\n    return new AccountAuthenticatorSingleKey(this.publicKey, this.sign(message));\n  }\n\n  /**\n   * Sign a transaction using the account's private key.\n   * This function returns an AccountAuthenticator that contains the signature of the transaction along with the account's public key.\n   * @param transaction - The raw transaction to be signed.\n   * @returns An AccountAuthenticatorSingleKey containing the signature of the transaction and the account's public key.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorSingleKey {\n    return new AccountAuthenticatorSingleKey(this.publicKey, this.signTransaction(transaction));\n  }\n\n  /**\n   * Sign the given message using the account's private key.\n   * @param message - The message to be signed in HexInput format.\n   * @returns A new AnySignature containing the signature of the message.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  sign(message: HexInput): AnySignature {\n    return new AnySignature(this.privateKey.sign(message));\n  }\n\n  /**\n   * Sign the given transaction using the account's private key.\n   * This function generates a signing message for the transaction and then signs it.\n   *\n   * @param transaction - The transaction to be signed.\n   * @returns Signature - The resulting signature for the signed transaction.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signTransaction(transaction: AnyRawTransaction): AnySignature {\n    return this.sign(generateSigningMessageForTransaction(transaction));\n  }\n\n  // endregion\n\n  static fromEd25519Account(account: Ed25519Account): SingleKeyAccount {\n    return new SingleKeyAccount({ privateKey: account.privateKey, address: account.accountAddress });\n  }\n}\n","import type { AccountAuthenticator } from \"../transactions/authenticator/account\";\nimport { HexInput, SigningScheme, SigningSchemeInput } from \"../types\";\nimport type { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { AuthenticationKey } from \"../core/authenticationKey\";\nimport { AccountPublicKey, Ed25519PrivateKey, PrivateKeyInput, Signature, VerifySignatureArgs } from \"../core/crypto\";\nimport { Ed25519Account } from \"./Ed25519Account\";\nimport { SingleKeyAccount } from \"./SingleKeyAccount\";\nimport { AnyRawTransaction } from \"../transactions/types\";\nimport { AptosConfig } from \"../api\";\n\n/**\n * Arguments for creating an `Ed25519Account` from an `Ed25519PrivateKey`.\n * To use the SingleKey authentication scheme, set `legacy` to false.\n *\n * @param privateKey - The private key used to create the account.\n * @param address - Optional address for the account.\n * @param legacy - Indicates whether to use legacy authentication (default is true).\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface CreateEd25519AccountFromPrivateKeyArgs {\n  privateKey: Ed25519PrivateKey;\n  address?: AccountAddressInput;\n  legacy?: true;\n}\n\n/**\n * Arguments for creating a `SingleKeyAccount` using an `Ed25519PrivateKey`.\n * The `legacy` property must be set to false to utilize the `SingleKey` authentication scheme.\n *\n * @param privateKey - The Ed25519 private key used for account creation.\n * @param address - Optional account address input.\n * @param legacy - Must be false to enable the `SingleKey` authentication scheme.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface CreateEd25519SingleKeyAccountFromPrivateKeyArgs {\n  privateKey: Ed25519PrivateKey;\n  address?: AccountAddressInput;\n  legacy: false;\n}\n\n/**\n * Arguments for creating a `SingleKeyAccount` from a supported private key, excluding `Ed25519PrivateKey`.\n * The `legacy` argument is always false and cannot be set to true.\n *\n * @param privateKey - The private key used to create the account.\n * @param address - Optional address input for the account.\n * @param legacy - Always false; cannot be explicitly set to true.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface CreateSingleKeyAccountFromPrivateKeyArgs {\n  privateKey: PrivateKeyInput;\n  address?: AccountAddressInput;\n  legacy?: false;\n}\n\n/**\n * Arguments for creating an `Account` from a private key when the key type is unknown at compile time.\n *\n * @param privateKey - The private key used to create the account.\n * @param address - Optional address for the account.\n * @param legacy - Optional flag indicating if the account is a legacy account.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface CreateAccountFromPrivateKeyArgs {\n  privateKey: PrivateKeyInput;\n  address?: AccountAddressInput;\n  legacy?: boolean;\n}\n\n/**\n * Arguments for generating an Ed25519 account, specifying the signing scheme and legacy option.\n *\n * @param scheme - The signing scheme to use for the account.\n * @param legacy - Indicates if the account should be created in legacy mode.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface GenerateEd25519AccountArgs {\n  scheme?: SigningSchemeInput.Ed25519;\n  legacy?: true;\n}\n\n/**\n * Arguments for generating a `SingleKeyAccount` with an underlying `Ed25519PrivateKey`.\n * The `legacy` argument must be set to false to ensure an `Ed25519SingleKeyAccount` is returned.\n *\n * @param scheme - Optional signing scheme input for the account.\n * @param legacy - Indicates whether to use legacy account generation.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface GenerateEd25519SingleKeyAccountArgs {\n  scheme?: SigningSchemeInput.Ed25519;\n  legacy: false;\n}\n\n/**\n * Arguments for generating a `SingleKeyAccount` using a supported private key other than `Ed25519PrivateKey`.\n * The `legacy` argument is optional and defaults to false, and cannot be set to true.\n *\n * @param scheme - The signing scheme to use for the account.\n * @param legacy - Indicates whether to use legacy account generation (defaults to false).\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface GenerateSingleKeyAccountArgs {\n  scheme: Exclude<SigningSchemeInput, SigningSchemeInput.Ed25519>;\n  legacy?: false;\n}\n\n/**\n * Arguments for generating an opaque `Account` when the input signature scheme is unknown at compile time.\n *\n * @param scheme - The signing scheme to use for account generation.\n * @param legacy - Indicates whether to use legacy account generation methods.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface GenerateAccountArgs {\n  scheme?: SigningSchemeInput;\n  legacy?: boolean;\n}\n\n/**\n * Arguments for deriving a private key using a mnemonic phrase and a specified BIP44 path.\n *\n * @param path - The BIP44 derivation path for the key.\n * @param mnemonic - The mnemonic phrase used for key generation.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface PrivateKeyFromDerivationPathArgs {\n  path: string;\n  mnemonic: string;\n}\n\n/**\n * Abstract class representing a generic Aptos account.\n *\n * This class serves as a single entry point for account generation, allowing accounts to be created\n * either through `Account.generate()` or `Account.fromDerivationPath`. Although it is defined as an\n * abstract class, it should be treated as an interface and enforced using the `implements` keyword.\n *\n * Note: Generating an account instance does not create the account on-chain.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport abstract class Account {\n  /**\n   * Public key associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  abstract readonly publicKey: AccountPublicKey;\n\n  /**\n   * Account address associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  abstract readonly accountAddress: AccountAddress;\n\n  /**\n   * Signing scheme used to sign transactions\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  abstract signingScheme: SigningScheme;\n\n  /**\n   * Generates a new account based on the specified signing scheme and legacy option.\n   * This function allows you to create an account with either the Ed25519 signing scheme or a different scheme as specified.\n   *\n   * @param args - The arguments for generating the account.\n   * @param args.scheme - The signing scheme to use for account generation. Defaults to Ed25519.\n   * @param args.legacy - Indicates whether to use the legacy account generation method. Defaults to true.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static generate(args?: GenerateEd25519AccountArgs): Ed25519Account;\n  static generate(args: GenerateEd25519SingleKeyAccountArgs): SingleKeyAccount;\n  static generate(args: GenerateSingleKeyAccountArgs): SingleKeyAccount;\n  static generate(args: GenerateAccountArgs): Account;\n  static generate(args: GenerateAccountArgs = {}) {\n    const { scheme = SigningSchemeInput.Ed25519, legacy = true } = args;\n    if (scheme === SigningSchemeInput.Ed25519 && legacy) {\n      return Ed25519Account.generate();\n    }\n    return SingleKeyAccount.generate({ scheme });\n  }\n\n  /**\n   * Creates an account from a given private key and address.\n   * This function allows you to instantiate an account based on the provided private key,\n   * and it can differentiate between legacy and non-legacy accounts.\n   *\n   * @param args - The arguments for creating the account.\n   * @param args.privateKey - The private key used to create the account.\n   * @param args.address - The address associated with the account.\n   * @param args.legacy - A boolean indicating whether to create a legacy account (default is true).\n   * @returns An instance of either Ed25519Account or SingleKeyAccount based on the provided private key.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static fromPrivateKey(args: CreateEd25519AccountFromPrivateKeyArgs): Ed25519Account;\n  static fromPrivateKey(args: CreateSingleKeyAccountFromPrivateKeyArgs): SingleKeyAccount;\n  static fromPrivateKey(args: CreateAccountFromPrivateKeyArgs): SingleKeyAccount;\n  static fromPrivateKey(args: CreateAccountFromPrivateKeyArgs): Ed25519Account | SingleKeyAccount {\n    const { privateKey, address, legacy = true } = args;\n    if (privateKey instanceof Ed25519PrivateKey && legacy) {\n      return new Ed25519Account({\n        privateKey,\n        address,\n      });\n    }\n    return new SingleKeyAccount({ privateKey, address });\n  }\n\n  /**\n   * @deprecated use `fromPrivateKey` instead.\n   * Instantiates an account using a private key and a specified account address. This is primarily used to instantiate an\n   * `Account` that has had its authentication key rotated.\n   *\n   * @param args - The arguments required to create an account from a private key.\n   * @param args.privateKey - The underlying private key for the account.\n   * @param args.address - The account address the `Account` will sign for.\n   * @param args.legacy - Optional. If set to false, the keypair generated is a Unified keypair. Defaults to generating a Legacy\n   * Ed25519 keypair.\n   *\n   * @returns Account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static fromPrivateKeyAndAddress(args: CreateAccountFromPrivateKeyArgs) {\n    return this.fromPrivateKey(args);\n  }\n\n  /**\n   * Generates an account from a specified derivation path and mnemonic.\n   * This function allows you to create an account using different signing schemes based on the provided arguments.\n   *\n   * @param args - The arguments for generating the account.\n   * @param args.scheme - The signing scheme to use for account generation. Defaults to Ed25519.\n   * @param args.mnemonic - The mnemonic phrase used to derive the account.\n   * @param args.path - The derivation path used to generate the account.\n   * @param args.legacy - A boolean indicating whether to use the legacy account generation method. Defaults to true.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static fromDerivationPath(args: GenerateEd25519AccountArgs & PrivateKeyFromDerivationPathArgs): Ed25519Account;\n  static fromDerivationPath(\n    args: GenerateEd25519SingleKeyAccountArgs & PrivateKeyFromDerivationPathArgs,\n  ): SingleKeyAccount;\n  static fromDerivationPath(args: GenerateSingleKeyAccountArgs & PrivateKeyFromDerivationPathArgs): SingleKeyAccount;\n  static fromDerivationPath(args: GenerateAccountArgs & PrivateKeyFromDerivationPathArgs): Account;\n  static fromDerivationPath(args: GenerateAccountArgs & PrivateKeyFromDerivationPathArgs) {\n    const { scheme = SigningSchemeInput.Ed25519, mnemonic, path, legacy = true } = args;\n    if (scheme === SigningSchemeInput.Ed25519 && legacy) {\n      return Ed25519Account.fromDerivationPath({ mnemonic, path });\n    }\n    return SingleKeyAccount.fromDerivationPath({ scheme, mnemonic, path });\n  }\n\n  /**\n   * Retrieve the authentication key for the associated account using the provided public key.\n   * This key enables account owners to rotate their private key(s) associated with the account without changing the address that\n   * hosts their account.\n   * See here for more info: {@link https://aptos.dev/concepts/accounts#single-signer-authentication}\n   *\n   * @param args - The arguments for retrieving the authentication key.\n   * @param args.publicKey - The public key of the account.\n   * @returns The authentication key for the associated account.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static authKey(args: { publicKey: AccountPublicKey }): AuthenticationKey {\n    const { publicKey } = args;\n    return publicKey.authKey();\n  }\n\n  /**\n   * Sign a message using the available signing capabilities.\n   * @param message the signing message, as binary input\n   * @return the AccountAuthenticator containing the signature, together with the account's public key\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  abstract signWithAuthenticator(message: HexInput): AccountAuthenticator;\n\n  /**\n   * Sign a transaction using the available signing capabilities.\n   * @param transaction the raw transaction\n   * @return the AccountAuthenticator containing the signature of the transaction, together with the account's public key\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  abstract signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticator;\n\n  /**\n   * Sign the given message using the available signing capabilities.\n   * @param message in HexInput format\n   * @returns Signature\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  abstract sign(message: HexInput): Signature;\n\n  /**\n   * Sign the given transaction using the available signing capabilities.\n   * @param transaction the transaction to be signed\n   * @returns Signature\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  abstract signTransaction(transaction: AnyRawTransaction): Signature;\n\n  /**\n   * Verify the given message and signature with the public key.\n   * This function helps ensure the integrity and authenticity of a message by validating its signature.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.message - The raw message data in HexInput format.\n   * @param args.signature - The signed message signature.\n   * @returns A boolean indicating whether the signature is valid.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  verifySignature(args: VerifySignatureArgs): boolean {\n    return this.publicKey.verifySignature(args);\n  }\n\n  /**\n   * Verify the given message and signature with the public key. It fetches any on chain state if needed for verification.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.aptosConfig - The configuration object for connecting to the Aptos network\n   * @param args.message - Raw message data in HexInput format.\n   * @param args.signature - Signed message signature.\n   * @returns A boolean indicating whether the signature is valid.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: Signature;\n  }): Promise<boolean> {\n    return this.publicKey.verifySignatureAsync(args);\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { randomBytes } from \"@noble/hashes/utils\";\n\nimport {\n  bytesToBigIntLE,\n  padAndPackBytesWithLen,\n  poseidonHash,\n  Ed25519PrivateKey,\n  EphemeralPublicKey,\n  EphemeralSignature,\n  PrivateKey,\n} from \"../core/crypto\";\nimport { Hex } from \"../core/hex\";\nimport { EphemeralPublicKeyVariant, HexInput } from \"../types\";\nimport { Deserializer, Serializable, Serializer } from \"../bcs\";\nimport { floorToWholeHour, nowInSeconds } from \"../utils/helpers\";\n\nconst TWO_WEEKS_IN_SECONDS = 1_209_600;\n\n/**\n * Represents an ephemeral key pair used for signing transactions via the Keyless authentication scheme.\n * This key pair is temporary and includes an expiration time.\n * For more details on how this class is used, refer to the documentation:\n * https://aptos.dev/guides/keyless-accounts/#1-present-the-user-with-a-sign-in-with-idp-button-on-the-ui\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport class EphemeralKeyPair extends Serializable {\n  static readonly BLINDER_LENGTH: number = 31;\n\n  /**\n   * A byte array of length BLINDER_LENGTH used to obfuscate the public key from the IdP.\n   * Used in calculating the nonce passed to the IdP and as a secret witness in proof generation.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly blinder: Uint8Array;\n\n  /**\n   * A timestamp in seconds indicating when the ephemeral key pair is expired.  After expiry, a new\n   * EphemeralKeyPair must be generated and a new JWT needs to be created.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly expiryDateSecs: number;\n\n  /**\n   * The value passed to the IdP when the user authenticates.  It consists of a hash of the\n   * ephemeral public key, expiry date, and blinder.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly nonce: string;\n\n  /**\n   * A private key used to sign transactions.  This private key is not tied to any account on the chain as it\n   * is ephemeral (not permanent) in nature.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  private privateKey: PrivateKey;\n\n  /**\n   * A public key used to verify transactions.  This public key is not tied to any account on the chain as it\n   * is ephemeral (not permanent) in nature.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  private publicKey: EphemeralPublicKey;\n\n  /**\n   * Creates an instance of the class with a specified private key, optional expiry date, and optional blinder.\n   * This constructor initializes the public key, sets the expiry date to a default value if not provided,\n   * generates a blinder if not supplied, and calculates the nonce based on the public key, expiry date, and blinder.\n   *\n   * @param args - The parameters for constructing the instance.\n   * @param args.privateKey - The private key used for creating the instance.\n   * @param args.expiryDateSecs - Optional expiry date in seconds from the current time. Defaults to two weeks from now.\n   * @param args.blinder - Optional blinder value. If not provided, a new blinder will be generated.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  constructor(args: { privateKey: PrivateKey; expiryDateSecs?: number; blinder?: HexInput }) {\n    super();\n    const { privateKey, expiryDateSecs, blinder } = args;\n    this.privateKey = privateKey;\n    this.publicKey = new EphemeralPublicKey(privateKey.publicKey());\n    // By default, we set the expiry date to be two weeks in the future floored to the nearest hour\n    this.expiryDateSecs = expiryDateSecs || floorToWholeHour(nowInSeconds() + TWO_WEEKS_IN_SECONDS);\n    // Generate the blinder if not provided\n    this.blinder = blinder !== undefined ? Hex.fromHexInput(blinder).toUint8Array() : generateBlinder();\n    // Calculate the nonce\n    const fields = padAndPackBytesWithLen(this.publicKey.bcsToBytes(), 93);\n    fields.push(BigInt(this.expiryDateSecs));\n    fields.push(bytesToBigIntLE(this.blinder));\n    const nonceHash = poseidonHash(fields);\n    this.nonce = nonceHash.toString();\n  }\n\n  /**\n   * Returns the public key of the key pair.\n   * @return EphemeralPublicKey\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  getPublicKey(): EphemeralPublicKey {\n    return this.publicKey;\n  }\n\n  /**\n   * Checks if the current time has surpassed the expiry date of the key pair.\n   * @return boolean - Returns true if the key pair is expired, otherwise false.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  isExpired(): boolean {\n    const currentTimeSecs: number = Math.floor(Date.now() / 1000);\n    return currentTimeSecs > this.expiryDateSecs;\n  }\n\n  /**\n   * Serializes the object's properties into a format suitable for transmission or storage.\n   * This function is essential for preparing the object data for serialization processes.\n   *\n   * @param serializer - The serializer instance used to serialize the object's properties.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(this.publicKey.variant);\n    serializer.serializeBytes(this.privateKey.toUint8Array());\n    serializer.serializeU64(this.expiryDateSecs);\n    serializer.serializeFixedBytes(this.blinder);\n  }\n\n  /**\n   * Deserializes an ephemeral key pair from the provided deserializer.\n   * This function helps in reconstructing an ephemeral key pair, which is essential for cryptographic operations.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static deserialize(deserializer: Deserializer): EphemeralKeyPair {\n    const variantIndex = deserializer.deserializeUleb128AsU32();\n    let privateKey: PrivateKey;\n    switch (variantIndex) {\n      case EphemeralPublicKeyVariant.Ed25519:\n        privateKey = Ed25519PrivateKey.deserialize(deserializer);\n        break;\n      default:\n        throw new Error(`Unknown variant index for EphemeralPublicKey: ${variantIndex}`);\n    }\n    const expiryDateSecs = deserializer.deserializeU64();\n    const blinder = deserializer.deserializeFixedBytes(31);\n    return new EphemeralKeyPair({ privateKey, expiryDateSecs: Number(expiryDateSecs), blinder });\n  }\n\n  /**\n   * Deserialize a byte array into an EphemeralKeyPair object.\n   * This function allows you to reconstruct an EphemeralKeyPair from its serialized byte representation.\n   *\n   * @param bytes - The byte array representing the serialized EphemeralKeyPair.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static fromBytes(bytes: Uint8Array): EphemeralKeyPair {\n    return EphemeralKeyPair.deserialize(new Deserializer(bytes));\n  }\n\n  /**\n   * Generates a new ephemeral key pair with an optional expiry date.\n   * This function allows you to create a temporary key pair for secure operations.\n   *\n   * @param args - Optional parameters for key pair generation.\n   * @param args.scheme - The type of key pair to use for the EphemeralKeyPair. Only Ed25519 is supported for now.\n   * @param args.expiryDateSecs - The date of expiry for the key pair in seconds.\n   * @returns An instance of EphemeralKeyPair containing the generated private key and expiry date.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static generate(args?: { scheme?: EphemeralPublicKeyVariant; expiryDateSecs?: number }): EphemeralKeyPair {\n    let privateKey: PrivateKey;\n\n    switch (args?.scheme) {\n      case EphemeralPublicKeyVariant.Ed25519:\n      default:\n        privateKey = Ed25519PrivateKey.generate();\n    }\n\n    return new EphemeralKeyPair({ privateKey, expiryDateSecs: args?.expiryDateSecs });\n  }\n\n  /**\n   * Sign the given data using the private key, returning an ephemeral signature.\n   * This function is essential for creating a secure signature that can be used for authentication or verification purposes.\n   *\n   * @param data - The data to be signed, provided in HexInput format.\n   * @returns EphemeralSignature - The resulting ephemeral signature.\n   * @throws Error - Throws an error if the EphemeralKeyPair has expired.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  sign(data: HexInput): EphemeralSignature {\n    if (this.isExpired()) {\n      throw new Error(\"EphemeralKeyPair has expired\");\n    }\n    return new EphemeralSignature(this.privateKey.sign(data));\n  }\n}\n\n/**\n * Generates a random byte array of length EphemeralKeyPair.BLINDER_LENGTH.\n * @returns Uint8Array A random byte array used for blinding.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nfunction generateBlinder(): Uint8Array {\n  return randomBytes(EphemeralKeyPair.BLINDER_LENGTH);\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport EventEmitter from \"eventemitter3\";\nimport { jwtDecode } from \"jwt-decode\";\nimport { EphemeralCertificateVariant, HexInput, SigningScheme } from \"../types\";\nimport { AccountAddress } from \"../core/accountAddress\";\nimport {\n  AnyPublicKey,\n  AnySignature,\n  KeylessPublicKey,\n  KeylessSignature,\n  EphemeralCertificate,\n  ZeroKnowledgeSig,\n  ZkProof,\n  MoveJWK,\n  getKeylessConfig,\n  fetchJWK,\n  KeylessConfiguration,\n} from \"../core/crypto\";\n\nimport { EphemeralKeyPair } from \"./EphemeralKeyPair\";\nimport { Hex } from \"../core/hex\";\nimport { AccountAuthenticatorSingleKey } from \"../transactions/authenticator/account\";\nimport { Deserializer, Serializable, Serializer } from \"../bcs\";\nimport { deriveTransactionType, generateSigningMessage } from \"../transactions/transactionBuilder/signingMessage\";\nimport { AnyRawTransaction, AnyRawTransactionInstance } from \"../transactions/types\";\nimport { base64UrlDecode } from \"../utils/helpers\";\nimport { FederatedKeylessPublicKey } from \"../core/crypto/federatedKeyless\";\nimport { Account } from \"./Account\";\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { KeylessError, KeylessErrorType } from \"../errors\";\nimport type { SingleKeySigner } from \"./SingleKeyAccount\";\n\n/**\n * An interface which defines if an Account utilizes Keyless signing.\n */\nexport interface KeylessSigner extends Account {\n  checkKeylessAccountValidity(aptosConfig: AptosConfig): Promise<void>;\n}\n\nexport function isKeylessSigner(obj: any): obj is KeylessSigner {\n  return obj !== null && obj !== undefined && typeof obj.checkKeylessAccountValidity === \"function\";\n}\n\n/**\n * Account implementation for the Keyless authentication scheme.  This abstract class is used for standard Keyless Accounts\n * and Federated Keyless Accounts.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport abstract class AbstractKeylessAccount extends Serializable implements KeylessSigner, SingleKeySigner {\n  static readonly PEPPER_LENGTH: number = 31;\n\n  /**\n   * The KeylessPublicKey associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly publicKey: KeylessPublicKey | FederatedKeylessPublicKey;\n\n  /**\n   * The EphemeralKeyPair used to generate sign.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly ephemeralKeyPair: EphemeralKeyPair;\n\n  /**\n   * The claim on the JWT to identify a user.  This is typically 'sub' or 'email'.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly uidKey: string;\n\n  /**\n   * The value of the uidKey claim on the JWT.  This intended to be a stable user identifier.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly uidVal: string;\n\n  /**\n   * The value of the 'aud' claim on the JWT, also known as client ID.  This is the identifier for the dApp's\n   * OIDC registration with the identity provider.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly aud: string;\n\n  /**\n   * A value contains 31 bytes of entropy that preserves privacy of the account. Typically fetched from a pepper provider.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly pepper: Uint8Array;\n\n  /**\n   * Account address associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly accountAddress: AccountAddress;\n\n  /**\n   * The zero knowledge signature (if ready) which contains the proof used to validate the EphemeralKeyPair.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  proof: ZeroKnowledgeSig | undefined;\n\n  /**\n   * The proof of the EphemeralKeyPair or a promise that provides the proof.  This is used to allow for awaiting on\n   * fetching the proof.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly proofOrPromise: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n\n  /**\n   * Signing scheme used to sign transactions\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly signingScheme: SigningScheme = SigningScheme.SingleKey;\n\n  /**\n   * The JWT token used to derive the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly jwt: string;\n\n  /**\n   * The hash of the verification key used to verify the proof. This is optional and can be used to check verifying key\n   * rotations which may invalidate the proof.\n   */\n  readonly verificationKeyHash?: Uint8Array;\n\n  /**\n   * An event emitter used to assist in handling asynchronous proof fetching.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  private readonly emitter: EventEmitter<ProofFetchEvents>;\n\n  /**\n   * Use the static generator `create(...)` instead.\n   * Creates an instance of the KeylessAccount with an optional proof.\n   *\n   * @param args - The parameters for creating a KeylessAccount.\n   * @param args.address - Optional account address associated with the KeylessAccount.\n   * @param args.publicKey - A KeylessPublicKey or FederatedKeylessPublicKey.\n   * @param args.ephemeralKeyPair - The ephemeral key pair used in the account creation.\n   * @param args.iss - A JWT issuer.\n   * @param args.uidKey - The claim on the JWT to identify a user.  This is typically 'sub' or 'email'.\n   * @param args.uidVal - The unique id for this user, intended to be a stable user identifier.\n   * @param args.aud - The value of the 'aud' claim on the JWT, also known as client ID.  This is the identifier for the dApp's\n   * OIDC registration with the identity provider.\n   * @param args.pepper - A hexadecimal input used for additional security.\n   * @param args.proof - A Zero Knowledge Signature or a promise that resolves to one.\n   * @param args.proofFetchCallback - Optional callback function for fetching proof.\n   * @param args.jwt - A JSON Web Token used for authentication.\n   * @param args.verificationKeyHash Optional 32-byte verification key hash as hex input used to check proof validity.\n   */\n  protected constructor(args: {\n    address?: AccountAddress;\n    publicKey: KeylessPublicKey | FederatedKeylessPublicKey;\n    ephemeralKeyPair: EphemeralKeyPair;\n    iss: string;\n    uidKey: string;\n    uidVal: string;\n    aud: string;\n    pepper: HexInput;\n    proof: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n    proofFetchCallback?: ProofFetchCallback;\n    jwt: string;\n    verificationKeyHash?: HexInput;\n  }) {\n    super();\n    const {\n      address,\n      ephemeralKeyPair,\n      publicKey,\n      uidKey,\n      uidVal,\n      aud,\n      pepper,\n      proof,\n      proofFetchCallback,\n      jwt,\n      verificationKeyHash,\n    } = args;\n    this.ephemeralKeyPair = ephemeralKeyPair;\n    this.publicKey = publicKey;\n    this.accountAddress = address ? AccountAddress.from(address) : this.publicKey.authKey().derivedAddress();\n    this.uidKey = uidKey;\n    this.uidVal = uidVal;\n    this.aud = aud;\n    this.jwt = jwt;\n    this.emitter = new EventEmitter<ProofFetchEvents>();\n    this.proofOrPromise = proof;\n    if (proof instanceof ZeroKnowledgeSig) {\n      this.proof = proof;\n    } else {\n      if (proofFetchCallback === undefined) {\n        throw new Error(\"Must provide callback for async proof fetch\");\n      }\n      this.emitter.on(\"proofFetchFinish\", async (status) => {\n        await proofFetchCallback(status);\n        this.emitter.removeAllListeners();\n      });\n      // Note, this is purposely not awaited to be non-blocking.  The caller should await on the proofFetchCallback.\n      this.init(proof);\n    }\n    const pepperBytes = Hex.fromHexInput(pepper).toUint8Array();\n    if (pepperBytes.length !== AbstractKeylessAccount.PEPPER_LENGTH) {\n      throw new Error(`Pepper length in bytes should be ${AbstractKeylessAccount.PEPPER_LENGTH}`);\n    }\n    this.pepper = pepperBytes;\n    if (verificationKeyHash !== undefined) {\n      if (Hex.hexInputToUint8Array(verificationKeyHash).length !== 32) {\n        throw new Error(\"verificationKeyHash must be 32 bytes\");\n      }\n      this.verificationKeyHash = Hex.hexInputToUint8Array(verificationKeyHash);\n    }\n  }\n\n  getAnyPublicKey(): AnyPublicKey {\n    return new AnyPublicKey(this.publicKey);\n  }\n\n  /**\n   * This initializes the asynchronous proof fetch\n   * @return Emits whether the proof succeeds or fails, but has no return.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  async init(promise: Promise<ZeroKnowledgeSig>) {\n    try {\n      this.proof = await promise;\n      this.emitter.emit(\"proofFetchFinish\", { status: \"Success\" });\n    } catch (error) {\n      if (error instanceof Error) {\n        this.emitter.emit(\"proofFetchFinish\", { status: \"Failed\", error: error.toString() });\n      } else {\n        this.emitter.emit(\"proofFetchFinish\", { status: \"Failed\", error: \"Unknown\" });\n      }\n    }\n  }\n\n  /**\n   * Serializes the jwt data into a format suitable for transmission or storage.\n   * This function ensures that both the jwt data and the proof are properly serialized.\n   *\n   * @param serializer - The serializer instance used to convert the jwt data into bytes.\n   */\n  serialize(serializer: Serializer): void {\n    this.accountAddress.serialize(serializer);\n    serializer.serializeStr(this.jwt);\n    serializer.serializeStr(this.uidKey);\n    serializer.serializeFixedBytes(this.pepper);\n    this.ephemeralKeyPair.serialize(serializer);\n    if (this.proof === undefined) {\n      throw new Error(\"Cannot serialize - proof undefined\");\n    }\n    this.proof.serialize(serializer);\n    serializer.serializeOption(this.verificationKeyHash, 32);\n  }\n\n  static partialDeserialize(deserializer: Deserializer): {\n    address: AccountAddress;\n    jwt: string;\n    uidKey: string;\n    pepper: Uint8Array;\n    ephemeralKeyPair: EphemeralKeyPair;\n    proof: ZeroKnowledgeSig;\n    verificationKeyHash?: Uint8Array;\n  } {\n    const address = AccountAddress.deserialize(deserializer);\n    const jwt = deserializer.deserializeStr();\n    const uidKey = deserializer.deserializeStr();\n    const pepper = deserializer.deserializeFixedBytes(31);\n    const ephemeralKeyPair = EphemeralKeyPair.deserialize(deserializer);\n    const proof = ZeroKnowledgeSig.deserialize(deserializer);\n    const verificationKeyHash = deserializer.deserializeOption(\"fixedBytes\", 32);\n\n    return { address, jwt, uidKey, pepper, ephemeralKeyPair, proof, verificationKeyHash };\n  }\n\n  /**\n   * Checks if the proof is expired.  If so the account must be re-derived with a new EphemeralKeyPair\n   * and JWT token.\n   * @return boolean\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  isExpired(): boolean {\n    return this.ephemeralKeyPair.isExpired();\n  }\n\n  /**\n   * Sign a message using Keyless.\n   * @param message the message to sign, as binary input\n   * @return the AccountAuthenticator containing the signature, together with the account's public key\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signWithAuthenticator(message: HexInput): AccountAuthenticatorSingleKey {\n    const signature = new AnySignature(this.sign(message));\n    const publicKey = new AnyPublicKey(this.publicKey);\n    return new AccountAuthenticatorSingleKey(publicKey, signature);\n  }\n\n  /**\n   * Sign a transaction using Keyless.\n   * @param transaction the raw transaction\n   * @return the AccountAuthenticator containing the signature of the transaction, together with the account's public key\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorSingleKey {\n    const signature = new AnySignature(this.signTransaction(transaction));\n    const publicKey = new AnyPublicKey(this.publicKey);\n    return new AccountAuthenticatorSingleKey(publicKey, signature);\n  }\n\n  /**\n   * Waits for asynchronous proof fetching to finish.\n   * @return\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  async waitForProofFetch() {\n    if (this.proofOrPromise instanceof Promise) {\n      await this.proofOrPromise;\n    }\n  }\n\n  /**\n   * Validates that the Keyless Account can be used to sign transactions.\n   * @return\n   */\n  async checkKeylessAccountValidity(aptosConfig: AptosConfig): Promise<void> {\n    if (this.isExpired()) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.EPHEMERAL_KEY_PAIR_EXPIRED,\n      });\n    }\n    await this.waitForProofFetch();\n    if (this.proof === undefined) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.ASYNC_PROOF_FETCH_FAILED,\n      });\n    }\n    const header = jwtDecode(this.jwt, { header: true });\n    if (header.kid === undefined) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.JWT_PARSING_ERROR,\n        details: \"checkKeylessAccountValidity failed. JWT is missing 'kid' in header. This should never happen.\",\n      });\n    }\n    if (this.verificationKeyHash !== undefined) {\n      const { verificationKey } = await getKeylessConfig({ aptosConfig });\n      if (Hex.hexInputToString(verificationKey.hash()) !== Hex.hexInputToString(this.verificationKeyHash)) {\n        throw KeylessError.fromErrorType({\n          type: KeylessErrorType.INVALID_PROOF_VERIFICATION_KEY_NOT_FOUND,\n        });\n      }\n    } else {\n      // eslint-disable-next-line no-console\n      console.warn(\n        \"[Aptos SDK] The verification key hash was not set. Proof may be invalid if the verification key has rotated.\",\n      );\n    }\n    await AbstractKeylessAccount.fetchJWK({ aptosConfig, publicKey: this.publicKey, kid: header.kid });\n  }\n\n  /**\n   * Sign the given message using Keyless.\n   * @param message in HexInput format\n   * @returns Signature\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  sign(message: HexInput): KeylessSignature {\n    const { expiryDateSecs } = this.ephemeralKeyPair;\n    if (this.isExpired()) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.EPHEMERAL_KEY_PAIR_EXPIRED,\n      });\n    }\n    if (this.proof === undefined) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.PROOF_NOT_FOUND,\n        details: \"Proof not found - make sure to call `await account.checkKeylessAccountValidity()` before signing.\",\n      });\n    }\n    const ephemeralPublicKey = this.ephemeralKeyPair.getPublicKey();\n    const ephemeralSignature = this.ephemeralKeyPair.sign(message);\n\n    return new KeylessSignature({\n      jwtHeader: base64UrlDecode(this.jwt.split(\".\")[0]),\n      ephemeralCertificate: new EphemeralCertificate(this.proof, EphemeralCertificateVariant.ZkProof),\n      expiryDateSecs,\n      ephemeralPublicKey,\n      ephemeralSignature,\n    });\n  }\n\n  /**\n   * Sign the given transaction with Keyless.\n   * Signs the transaction and proof to guard against proof malleability.\n   * @param transaction the transaction to be signed\n   * @returns KeylessSignature\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signTransaction(transaction: AnyRawTransaction): KeylessSignature {\n    if (this.proof === undefined) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.PROOF_NOT_FOUND,\n        details: \"Proof not found - make sure to call `await account.checkKeylessAccountValidity()` before signing.\",\n      });\n    }\n    const raw = deriveTransactionType(transaction);\n    const txnAndProof = new TransactionAndProof(raw, this.proof.proof);\n    const signMess = txnAndProof.hash();\n    return this.sign(signMess);\n  }\n\n  getSigningMessage(transaction: AnyRawTransaction): Uint8Array {\n    if (this.proof === undefined) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.PROOF_NOT_FOUND,\n        details: \"Proof not found - make sure to call `await account.checkKeylessAccountValidity()` before signing.\",\n      });\n    }\n    const raw = deriveTransactionType(transaction);\n    const txnAndProof = new TransactionAndProof(raw, this.proof.proof);\n    return txnAndProof.hash();\n  }\n\n  /**\n   * Note - This function is currently incomplete and should only be used to verify ownership of the KeylessAccount\n   *\n   * Verifies a signature given the message.\n   *\n   * @param args.message the message that was signed.\n   * @param args.signature the KeylessSignature to verify\n   * @returns boolean\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  verifySignature(args: {\n    message: HexInput;\n    signature: KeylessSignature;\n    jwk: MoveJWK;\n    keylessConfig: KeylessConfiguration;\n  }): boolean {\n    return this.publicKey.verifySignature(args);\n  }\n\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: KeylessSignature;\n    options?: { throwErrorWithReason?: boolean };\n  }): Promise<boolean> {\n    return this.publicKey.verifySignatureAsync({\n      ...args,\n    });\n  }\n\n  /**\n   * Fetches the JWK from the issuer's well-known JWKS endpoint.\n   *\n   * @param args.publicKey The keyless public key to query\n   * @param args.kid The kid of the JWK to fetch\n   * @returns A JWK matching the `kid` in the JWT header.\n   * @throws {KeylessError} If the JWK cannot be fetched\n   */\n  static async fetchJWK(args: {\n    aptosConfig: AptosConfig;\n    publicKey: KeylessPublicKey | FederatedKeylessPublicKey;\n    kid: string;\n  }): Promise<MoveJWK> {\n    return fetchJWK(args);\n  }\n}\n\n/**\n * A container class to hold a transaction and a proof.  It implements CryptoHashable which is used to create\n * the signing message for Keyless transactions.  We sign over the proof to ensure non-malleability.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport class TransactionAndProof extends Serializable {\n  /**\n   * The transaction to sign.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  transaction: AnyRawTransactionInstance;\n\n  /**\n   * The zero knowledge proof used in signing the transaction.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  proof?: ZkProof;\n\n  /**\n   * The domain separator prefix used when hashing.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly domainSeparator = \"APTOS::TransactionAndProof\";\n\n  constructor(transaction: AnyRawTransactionInstance, proof?: ZkProof) {\n    super();\n    this.transaction = transaction;\n    this.proof = proof;\n  }\n\n  /**\n   * Serializes the transaction data into a format suitable for transmission or storage.\n   * This function ensures that both the transaction bytes and the proof are properly serialized.\n   *\n   * @param serializer - The serializer instance used to convert the transaction data into bytes.\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeFixedBytes(this.transaction.bcsToBytes());\n    serializer.serializeOption(this.proof);\n  }\n\n  /**\n   * Hashes the bcs serialized from of the class. This is the typescript corollary to the BCSCryptoHash macro in aptos-core.\n   *\n   * @returns Uint8Array\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  hash(): Uint8Array {\n    return generateSigningMessage(this.bcsToBytes(), this.domainSeparator);\n  }\n}\n/**\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport type ProofFetchSuccess = {\n  status: \"Success\";\n};\n/**\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport type ProofFetchFailure = {\n  status: \"Failed\";\n  error: string;\n};\n/**\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport type ProofFetchStatus = ProofFetchSuccess | ProofFetchFailure;\n/**\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport type ProofFetchCallback = (status: ProofFetchStatus) => Promise<void>;\n/**\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface ProofFetchEvents {\n  proofFetchFinish: (status: ProofFetchStatus) => void;\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { HexInput } from \"../types\";\nimport { AccountAddress } from \"../core/accountAddress\";\nimport { getIssAudAndUidVal, Groth16VerificationKey, KeylessPublicKey, ZeroKnowledgeSig } from \"../core/crypto\";\n\nimport { EphemeralKeyPair } from \"./EphemeralKeyPair\";\nimport { Deserializer, Serializer } from \"../bcs\";\nimport { AbstractKeylessAccount, ProofFetchCallback } from \"./AbstractKeylessAccount\";\nimport { Hex } from \"../core/hex\";\n\n/**\n * Account implementation for the Keyless authentication scheme.\n *\n * Used to represent a Keyless based account and sign transactions with it.\n *\n * Use `KeylessAccount.create()` to instantiate a KeylessAccount with a JWT, proof and EphemeralKeyPair.\n *\n * When the proof expires or the JWT becomes invalid, the KeylessAccount must be instantiated again with a new JWT,\n * EphemeralKeyPair, and corresponding proof.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport class KeylessAccount extends AbstractKeylessAccount {\n  /**\n   * The KeylessPublicKey associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly publicKey: KeylessPublicKey;\n\n  // Use the static constructor 'create' instead.\n\n  /**\n   * Use the static generator `create(...)` instead.\n   * Creates an instance of the KeylessAccount with an optional proof.\n   *\n   * @param args - The parameters for creating a KeylessAccount.\n   * @param args.address - Optional account address associated with the KeylessAccount.\n   * @param args.ephemeralKeyPair - The ephemeral key pair used in the account creation.\n   * @param args.iss - A JWT issuer.\n   * @param args.uidKey - The claim on the JWT to identify a user.  This is typically 'sub' or 'email'.\n   * @param args.uidVal - The unique id for this user, intended to be a stable user identifier.\n   * @param args.aud - The value of the 'aud' claim on the JWT, also known as client ID.  This is the identifier for the dApp's\n   * OIDC registration with the identity provider.\n   * @param args.pepper - A hexadecimal input used for additional security.\n   * @param args.proof - A Zero Knowledge Signature or a promise that resolves to one.\n   * @param args.proofFetchCallback - Optional callback function for fetching proof.\n   * @param args.jwt - A JSON Web Token used for authentication.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  constructor(args: {\n    address?: AccountAddress;\n    ephemeralKeyPair: EphemeralKeyPair;\n    iss: string;\n    uidKey: string;\n    uidVal: string;\n    aud: string;\n    pepper: HexInput;\n    proof: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n    proofFetchCallback?: ProofFetchCallback;\n    jwt: string;\n    verificationKeyHash?: HexInput;\n  }) {\n    const publicKey = KeylessPublicKey.create(args);\n    super({ publicKey, ...args });\n    this.publicKey = publicKey;\n  }\n\n  /**\n   * Serializes the transaction data into a format suitable for transmission or storage.\n   * This function ensures that both the transaction bytes and the proof are properly serialized.\n   *\n   * @param serializer - The serializer instance used to convert the transaction data into bytes.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  serialize(serializer: Serializer): void {\n    super.serialize(serializer);\n  }\n\n  /**\n   * Deserializes the provided deserializer to create a KeylessAccount instance.\n   * This function extracts necessary components such as the JWT, UID key, pepper, ephemeral key pair, and proof from the deserializer.\n   *\n   * @param deserializer - The deserializer instance used to retrieve the serialized data.\n   * @returns A KeylessAccount instance created from the deserialized data.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static deserialize(deserializer: Deserializer): KeylessAccount {\n    const { address, proof, ephemeralKeyPair, jwt, uidKey, pepper, verificationKeyHash } =\n      AbstractKeylessAccount.partialDeserialize(deserializer);\n    const { iss, aud, uidVal } = getIssAudAndUidVal({ jwt, uidKey });\n    return new KeylessAccount({\n      address,\n      proof,\n      ephemeralKeyPair,\n      iss,\n      uidKey,\n      uidVal,\n      aud,\n      pepper,\n      jwt,\n      verificationKeyHash,\n    });\n  }\n\n  /**\n   * Deserialize bytes using this account's information.\n   *\n   * @param bytes The bytes being interpreted.\n   * @returns\n   */\n  static fromBytes(bytes: HexInput): KeylessAccount {\n    return KeylessAccount.deserialize(new Deserializer(Hex.hexInputToUint8Array(bytes)));\n  }\n\n  /**\n   * Creates a KeylessAccount instance using the provided parameters.\n   * This function allows you to set up a KeylessAccount with specific attributes such as address, proof, and JWT.\n   * This is used instead of the KeylessAccount constructor.\n   *\n   * @param args - The parameters for creating a KeylessAccount.\n   * @param args.address - Optional account address associated with the KeylessAccount.\n   * @param args.proof - A Zero Knowledge Signature or a promise that resolves to one.\n   * @param args.jwt - A JSON Web Token used for authentication.\n   * @param args.ephemeralKeyPair - The ephemeral key pair used in the account creation.\n   * @param args.pepper - A hexadecimal input used for additional security.\n   * @param args.uidKey - Optional key for user identification, defaults to \"sub\".\n   * @param args.proofFetchCallback - Optional callback function for fetching proof.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static create(args: {\n    address?: AccountAddress;\n    proof: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n    jwt: string;\n    ephemeralKeyPair: EphemeralKeyPair;\n    pepper: HexInput;\n    uidKey?: string;\n    proofFetchCallback?: ProofFetchCallback;\n    verificationKey?: Groth16VerificationKey;\n  }): KeylessAccount {\n    const { address, proof, jwt, ephemeralKeyPair, pepper, uidKey = \"sub\", proofFetchCallback, verificationKey } = args;\n\n    const { iss, aud, uidVal } = getIssAudAndUidVal({ jwt, uidKey });\n    return new KeylessAccount({\n      address,\n      proof,\n      ephemeralKeyPair,\n      iss,\n      uidKey,\n      uidVal,\n      aud,\n      pepper,\n      jwt,\n      proofFetchCallback,\n      verificationKeyHash: verificationKey ? verificationKey.hash() : undefined,\n    });\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { HexInput } from \"../types\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { getIssAudAndUidVal, Groth16VerificationKey, ZeroKnowledgeSig } from \"../core/crypto\";\n\nimport { EphemeralKeyPair } from \"./EphemeralKeyPair\";\nimport { Deserializer, Serializer } from \"../bcs\";\nimport { FederatedKeylessPublicKey } from \"../core/crypto/federatedKeyless\";\nimport { AbstractKeylessAccount, ProofFetchCallback } from \"./AbstractKeylessAccount\";\n\n/**\n * Account implementation for the FederatedKeyless authentication scheme.\n *\n * Used to represent a FederatedKeyless based account and sign transactions with it.\n *\n * Use `FederatedKeylessAccount.create()` to instantiate a KeylessAccount with a JSON Web Token (JWT), proof, EphemeralKeyPair and the\n * address the JSON Web Key Set (JWKS) are installed that will be used to verify the JWT.\n *\n * When the proof expires or the JWT becomes invalid, the KeylessAccount must be instantiated again with a new JWT,\n * EphemeralKeyPair, and corresponding proof.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport class FederatedKeylessAccount extends AbstractKeylessAccount {\n  /**\n   * The FederatedKeylessPublicKey associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly publicKey: FederatedKeylessPublicKey;\n\n  readonly audless: boolean;\n\n  /**\n   * Use the static generator `FederatedKeylessAccount.create(...)` instead.\n   * Creates a KeylessAccount instance using the provided parameters.\n   * This function allows you to set up a KeylessAccount with specific attributes such as address, proof, and JWT.\n   *\n   * @param args - The parameters for creating a KeylessAccount.\n   * @param args.address - Optional account address associated with the KeylessAccount.\n   * @param args.proof - A Zero Knowledge Signature or a promise that resolves to one.\n   * @param args.jwt - A JSON Web Token used for authentication.\n   * @param args.ephemeralKeyPair - The ephemeral key pair used in the account creation.\n   * @param args.jwkAddress - The address which stores the JSON Web Key Set (JWKS) used to verify the JWT.\n   * @param args.uidKey - Optional key for user identification, defaults to \"sub\".\n   * @param args.proofFetchCallback - Optional callback function for fetching proof.\n   */\n  constructor(args: {\n    address?: AccountAddress;\n    ephemeralKeyPair: EphemeralKeyPair;\n    iss: string;\n    uidKey: string;\n    uidVal: string;\n    aud: string;\n    pepper: HexInput;\n    jwkAddress: AccountAddress;\n    proof: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n    proofFetchCallback?: ProofFetchCallback;\n    jwt: string;\n    verificationKeyHash?: HexInput;\n    audless?: boolean;\n  }) {\n    const publicKey = FederatedKeylessPublicKey.create(args);\n    super({ publicKey, ...args });\n    this.publicKey = publicKey;\n    this.audless = args.audless ?? false;\n  }\n\n  /**\n   * Serializes the transaction data into a format suitable for transmission or storage.\n   * This function ensures that both the transaction bytes and the proof are properly serialized.\n   *\n   * @param serializer - The serializer instance used to convert the transaction data into bytes.\n   */\n  serialize(serializer: Serializer): void {\n    super.serialize(serializer);\n    this.publicKey.jwkAddress.serialize(serializer);\n  }\n\n  /**\n   * Deserializes the provided deserializer to create a KeylessAccount instance.\n   * This function extracts necessary components such as the JWT, UID key, pepper, ephemeral key pair, and proof from the deserializer.\n   *\n   * @param deserializer - The deserializer instance used to retrieve the serialized data.\n   * @returns A KeylessAccount instance created from the deserialized data.\n   */\n  static deserialize(deserializer: Deserializer): FederatedKeylessAccount {\n    const { address, proof, ephemeralKeyPair, jwt, uidKey, pepper, verificationKeyHash } =\n      AbstractKeylessAccount.partialDeserialize(deserializer);\n    const jwkAddress = AccountAddress.deserialize(deserializer);\n    const { iss, aud, uidVal } = getIssAudAndUidVal({ jwt, uidKey });\n    return new FederatedKeylessAccount({\n      address,\n      proof,\n      ephemeralKeyPair,\n      iss,\n      uidKey,\n      uidVal,\n      aud,\n      pepper,\n      jwt,\n      verificationKeyHash,\n      jwkAddress,\n    });\n  }\n\n  /**\n   * Deserialize bytes using this account's information.\n   *\n   * @param bytes The bytes being interpreted.\n   * @returns\n   */\n  static fromBytes(bytes: HexInput): FederatedKeylessAccount {\n    return FederatedKeylessAccount.deserialize(Deserializer.fromHex(bytes));\n  }\n\n  /**\n   * Creates a KeylessAccount instance using the provided parameters.\n   * This function allows you to set up a KeylessAccount with specific attributes such as address, proof, and JWT.\n   * This is used instead of the KeylessAccount constructor.\n   *\n   * @param args - The parameters for creating a KeylessAccount.\n   * @param args.address - Optional account address associated with the KeylessAccount.\n   * @param args.proof - A Zero Knowledge Signature or a promise that resolves to one.\n   * @param args.jwt - A JSON Web Token used for authentication.\n   * @param args.ephemeralKeyPair - The ephemeral key pair used in the account creation.\n   * @param args.jwkAddress - The address which stores the JSON Web Key Set (JWKS) used to verify the JWT.\n   * @param args.uidKey - Optional key for user identification, defaults to \"sub\".\n   * @param args.proofFetchCallback - Optional callback function for fetching proof.\n   */\n  static create(args: {\n    address?: AccountAddress;\n    proof: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n    jwt: string;\n    ephemeralKeyPair: EphemeralKeyPair;\n    pepper: HexInput;\n    jwkAddress: AccountAddressInput;\n    uidKey?: string;\n    proofFetchCallback?: ProofFetchCallback;\n    verificationKey?: Groth16VerificationKey;\n  }): FederatedKeylessAccount {\n    const {\n      address,\n      proof,\n      jwt,\n      ephemeralKeyPair,\n      pepper,\n      jwkAddress,\n      uidKey = \"sub\",\n      proofFetchCallback,\n      verificationKey,\n    } = args;\n\n    const { iss, aud, uidVal } = getIssAudAndUidVal({ jwt, uidKey });\n    return new FederatedKeylessAccount({\n      address,\n      proof,\n      ephemeralKeyPair,\n      iss,\n      uidKey,\n      uidVal,\n      aud,\n      pepper,\n      jwkAddress: AccountAddress.from(jwkAddress),\n      jwt,\n      proofFetchCallback,\n      verificationKeyHash: verificationKey ? verificationKey.hash() : undefined,\n    });\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Account } from \"./Account\";\nimport { MultiKey, MultiKeySignature, PublicKey } from \"../core/crypto\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { HexInput, SigningScheme } from \"../types\";\nimport { AccountAuthenticatorMultiKey } from \"../transactions/authenticator/account\";\nimport { AnyRawTransaction } from \"../transactions/types\";\nimport { AbstractKeylessAccount, KeylessSigner } from \"./AbstractKeylessAccount\";\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { SingleKeyAccount, SingleKeySigner, SingleKeySignerOrLegacyEd25519Account } from \"./SingleKeyAccount\";\nimport { Ed25519Account } from \"./Ed25519Account\";\n\n/**\n * Arguments required to verify a multi-key signature against a given message.\n *\n * @param message - The original message that was signed.\n * @param signature - The multi-key signature to be verified.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface VerifyMultiKeySignatureArgs {\n  message: HexInput;\n  signature: MultiKeySignature;\n}\n\n/**\n * Signer implementation for the MultiKey authentication scheme.\n *\n * This account utilizes an M of N signing scheme, where M and N are specified in the {@link MultiKey}.\n * It signs messages using an array of M accounts, each corresponding to a public key in the {@link MultiKey}.\n *\n * Note: Generating a signer instance does not create the account on-chain.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport class MultiKeyAccount implements Account, KeylessSigner {\n  /**\n   * Public key associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly publicKey: MultiKey;\n\n  /**\n   * Account address associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly accountAddress: AccountAddress;\n\n  /**\n   * Signing scheme used to sign transactions\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly signingScheme: SigningScheme = SigningScheme.MultiKey;\n\n  /**\n   * The signers used to sign messages.  These signers should correspond to public keys in the\n   * MultiKeyAccount's public key.  The number of signers should be equal to this.publicKey.signaturesRequired.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly signers: Account[];\n\n  /**\n   * An array of indices where for signer[i], signerIndicies[i] is the index of the corresponding public key in\n   * publicKey.publicKeys.  Used to derive the right public key to use for verification.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  // TODO: Rename Indicies to Indices\n  readonly signerIndicies: number[];\n\n  readonly signaturesBitmap: Uint8Array;\n\n  /**\n   * Constructs a MultiKeyAccount instance, which requires multiple signatures for transactions.\n   *\n   * @param args - The arguments for creating a MultiKeyAccount.\n   * @param args.multiKey - The multikey of the account consisting of N public keys and a number M representing the required signatures.\n   * @param args.signers - An array of M signers that will be used to sign the transaction.\n   * @param args.address - An optional account address input. If not provided, the derived address from the public key will be used.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  constructor(args: {\n    multiKey: MultiKey;\n    signers: SingleKeySignerOrLegacyEd25519Account[];\n    address?: AccountAddressInput;\n  }) {\n    const { multiKey, address } = args;\n\n    const signers: SingleKeySigner[] = args.signers.map((signer) =>\n      signer instanceof Ed25519Account ? SingleKeyAccount.fromEd25519Account(signer) : signer,\n    );\n\n    if (multiKey.signaturesRequired > signers.length) {\n      throw new Error(\n        // eslint-disable-next-line max-len\n        `Not enough signers provided to satisfy the required signatures. Need ${multiKey.signaturesRequired} signers, but only ${signers.length} provided`,\n      );\n    } else if (multiKey.signaturesRequired < signers.length) {\n      throw new Error(\n        // eslint-disable-next-line max-len\n        `More signers provided than required. Need ${multiKey.signaturesRequired} signers, but ${signers.length} provided`,\n      );\n    }\n\n    this.publicKey = multiKey;\n\n    this.accountAddress = address ? AccountAddress.from(address) : this.publicKey.authKey().derivedAddress();\n\n    // For each signer, find its corresponding position in the MultiKey's public keys array\n    const bitPositions: number[] = [];\n    for (const signer of signers) {\n      bitPositions.push(this.publicKey.getIndex(signer.getAnyPublicKey()));\n    }\n\n    // Create pairs of [signer, position] and sort them by position\n    // This sorting is critical because:\n    // 1. The on-chain verification expects signatures to be in ascending order by bit position\n    // 2. The bitmap must match the order of signatures when verifying\n    const signersAndBitPosition: [Account, number][] = signers.map((signer, index) => [signer, bitPositions[index]]);\n    signersAndBitPosition.sort((a, b) => a[1] - b[1]);\n\n    // Extract the sorted signers and their positions into separate arrays\n    this.signers = signersAndBitPosition.map((value) => value[0]);\n    this.signerIndicies = signersAndBitPosition.map((value) => value[1]);\n\n    // Create a bitmap representing which public keys from the MultiKey are being used\n    // This bitmap is used during signature verification to identify which public keys\n    // should be used to verify each signature\n    this.signaturesBitmap = this.publicKey.createBitmap({ bits: bitPositions });\n  }\n\n  /**\n   * Static constructor to create a MultiKeyAccount using the provided public keys and signers.\n   *\n   * @param args - The arguments for creating a MultiKeyAccount.\n   * @param args.publicKeys - The N public keys of the MultiKeyAccount.\n   * @param args.signaturesRequired - The number of signatures required to authorize a transaction.\n   * @param args.signers - An array of M signers that will be used to sign the transaction.\n   * @returns MultiKeyAccount - The newly created MultiKeyAccount.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static fromPublicKeysAndSigners(args: {\n    address?: AccountAddressInput;\n    publicKeys: PublicKey[];\n    signaturesRequired: number;\n    signers: SingleKeySignerOrLegacyEd25519Account[];\n  }): MultiKeyAccount {\n    const { address, publicKeys, signaturesRequired, signers } = args;\n    const multiKey = new MultiKey({ publicKeys, signaturesRequired });\n    return new MultiKeyAccount({ multiKey, signers, address });\n  }\n\n  /**\n   * Determines if the provided account is a multi-key account.\n   *\n   * @param account - The account to check.\n   * @returns A boolean indicating whether the account is a multi-key account.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static isMultiKeySigner(account: Account): account is MultiKeyAccount {\n    return account instanceof MultiKeyAccount;\n  }\n\n  /**\n   * Sign a message using the account's signers and return an AccountAuthenticator containing the signature along with the\n   * account's public key.\n   * @param message - The signing message, represented as binary input in hexadecimal format.\n   * @returns An instance of AccountAuthenticatorMultiKey that includes the signature and the public key.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signWithAuthenticator(message: HexInput): AccountAuthenticatorMultiKey {\n    return new AccountAuthenticatorMultiKey(this.publicKey, this.sign(message));\n  }\n\n  /**\n   * Sign a transaction using the account's signers, returning an AccountAuthenticator that contains the signature and the\n   * account's public key.\n   * @param transaction - The raw transaction to be signed.\n   * @returns An AccountAuthenticatorMultiKey containing the signature of the transaction along with the account's public key.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorMultiKey {\n    return new AccountAuthenticatorMultiKey(this.publicKey, this.signTransaction(transaction));\n  }\n\n  /**\n   * Waits for any proofs on KeylessAccount signers to be fetched. This ensures that signing with the KeylessAccount does not\n   * fail due to missing proofs.\n   * @return {Promise<void>} A promise that resolves when all proofs have been fetched.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  async waitForProofFetch(): Promise<void> {\n    const keylessSigners = this.signers.filter(\n      (signer) => signer instanceof AbstractKeylessAccount,\n    ) as AbstractKeylessAccount[];\n    const promises = keylessSigners.map(async (signer) => signer.waitForProofFetch());\n    await Promise.all(promises);\n  }\n\n  /**\n   * Validates that the Keyless Account can be used to sign transactions.\n   * @return\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  async checkKeylessAccountValidity(aptosConfig: AptosConfig): Promise<void> {\n    const keylessSigners = this.signers.filter(\n      (signer) => signer instanceof AbstractKeylessAccount,\n    ) as AbstractKeylessAccount[];\n    const promises = keylessSigners.map((signer) => signer.checkKeylessAccountValidity(aptosConfig));\n    await Promise.all(promises);\n  }\n\n  /**\n   * Sign the given message using the MultiKeyAccount's signers\n   * @param data - The data to be signed in HexInput format.\n   * @returns MultiKeySignature\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  sign(data: HexInput): MultiKeySignature {\n    const signatures = [];\n    for (const signer of this.signers) {\n      signatures.push(signer.sign(data));\n    }\n    return new MultiKeySignature({ signatures, bitmap: this.signaturesBitmap });\n  }\n\n  /**\n   * Sign the given transaction using the MultiKeyAccount's signers.\n   * This function aggregates signatures from all signers associated with the MultiKeyAccount.\n   *\n   * @param transaction - The transaction to be signed.\n   * @returns MultiKeySignature - An object containing the aggregated signatures and a bitmap of the signatures.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signTransaction(transaction: AnyRawTransaction): MultiKeySignature {\n    const signatures = [];\n    for (const signer of this.signers) {\n      signatures.push(signer.signTransaction(transaction));\n    }\n    return new MultiKeySignature({ signatures, bitmap: this.signaturesBitmap });\n  }\n\n  /**\n   * Verify the given message and signature with the public keys.\n   *\n   * This function checks if the provided signatures are valid for the given message using the corresponding public keys.\n   * Note: If you are using KeylessAccounts, you must use `verifySignatureAsync` instead.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.message - The raw message data in HexInput format.\n   * @param args.signature - The signed message MultiKeySignature containing multiple signatures.\n   * @returns A boolean indicating whether the signatures are valid for the message.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  verifySignature(args: { message: HexInput; signature: MultiKeySignature }): boolean {\n    return this.publicKey.verifySignature(args);\n  }\n\n  /**\n   * Verify the given message and signature with the public keys.\n   *\n   * This function checks if the provided signatures are valid for the given message using the corresponding public keys.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.message - The raw message data in HexInput format.\n   * @param args.signature - The signed message MultiKeySignature containing multiple signatures.\n   * @param args.options.throwErrorWithReason - Whether to throw an error with the reason for the verification failure.\n   * @returns A boolean indicating whether the signatures are valid for the message.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: MultiKeySignature;\n    options?: { throwErrorWithReason?: boolean };\n  }): Promise<boolean> {\n    return await this.publicKey.verifySignatureAsync(args);\n  }\n}\n","import { AptosConfig } from \"../api\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { Ed25519PrivateKey, Signature } from \"../core/crypto\";\nimport { MultiEd25519PublicKey, MultiEd25519Signature } from \"../core/crypto/multiEd25519\";\nimport { AccountAuthenticatorMultiEd25519 } from \"../transactions/authenticator/account\";\nimport { generateSigningMessageForTransaction } from \"../transactions/transactionBuilder/signingMessage\";\nimport { AnyRawTransaction } from \"../transactions/types\";\nimport { HexInput, SigningScheme } from \"../types\";\nimport type { Account } from \"./Account\";\n\nexport interface MultiEd25519SignerConstructorArgs {\n  publicKey: MultiEd25519PublicKey;\n  signers: Ed25519PrivateKey[];\n  address?: AccountAddressInput;\n}\n\nexport interface VerifyMultiEd25519SignatureArgs {\n  message: HexInput;\n  signature: MultiEd25519Signature;\n}\n\n/**\n * Signer implementation for the Multi-Ed25519 authentication scheme.\n *\n * Note: This authentication scheme is a legacy authentication scheme.  Prefer using MultiKeyAccounts as a\n * MultiKeyAccount can support any type of signer, not just Ed25519.  Generating a signer instance does not\n * create the account on-chain.\n */\nexport class MultiEd25519Account implements Account {\n  readonly publicKey: MultiEd25519PublicKey;\n\n  readonly accountAddress: AccountAddress;\n\n  readonly signingScheme = SigningScheme.MultiEd25519;\n\n  /**\n   * The signers used to sign messages.  These signers should correspond to public keys in the\n   * MultiEd25519Account.  The number of signers should be equal to this.publicKey.threshold.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly signers: Ed25519PrivateKey[];\n\n  /**\n   * An array of indices where for signer[i], signerIndicies[i] is the index of the corresponding public key in\n   * publicKey.publicKeys.  Used to derive the right public key to use for verification.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly signerIndices: number[];\n\n  readonly signaturesBitmap: Uint8Array;\n\n  // region Constructors\n\n  constructor(args: MultiEd25519SignerConstructorArgs) {\n    const { signers, publicKey, address } = args;\n    this.publicKey = publicKey;\n    this.accountAddress = address ? AccountAddress.from(address) : this.publicKey.authKey().derivedAddress();\n\n    if (publicKey.threshold > signers.length) {\n      throw new Error(\n        // eslint-disable-next-line max-len\n        `Not enough signers provided to satisfy the required signatures. Need ${publicKey.threshold} signers, but only ${signers.length} provided`,\n      );\n    } else if (publicKey.threshold < signers.length) {\n      throw new Error(\n        // eslint-disable-next-line max-len\n        `More signers provided than required. Need ${publicKey.threshold} signers, but ${signers.length} provided`,\n      );\n    }\n\n    // For each signer, find its corresponding position in the public keys array\n    const bitPositions: number[] = [];\n    for (const signer of signers) {\n      bitPositions.push(this.publicKey.getIndex(signer.publicKey()));\n    }\n\n    // Create pairs of [signer, position] and sort them by position\n    // This sorting is critical because:\n    // 1. The on-chain verification expects signatures to be in ascending order by bit position\n    // 2. The bitmap must match the order of signatures when verifying\n    const signersAndBitPosition: [Ed25519PrivateKey, number][] = signers.map((signer, index) => [\n      signer,\n      bitPositions[index],\n    ]);\n    signersAndBitPosition.sort((a, b) => a[1] - b[1]);\n\n    // Extract the sorted signers and their positions into separate arrays\n    this.signers = signersAndBitPosition.map((value) => value[0]);\n    this.signerIndices = signersAndBitPosition.map((value) => value[1]);\n\n    // Create a bitmap representing which public keys from the MultiEd25519PublicKey are being used\n    // This bitmap is used during signature verification to identify which public keys\n    // should be used to verify each signature\n    this.signaturesBitmap = this.publicKey.createBitmap({ bits: bitPositions });\n  }\n\n  // endregion\n\n  // region Account\n\n  /**\n   * Verify the given message and signature with the public key.\n   *\n   * @param args.message raw message data in HexInput format\n   * @param args.signature signed message Signature\n   * @returns\n   */\n  verifySignature(args: VerifyMultiEd25519SignatureArgs): boolean {\n    return this.publicKey.verifySignature(args);\n  }\n\n  /**\n   * Verify the given message and signature with the public key.\n   *\n   * MultiEd25519 signatures do not depend on chain state, so this function is\n   * equivalent to the synchronous verifySignature method.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.aptosConfig - The configuration object for connecting to the Aptos network\n   * @param args.message - Raw message data in HexInput format.\n   * @param args.signature - Signed message signature.\n   * @returns A boolean indicating whether the signature is valid.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: Signature;\n    options?: { throwErrorWithReason?: boolean };\n  }): Promise<boolean> {\n    return this.publicKey.verifySignatureAsync({\n      ...args,\n      signature: args.signature,\n    });\n  }\n\n  /**\n   * Sign a message using the account's Ed25519 private key.\n   * @param message the signing message, as binary input\n   * @return the AccountAuthenticator containing the signature, together with the account's public key\n   */\n  signWithAuthenticator(message: HexInput): AccountAuthenticatorMultiEd25519 {\n    return new AccountAuthenticatorMultiEd25519(this.publicKey, this.sign(message));\n  }\n\n  /**\n   * Sign a transaction using the account's Ed25519 private keys.\n   * @param transaction the raw transaction\n   * @return the AccountAuthenticator containing the signature of the transaction, together with the account's public key\n   */\n  signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorMultiEd25519 {\n    return new AccountAuthenticatorMultiEd25519(this.publicKey, this.signTransaction(transaction));\n  }\n\n  /**\n   * Sign the given message using the account's Ed25519 private keys.\n   * @param message in HexInput format\n   * @returns MultiEd25519Signature\n   */\n  sign(message: HexInput): MultiEd25519Signature {\n    const signatures = [];\n    for (const signer of this.signers) {\n      signatures.push(signer.sign(message));\n    }\n    return new MultiEd25519Signature({ signatures, bitmap: this.signaturesBitmap });\n  }\n\n  /**\n   * Sign the given transaction using the available signing capabilities.\n   * @param transaction the transaction to be signed\n   * @returns Signature\n   */\n  signTransaction(transaction: AnyRawTransaction): MultiEd25519Signature {\n    return this.sign(generateSigningMessageForTransaction(transaction));\n  }\n\n  // endregion\n}\n","import { SigningScheme } from \"../types\";\nimport { AccountAddress } from \"../core\";\nimport { Deserializer } from \"../bcs/deserializer\";\n\nexport function deserializeSchemeAndAddress(deserializer: Deserializer): {\n  address: AccountAddress;\n  signingScheme: SigningScheme;\n} {\n  const signingScheme = deserializer.deserializeUleb128AsU32();\n  // Validate that signingScheme is a valid SigningScheme value\n  if (!Object.values(SigningScheme).includes(signingScheme)) {\n    throw new Error(`Deserialization of Account failed: SigningScheme variant ${signingScheme} is invalid`);\n  }\n  const address = AccountAddress.deserialize(deserializer);\n  return { address, signingScheme };\n}\n","import { Deserializer, Serializer } from \"../bcs\";\nimport { AnyPublicKeyVariant, HexInput, SigningScheme } from \"../types\";\nimport { MultiKeyAccount } from \"./MultiKeyAccount\";\nimport { Account } from \"./Account\";\nimport { Ed25519Account } from \"./Ed25519Account\";\nimport { isSingleKeySigner, SingleKeyAccount, SingleKeySignerOrLegacyEd25519Account } from \"./SingleKeyAccount\";\nimport { KeylessAccount } from \"./KeylessAccount\";\nimport { FederatedKeylessAccount } from \"./FederatedKeylessAccount\";\nimport { AbstractKeylessAccount } from \"./AbstractKeylessAccount\";\nimport {\n  AccountAddress,\n  Ed25519PrivateKey,\n  getIssAudAndUidVal,\n  Hex,\n  MultiKey,\n  Secp256k1PrivateKey,\n  ZeroKnowledgeSig,\n} from \"../core\";\nimport { deserializeSchemeAndAddress } from \"./utils\";\nimport { EphemeralKeyPair } from \"./EphemeralKeyPair\";\n\nfunction serializeKeylessAccountCommon(account: AbstractKeylessAccount, serializer: Serializer): void {\n  serializer.serializeStr(account.jwt);\n  serializer.serializeStr(account.uidKey);\n  serializer.serializeFixedBytes(account.pepper);\n  account.ephemeralKeyPair.serialize(serializer);\n  if (account.proof === undefined) {\n    throw new Error(\"Cannot serialize - proof undefined\");\n  }\n  account.proof.serialize(serializer);\n  serializer.serializeOption(account.verificationKeyHash, 32);\n}\n\nfunction deserializeKeylessAccountCommon(deserializer: Deserializer): {\n  jwt: string;\n  uidKey: string;\n  pepper: Uint8Array;\n  ephemeralKeyPair: EphemeralKeyPair;\n  proof: ZeroKnowledgeSig;\n  verificationKeyHash?: Uint8Array;\n} {\n  const jwt = deserializer.deserializeStr();\n  const uidKey = deserializer.deserializeStr();\n  const pepper = deserializer.deserializeFixedBytes(31);\n  const ephemeralKeyPair = EphemeralKeyPair.deserialize(deserializer);\n  const proof = ZeroKnowledgeSig.deserialize(deserializer);\n  const verificationKeyHash = deserializer.deserializeOption(\"fixedBytes\", 32);\n  return { jwt, uidKey, pepper, ephemeralKeyPair, proof, verificationKeyHash };\n}\n\n/**\n * Utility functions for working with accounts.\n */\nexport namespace AccountUtils {\n  export function toBytes(account: Account): Uint8Array {\n    const serializer = new Serializer();\n    serializer.serializeU32AsUleb128(account.signingScheme);\n    account.accountAddress.serialize(serializer);\n    switch (account.signingScheme) {\n      case SigningScheme.Ed25519:\n        (account as Ed25519Account).privateKey.serialize(serializer);\n        return serializer.toUint8Array();\n      case SigningScheme.SingleKey: {\n        if (!isSingleKeySigner(account)) {\n          throw new Error(\"Account is not a SingleKeySigner\");\n        }\n        const anyPublicKey = account.getAnyPublicKey();\n        serializer.serializeU32AsUleb128(anyPublicKey.variant);\n        switch (anyPublicKey.variant) {\n          case AnyPublicKeyVariant.Keyless: {\n            const keylessAccount = account as KeylessAccount;\n            serializeKeylessAccountCommon(keylessAccount, serializer);\n            return serializer.toUint8Array();\n          }\n          case AnyPublicKeyVariant.FederatedKeyless: {\n            const federatedKeylessAccount = account as FederatedKeylessAccount;\n            serializeKeylessAccountCommon(federatedKeylessAccount, serializer);\n            federatedKeylessAccount.publicKey.jwkAddress.serialize(serializer);\n            serializer.serializeBool(federatedKeylessAccount.audless);\n            return serializer.toUint8Array();\n          }\n          case AnyPublicKeyVariant.Secp256k1:\n          case AnyPublicKeyVariant.Ed25519: {\n            const singleKeyAccount = account as SingleKeyAccount;\n            singleKeyAccount.privateKey.serialize(serializer);\n            return serializer.toUint8Array();\n          }\n          default: {\n            throw new Error(`Invalid public key variant: ${anyPublicKey.variant}`);\n          }\n        }\n      }\n      case SigningScheme.MultiKey: {\n        const multiKeyAccount = account as MultiKeyAccount;\n        multiKeyAccount.publicKey.serialize(serializer);\n        serializer.serializeU32AsUleb128(multiKeyAccount.signers.length);\n        multiKeyAccount.signers.forEach((signer) => {\n          serializer.serializeFixedBytes(toBytes(signer));\n        });\n        return serializer.toUint8Array();\n      }\n      default:\n        throw new Error(`Deserialization of Account failed: invalid signingScheme value ${account.signingScheme}`);\n    }\n  }\n\n  export function toHexStringWithoutPrefix(account: Account): string {\n    return Hex.hexInputToStringWithoutPrefix(toBytes(account));\n  }\n\n  export function toHexString(account: Account): string {\n    return Hex.hexInputToString(toBytes(account));\n  }\n\n  export function deserialize(deserializer: Deserializer): Account {\n    const { address, signingScheme } = deserializeSchemeAndAddress(deserializer);\n    switch (signingScheme) {\n      case SigningScheme.Ed25519: {\n        const privateKey = Ed25519PrivateKey.deserialize(deserializer);\n        return new Ed25519Account({ privateKey, address });\n      }\n      case SigningScheme.SingleKey: {\n        const variantIndex = deserializer.deserializeUleb128AsU32();\n        switch (variantIndex) {\n          case AnyPublicKeyVariant.Ed25519: {\n            const privateKey = Ed25519PrivateKey.deserialize(deserializer);\n            return new SingleKeyAccount({ privateKey, address });\n          }\n          case AnyPublicKeyVariant.Secp256k1: {\n            const privateKey = Secp256k1PrivateKey.deserialize(deserializer);\n            return new SingleKeyAccount({ privateKey, address });\n          }\n          case AnyPublicKeyVariant.Keyless: {\n            const keylessComponents = deserializeKeylessAccountCommon(deserializer);\n            const jwtClaims = getIssAudAndUidVal(keylessComponents);\n            return new KeylessAccount({ ...keylessComponents, ...jwtClaims });\n          }\n          case AnyPublicKeyVariant.FederatedKeyless: {\n            const keylessComponents = deserializeKeylessAccountCommon(deserializer);\n            const jwkAddress = AccountAddress.deserialize(deserializer);\n            const audless = deserializer.deserializeBool();\n            const jwtClaims = getIssAudAndUidVal(keylessComponents);\n            return new FederatedKeylessAccount({ ...keylessComponents, ...jwtClaims, jwkAddress, audless });\n          }\n          default:\n            throw new Error(`Unsupported public key variant ${variantIndex}`);\n        }\n      }\n      case SigningScheme.MultiKey: {\n        const multiKey = MultiKey.deserialize(deserializer);\n        const length = deserializer.deserializeUleb128AsU32();\n        const signers = new Array<SingleKeySignerOrLegacyEd25519Account>();\n        for (let i = 0; i < length; i += 1) {\n          const signer = deserialize(deserializer);\n          if (!isSingleKeySigner(signer) && !(signer instanceof Ed25519Account)) {\n            throw new Error(\n              \"Deserialization of MultiKeyAccount failed. Signer is not a SingleKeySigner or Ed25519Account\",\n            );\n          }\n          signers.push(signer);\n        }\n        return new MultiKeyAccount({ multiKey, signers, address });\n      }\n      default:\n        throw new Error(`Deserialization of Account failed: invalid signingScheme value ${signingScheme}`);\n    }\n  }\n\n  export function keylessAccountFromHex(hex: HexInput): KeylessAccount {\n    const account = fromHex(hex);\n    if (!(account instanceof KeylessAccount)) {\n      throw new Error(\"Deserialization of KeylessAccount failed\");\n    }\n    return account;\n  }\n\n  export function federatedKeylessAccountFromHex(hex: HexInput): FederatedKeylessAccount {\n    const account = fromHex(hex);\n    if (!(account instanceof FederatedKeylessAccount)) {\n      throw new Error(\"Deserialization of FederatedKeylessAccount failed\");\n    }\n    return account;\n  }\n\n  export function multiKeyAccountFromHex(hex: HexInput): MultiKeyAccount {\n    const account = fromHex(hex);\n    if (!(account instanceof MultiKeyAccount)) {\n      throw new Error(\"Deserialization of MultiKeyAccount failed\");\n    }\n    return account;\n  }\n\n  export function singleKeyAccountFromHex(hex: HexInput): SingleKeyAccount {\n    const account = fromHex(hex);\n    if (!(account instanceof SingleKeyAccount)) {\n      throw new Error(\"Deserialization of SingleKeyAccount failed\");\n    }\n    return account;\n  }\n\n  export function ed25519AccountFromHex(hex: HexInput): Ed25519Account {\n    const account = fromHex(hex);\n    if (!(account instanceof Ed25519Account)) {\n      throw new Error(\"Deserialization of Ed25519Account failed\");\n    }\n    return account;\n  }\n\n  export function fromHex(hex: HexInput): Account {\n    return deserialize(Deserializer.fromHex(hex));\n  }\n\n  export function fromBytes(bytes: Uint8Array): Account {\n    return fromHex(bytes);\n  }\n}\n","import { sha3_256 } from \"@noble/hashes/sha3\";\nimport { AccountAddress } from \"../core\";\nimport { AbstractPublicKey, AbstractSignature } from \"../core/crypto/abstraction\";\nimport { SigningScheme, HexInput } from \"../types\";\nimport { Account } from \"./Account\";\nimport { AnyRawTransaction } from \"../transactions/types\";\nimport { generateSigningMessageForTransaction } from \"../transactions/transactionBuilder/signingMessage\";\nimport { AccountAuthenticatorAbstraction } from \"../transactions/authenticator/account\";\nimport { Ed25519Account } from \"./Ed25519Account\";\nimport { Serializer } from \"../bcs/serializer\";\nimport { isValidFunctionInfo } from \"../utils/helpers\";\n\ntype AbstractedAccountConstructorArgs = {\n  /**\n   * The account address of the account.\n   */\n  accountAddress: AccountAddress;\n  /**\n   * The signer function signs transactions and returns the `authenticator` bytes in the `AbstractionAuthData`.\n   *\n   * @param digest - The SHA256 hash of the transaction signing message\n   * @returns The `authenticator` bytes that can be used to verify the signature.\n   */\n  signer: (digest: HexInput) => Uint8Array;\n  /**\n   * The authentication function that will be used to verify the signature.\n   *\n   * @example\n   * ```ts\n   * const authenticationFunction = `${accountAddress}::permissioned_delegation::authenticate`;\n   * ```\n   */\n  authenticationFunction: string;\n};\n\nexport class AbstractedAccount extends Account {\n  public readonly publicKey: AbstractPublicKey;\n\n  readonly accountAddress: AccountAddress;\n\n  readonly authenticationFunction: string;\n\n  readonly signingScheme = SigningScheme.SingleKey;\n\n  constructor({ signer, accountAddress, authenticationFunction }: AbstractedAccountConstructorArgs) {\n    super();\n\n    if (!isValidFunctionInfo(authenticationFunction)) {\n      throw new Error(`Invalid authentication function ${authenticationFunction} passed into AbstractedAccount`);\n    }\n\n    this.authenticationFunction = authenticationFunction;\n    this.accountAddress = accountAddress;\n    this.publicKey = new AbstractPublicKey(this.accountAddress);\n    this.sign = (digest: HexInput) => new AbstractSignature(signer(digest));\n  }\n\n  /**\n   * Creates an `AbstractedAccount` from an `Ed25519Account` that has a permissioned signer function and\n   * using the `0x1::permissioned_delegation::authenticate` function to verify the signature.\n   *\n   * @param signer - The `Ed25519Account` that can be used to sign permissioned transactions.\n   * @returns The `AbstractedAccount`\n   */\n  public static fromPermissionedSigner({\n    signer,\n    accountAddress,\n  }: {\n    signer: Ed25519Account;\n    accountAddress?: AccountAddress;\n  }) {\n    return new AbstractedAccount({\n      signer: (digest: HexInput) => {\n        const serializer = new Serializer();\n        signer.publicKey.serialize(serializer);\n        signer.sign(digest).serialize(serializer);\n        return serializer.toUint8Array();\n      },\n      accountAddress: accountAddress ?? signer.accountAddress,\n      authenticationFunction: \"0x1::permissioned_delegation::authenticate\",\n    });\n  }\n\n  signWithAuthenticator(message: HexInput): AccountAuthenticatorAbstraction {\n    return new AccountAuthenticatorAbstraction(\n      this.authenticationFunction,\n      sha3_256(message),\n      this.sign(sha3_256(message)).toUint8Array(),\n    );\n  }\n\n  signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorAbstraction {\n    return this.signWithAuthenticator(generateSigningMessageForTransaction(transaction));\n  }\n\n  sign: (message: HexInput) => AbstractSignature;\n\n  signTransaction(transaction: AnyRawTransaction): AbstractSignature {\n    return this.sign(generateSigningMessageForTransaction(transaction));\n  }\n\n  /**\n   * Update the signer function for the account. This can be done after asynchronous operations are complete\n   * to update the context of the signer function.\n   *\n   * @param signer - The new signer function to use for the account.\n   */\n  public setSigner(signer: (digest: HexInput) => HexInput): void {\n    this.sign = (digest: HexInput) => new AbstractSignature(signer(digest));\n  }\n}\n","import { sha3_256 } from \"@noble/hashes/sha3\";\nimport { Serializer } from \"../bcs/serializer\";\nimport { AccountAddress } from \"../core/accountAddress\";\nimport { AccountAuthenticatorAbstraction } from \"../transactions/authenticator/account\";\nimport { HexInput } from \"../types\";\nimport { isValidFunctionInfo } from \"../utils/helpers\";\nimport { AbstractedAccount } from \"./AbstractedAccount\";\n\ntype DerivableAbstractedAccountArgs = {\n  /**\n   * The signer function signs transactions and returns the `authenticator` bytes in the `AbstractionAuthData`.\n   *\n   * @param digest - The SHA256 hash of the transaction signing message\n   * @returns The `authenticator` bytes that can be used to verify the signature.\n   */\n  signer: (digest: HexInput) => Uint8Array;\n\n  /**\n   * The authentication function that will be used to verify the signature.\n   *\n   * @example\n   * ```ts\n   * const authenticationFunction = `${accountAddress}::permissioned_delegation::authenticate`;\n   * ```\n   */\n  authenticationFunction: string;\n\n  /**\n   * The abstract public key that is used to identify the account.\n   * Depends on the use cases, most of the time it is the public key of the source wallet\n   */\n  abstractPublicKey: Uint8Array;\n};\n\nexport class DerivableAbstractedAccount extends AbstractedAccount {\n  /**\n   * The abstract public key that is used to identify the account.\n   * Depends on the use cases, most of the time it is the public key of the source wallet\n   */\n  readonly abstractPublicKey: Uint8Array;\n\n  /**\n   * The domain separator used to calculate the DAA account address.\n   */\n  static readonly ADDRESS_DOMAIN_SEPERATOR: number = 5;\n\n  constructor({ signer, authenticationFunction, abstractPublicKey }: DerivableAbstractedAccountArgs) {\n    const daaAccountAddress = new AccountAddress(\n      DerivableAbstractedAccount.computeAccountAddress(authenticationFunction, abstractPublicKey),\n    );\n    super({\n      accountAddress: daaAccountAddress,\n      signer,\n      authenticationFunction,\n    });\n    this.abstractPublicKey = abstractPublicKey;\n  }\n\n  /**\n   * Compute the account address of the DAA\n   * The DAA account address is computed by hashing the function info and the account identity\n   * and appending the domain separator (5)\n   *\n   * @param functionInfo - The authentication function\n   * @param accountIdentifier - The account identity\n   * @returns The account address\n   */\n  static computeAccountAddress(functionInfo: string, accountIdentifier: Uint8Array): Uint8Array {\n    if (!isValidFunctionInfo(functionInfo)) {\n      throw new Error(`Invalid authentication function ${functionInfo} passed into DerivableAbstractedAccount`);\n    }\n    const [moduleAddress, moduleName, functionName] = functionInfo.split(\"::\");\n\n    const hash = sha3_256.create();\n    // Serialize and append the function info\n    const serializer = new Serializer();\n    AccountAddress.fromString(moduleAddress).serialize(serializer);\n    serializer.serializeStr(moduleName);\n    serializer.serializeStr(functionName);\n    hash.update(serializer.toUint8Array());\n\n    // Serialize and append the account identity\n    const s2 = new Serializer();\n    s2.serializeBytes(accountIdentifier);\n    hash.update(s2.toUint8Array());\n\n    // Append the domain separator\n    hash.update(new Uint8Array([DerivableAbstractedAccount.ADDRESS_DOMAIN_SEPERATOR]));\n\n    return hash.digest();\n  }\n\n  signWithAuthenticator(message: HexInput): AccountAuthenticatorAbstraction {\n    return new AccountAuthenticatorAbstraction(\n      this.authenticationFunction,\n      sha3_256(message),\n      this.sign(sha3_256(message)).value,\n      this.abstractPublicKey,\n    );\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file handles the transaction creation lifecycle.\n * It holds different operations to generate a transaction payload, a raw transaction,\n * and a signed transaction that can be simulated, signed and submitted to chain.\n */\nimport { sha3_256 as sha3Hash } from \"@noble/hashes/sha3\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport { AccountAddress, AccountAddressInput, Hex, PublicKey } from \"../../core\";\nimport {\n  AnyPublicKey,\n  AnySignature,\n  KeylessPublicKey,\n  KeylessSignature,\n  Secp256k1PublicKey,\n  FederatedKeylessPublicKey,\n  MultiKey,\n  MultiKeySignature,\n} from \"../../core/crypto\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"../../core/crypto/ed25519\";\nimport { getInfo } from \"../../internal/utils\";\nimport { getLedgerInfo } from \"../../internal/general\";\nimport { getGasPriceEstimation } from \"../../internal/transaction\";\nimport { NetworkToChainId } from \"../../utils/apiEndpoints\";\nimport { DEFAULT_MAX_GAS_AMOUNT, DEFAULT_TXN_EXP_SEC_FROM_NOW } from \"../../utils/const\";\nimport { normalizeBundle } from \"../../utils/normalizeBundle\";\nimport {\n  AccountAuthenticator,\n  AccountAuthenticatorEd25519,\n  AccountAuthenticatorMultiEd25519,\n  AccountAuthenticatorMultiKey,\n  AccountAuthenticatorNoAccountAuthenticator,\n  AccountAuthenticatorSingleKey,\n} from \"../authenticator/account\";\nimport {\n  TransactionAuthenticator,\n  TransactionAuthenticatorEd25519,\n  TransactionAuthenticatorFeePayer,\n  TransactionAuthenticatorMultiAgent,\n  TransactionAuthenticatorMultiEd25519,\n  TransactionAuthenticatorSingleSender,\n} from \"../authenticator/transaction\";\nimport {\n  ChainId,\n  EntryFunction,\n  FeePayerRawTransaction,\n  MultiAgentRawTransaction,\n  MultiSig,\n  MultiSigTransactionPayload,\n  RawTransaction,\n  Script,\n  TransactionPayloadEntryFunction,\n  TransactionPayloadMultiSig,\n  TransactionPayloadScript,\n} from \"../instances\";\nimport { SignedTransaction } from \"../instances/signedTransaction\";\nimport {\n  AnyRawTransaction,\n  AnyTransactionPayloadInstance,\n  EntryFunctionArgumentTypes,\n  InputGenerateMultiAgentRawTransactionArgs,\n  InputGenerateRawTransactionArgs,\n  InputGenerateSingleSignerRawTransactionArgs,\n  InputGenerateTransactionOptions,\n  InputScriptData,\n  InputSimulateTransactionData,\n  InputMultiSigDataWithRemoteABI,\n  InputEntryFunctionDataWithRemoteABI,\n  InputGenerateTransactionPayloadDataWithRemoteABI,\n  InputSubmitTransactionData,\n  InputGenerateTransactionPayloadDataWithABI,\n  InputEntryFunctionDataWithABI,\n  InputMultiSigDataWithABI,\n  InputViewFunctionDataWithRemoteABI,\n  InputViewFunctionDataWithABI,\n  FunctionABI,\n} from \"../types\";\nimport { convertArgument, fetchEntryFunctionAbi, fetchViewFunctionAbi, standardizeTypeTags } from \"./remoteAbi\";\nimport { memoizeAsync } from \"../../utils/memoize\";\nimport { isScriptDataInput } from \"./helpers\";\nimport { SimpleTransaction } from \"../instances/simpleTransaction\";\nimport { MultiAgentTransaction } from \"../instances/multiAgentTransaction\";\nimport { getFunctionParts } from \"../../utils/helpers\";\n\n/**\n * Builds a transaction payload based on the provided arguments and returns a transaction payload.\n * This function uses the RemoteABI by default, but can also utilize a specified ABI.\n * When we call our `generateTransactionPayload` function with the relevant type properties,\n * Typescript can infer the return type based on the appropriate function overload.\n * @param args - The input data for generating the transaction payload.\n * @param args.function - The function to be called, specified in the format \"moduleAddress::moduleName::functionName\".\n * @param args.functionArguments - The arguments to pass to the function.\n * @param args.typeArguments - The type arguments for the function.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.abi - The ABI to use for the transaction, if not using the RemoteABI.\n *\n * @returns TransactionPayload - The generated transaction payload, which can be of type TransactionPayloadScript,\n * TransactionPayloadMultiSig, or TransactionPayloadEntryFunction.\n * @group Implementation\n * @category Transactions\n */\nexport async function generateTransactionPayload(args: InputScriptData): Promise<TransactionPayloadScript>;\n/**\n * @group Implementation\n * @category Transactions\n */\nexport async function generateTransactionPayload(\n  args: InputEntryFunctionDataWithRemoteABI,\n): Promise<TransactionPayloadEntryFunction>;\n/**\n * @group Implementation\n * @category Transactions\n */\nexport async function generateTransactionPayload(\n  args: InputMultiSigDataWithRemoteABI,\n): Promise<TransactionPayloadMultiSig>;\n\n/**\n * Builds a transaction payload based on the data argument and returns\n * a transaction payload - TransactionPayloadScript | TransactionPayloadMultiSig | TransactionPayloadEntryFunction\n *\n * This uses the RemoteABI by default, and the remote ABI can be skipped by using generateTransactionPayloadWithABI\n *\n * @param args.data GenerateTransactionPayloadData\n *\n * @return TransactionPayload\n * @group Implementation\n * @category Transactions\n */\nexport async function generateTransactionPayload(\n  args: InputGenerateTransactionPayloadDataWithRemoteABI,\n): Promise<AnyTransactionPayloadInstance> {\n  if (isScriptDataInput(args)) {\n    return generateTransactionPayloadScript(args);\n  }\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);\n\n  const functionAbi = await fetchAbi({\n    key: \"entry-function\",\n    moduleAddress,\n    moduleName,\n    functionName,\n    aptosConfig: args.aptosConfig,\n    abi: args.abi,\n    fetch: fetchEntryFunctionAbi,\n  });\n\n  // Fill in the ABI\n  return generateTransactionPayloadWithABI({ ...args, abi: functionAbi });\n}\n\n/**\n * Generates a transaction payload using the provided ABI and function details.\n * This function helps create a properly structured transaction payload for executing a specific function on a module.\n *\n * @param args - The input data required to generate the transaction payload.\n * @param args.abi - The ABI of the function to be executed.\n * @param args.function - The fully qualified name of the function in the format `moduleAddress::moduleName::functionName`.\n * @param args.typeArguments - An array of type arguments that correspond to the function's type parameters.\n * @param args.functionArguments - An array of arguments to be passed to the function.\n * @param args.multisigAddress - (Optional) The address for a multisig transaction if applicable.\n *\n * @throws Error if the type argument count does not match the ABI or if the number of function arguments is incorrect.\n * @group Implementation\n * @category Transactions\n */\nexport function generateTransactionPayloadWithABI(args: InputEntryFunctionDataWithABI): TransactionPayloadEntryFunction;\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function generateTransactionPayloadWithABI(args: InputMultiSigDataWithABI): TransactionPayloadMultiSig;\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function generateTransactionPayloadWithABI(\n  args: InputGenerateTransactionPayloadDataWithABI,\n): AnyTransactionPayloadInstance {\n  const functionAbi = args.abi;\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);\n\n  // Ensure that all type arguments are typed properly\n  const typeArguments = standardizeTypeTags(args.typeArguments);\n\n  // Check the type argument count against the ABI\n  if (typeArguments.length !== functionAbi.typeParameters.length) {\n    throw new Error(\n      `Type argument count mismatch, expected ${functionAbi.typeParameters.length}, received ${typeArguments.length}`,\n    );\n  }\n\n  // Check all BCS types, and convert any non-BCS types\n  const functionArguments: Array<EntryFunctionArgumentTypes> = args.functionArguments.map((arg, i) =>\n    /**\n     * Converts the argument for a specified function using its ABI and type arguments.\n     * This function helps ensure that the correct number of arguments is provided for the function call.\n     *\n     * @param args - The arguments for the function call.\n     * @param args.function - The specific function to be invoked.\n     * @param functionAbi - The ABI (Application Binary Interface) of the function, which includes parameter details.\n     * @param arg - The argument to be converted.\n     * @param i - The index of the argument in the function call.\n     * @param typeArguments - Additional type arguments that may be required for the conversion.\n     * @group Implementation\n     * @category Transactions\n     */\n    // TODO: Fix JSDoc\n    convertArgument(args.function, functionAbi, arg, i, typeArguments),\n  );\n\n  // Check that all arguments are accounted for\n  if (functionArguments.length !== functionAbi.parameters.length) {\n    throw new Error(\n      // eslint-disable-next-line max-len\n      `Too few arguments for '${moduleAddress}::${moduleName}::${functionName}', expected ${functionAbi.parameters.length} but got ${functionArguments.length}`,\n    );\n  }\n\n  // Generate entry function payload\n  const entryFunctionPayload = EntryFunction.build(\n    `${moduleAddress}::${moduleName}`,\n    functionName,\n    typeArguments,\n    functionArguments,\n  );\n\n  // Send it as multi sig if it's a multisig payload\n  if (\"multisigAddress\" in args) {\n    const multisigAddress = AccountAddress.from(args.multisigAddress);\n    return new TransactionPayloadMultiSig(\n      new MultiSig(multisigAddress, new MultiSigTransactionPayload(entryFunctionPayload)),\n    );\n  }\n\n  // Otherwise send as an entry function\n  return new TransactionPayloadEntryFunction(entryFunctionPayload);\n}\n\n/**\n * Generates the payload for a view function call using the provided arguments.\n * This function helps in preparing the necessary data to interact with a specific view function on the blockchain.\n *\n * @param args - The input data required to generate the view function payload.\n * @param args.function - The function identifier in the format \"moduleAddress::moduleName::functionName\".\n * @param args.aptosConfig - Configuration settings for the Aptos client.\n * @param args.abi - The ABI (Application Binary Interface) of the module.\n *\n * @returns The generated payload for the view function call.\n * @group Implementation\n * @category Transactions\n */\nexport async function generateViewFunctionPayload(args: InputViewFunctionDataWithRemoteABI): Promise<EntryFunction> {\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);\n\n  const functionAbi = await fetchAbi({\n    key: \"view-function\",\n    moduleAddress,\n    moduleName,\n    functionName,\n    aptosConfig: args.aptosConfig,\n    abi: args.abi,\n    fetch: fetchViewFunctionAbi,\n  });\n\n  // Fill in the ABI\n  return generateViewFunctionPayloadWithABI({ abi: functionAbi, ...args });\n}\n\n/**\n * Generates a payload for a view function call using the provided ABI and arguments.\n * This function ensures that the type arguments and function arguments are correctly formatted\n * and match the expected counts as defined in the ABI.\n *\n * @param args - The input data for generating the view function payload.\n * @param args.abi - The ABI of the function to be called.\n * @param args.function - The full name of the function in the format \"moduleAddress::moduleName::functionName\".\n * @param args.typeArguments - An array of type arguments to be used in the function call.\n * @param args.functionArguments - An array of arguments to be passed to the function.\n *\n * @throws Error if the type argument count does not match the ABI or if the function arguments\n * do not match the expected parameters defined in the ABI.\n * @group Implementation\n * @category Transactions\n */\nexport function generateViewFunctionPayloadWithABI(args: InputViewFunctionDataWithABI): EntryFunction {\n  const functionAbi = args.abi;\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);\n\n  // Ensure that all type arguments are typed properly\n  const typeArguments = standardizeTypeTags(args.typeArguments);\n\n  // Check the type argument count against the ABI\n  if (typeArguments.length !== functionAbi.typeParameters.length) {\n    throw new Error(\n      `Type argument count mismatch, expected ${functionAbi.typeParameters.length}, received ${typeArguments.length}`,\n    );\n  }\n\n  // Check all BCS types, and convert any non-BCS types\n  const functionArguments: Array<EntryFunctionArgumentTypes> =\n    args?.functionArguments?.map((arg, i) => convertArgument(args.function, functionAbi, arg, i, typeArguments)) ?? [];\n\n  // Check that all arguments are accounted for\n  if (functionArguments.length !== functionAbi.parameters.length) {\n    throw new Error(\n      // eslint-disable-next-line max-len\n      `Too few arguments for '${moduleAddress}::${moduleName}::${functionName}', expected ${functionAbi.parameters.length} but got ${functionArguments.length}`,\n    );\n  }\n\n  // Generate entry function payload\n  return EntryFunction.build(`${moduleAddress}::${moduleName}`, functionName, typeArguments, functionArguments);\n}\n\n/**\n * Generates a transaction payload script based on the provided input data.\n * This function helps in creating a structured script for transaction processing.\n *\n * @param args - The input data required to generate the transaction payload script.\n * @param args.bytecode - The bytecode to be converted into a Uint8Array.\n * @param args.typeArguments - The type arguments that will be standardized.\n * @param args.functionArguments - The arguments for the function being called.\n * @returns A new instance of TransactionPayloadScript.\n * @group Implementation\n * @category Transactions\n */\nfunction generateTransactionPayloadScript(args: InputScriptData) {\n  return new TransactionPayloadScript(\n    new Script(\n      Hex.fromHexInput(args.bytecode).toUint8Array(),\n      standardizeTypeTags(args.typeArguments),\n      args.functionArguments,\n    ),\n  );\n}\n\n/**\n * Generates a raw transaction that can be sent to the Aptos network.\n *\n * @param args - The arguments for generating the raw transaction.\n * @param args.aptosConfig - The configuration for the Aptos network.\n * @param args.sender - The transaction's sender account address as a hex input.\n * @param args.payload - The transaction payload, which can be created using generateTransactionPayload().\n * @param args.options - Optional parameters for transaction generation.\n * @param args.feePayerAddress - The address of the fee payer for sponsored transactions.\n *\n * @returns RawTransaction - The generated raw transaction.\n * @group Implementation\n * @category Transactions\n */\nexport async function generateRawTransaction(args: {\n  aptosConfig: AptosConfig;\n  sender: AccountAddressInput;\n  payload: AnyTransactionPayloadInstance;\n  options?: InputGenerateTransactionOptions;\n  feePayerAddress?: AccountAddressInput;\n}): Promise<RawTransaction> {\n  const { aptosConfig, sender, payload, options, feePayerAddress } = args;\n\n  const getChainId = async () => {\n    if (NetworkToChainId[aptosConfig.network]) {\n      return { chainId: NetworkToChainId[aptosConfig.network] };\n    }\n    const info = await getLedgerInfo({ aptosConfig });\n    return { chainId: info.chain_id };\n  };\n\n  const getGasUnitPrice = async () => {\n    if (options?.gasUnitPrice) {\n      return { gasEstimate: options.gasUnitPrice };\n    }\n    const estimation = await getGasPriceEstimation({ aptosConfig });\n    return { gasEstimate: estimation.gas_estimate };\n  };\n\n  const getSequenceNumberForAny = async () => {\n    const getSequenceNumber = async () => {\n      if (options?.accountSequenceNumber !== undefined) {\n        return options.accountSequenceNumber;\n      }\n\n      return (await getInfo({ aptosConfig, accountAddress: sender })).sequence_number;\n    };\n\n    /**\n     * Check if is sponsored transaction to honor AIP-52\n     * {@link https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-52.md}\n     * @group Implementation\n     * @category Transactions\n     */\n    if (feePayerAddress && AccountAddress.from(feePayerAddress).equals(AccountAddress.ZERO)) {\n      // Handle sponsored transaction generation with the option that\n      // the main signer has not been created on chain\n      try {\n        // Check if main signer has been created on chain, if not assign sequence number 0\n        return await getSequenceNumber();\n      } catch (e: any) {\n        return 0;\n      }\n    } else {\n      return getSequenceNumber();\n    }\n  };\n  const [{ chainId }, { gasEstimate }, sequenceNumber] = await Promise.all([\n    getChainId(),\n    getGasUnitPrice(),\n    getSequenceNumberForAny(),\n  ]);\n\n  const { maxGasAmount, gasUnitPrice, expireTimestamp } = {\n    maxGasAmount: options?.maxGasAmount ? BigInt(options.maxGasAmount) : BigInt(DEFAULT_MAX_GAS_AMOUNT),\n    gasUnitPrice: options?.gasUnitPrice ?? BigInt(gasEstimate),\n    expireTimestamp: options?.expireTimestamp ?? BigInt(Math.floor(Date.now() / 1000) + DEFAULT_TXN_EXP_SEC_FROM_NOW),\n  };\n\n  return new RawTransaction(\n    AccountAddress.from(sender),\n    BigInt(sequenceNumber),\n    payload,\n    BigInt(maxGasAmount),\n    BigInt(gasUnitPrice),\n    BigInt(expireTimestamp),\n    new ChainId(chainId),\n  );\n}\n\n/**\n * Generates a transaction based on the provided arguments.\n * This function can create both simple and multi-agent transactions, allowing for flexible transaction handling.\n *\n * @param args - The input arguments for generating the transaction.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.sender - The transaction's sender account address as a hex input.\n * @param args.payload - The transaction payload, which can be created using `generateTransactionPayload()`.\n * @param args.options - Optional. Transaction options object.\n * @param args.secondarySignerAddresses - Optional. An array of addresses for additional signers in a multi-signature transaction.\n * @param args.feePayerAddress - Optional. The address of the fee payer for sponsored transactions.\n * @returns An instance of a transaction, which may include secondary signer addresses and a fee payer address.\n * @group Implementation\n * @category Transactions\n */\nexport async function buildTransaction(args: InputGenerateSingleSignerRawTransactionArgs): Promise<SimpleTransaction>;\n/**\n * @group Implementation\n * @category Transactions\n */\nexport async function buildTransaction(args: InputGenerateMultiAgentRawTransactionArgs): Promise<MultiAgentTransaction>;\n\n/**\n * Generates a transaction based on the provided arguments\n *\n * Note: we can start with one function to support all different payload/transaction types,\n * and if to complex to use, we could have function for each type\n *\n * @param args.aptosConfig AptosConfig\n * @param args.sender The transaction's sender account address as a hex input\n * @param args.payload The transaction payload - can create by using generateTransactionPayload()\n * @param args.options optional. Transaction options object\n * @param args.secondarySignerAddresses optional. For when want to create a multi signers transaction\n * @param args.feePayerAddress optional. For when want to create a fee payer (aka sponsored) transaction\n *\n * @return An instance of a RawTransaction, plus optional secondary/fee payer addresses\n * ```\n * {\n *  rawTransaction: RawTransaction,\n *  secondarySignerAddresses?: Array<AccountAddress>,\n *  feePayerAddress?: AccountAddress\n * }\n * ```\n * @group Implementation\n * @category Transactions\n */\nexport async function buildTransaction(args: InputGenerateRawTransactionArgs): Promise<AnyRawTransaction> {\n  const { aptosConfig, sender, payload, options, feePayerAddress } = args;\n  // generate raw transaction\n  const rawTxn = await generateRawTransaction({\n    aptosConfig,\n    sender,\n    payload,\n    options,\n    feePayerAddress,\n  });\n\n  // if multi agent transaction\n  if (\"secondarySignerAddresses\" in args) {\n    const signers: Array<AccountAddress> =\n      args.secondarySignerAddresses?.map((signer) => AccountAddress.from(signer)) ?? [];\n\n    return new MultiAgentTransaction(\n      rawTxn,\n      signers,\n      args.feePayerAddress ? AccountAddress.from(args.feePayerAddress) : undefined,\n    );\n  }\n  // return the raw transaction\n  return new SimpleTransaction(rawTxn, args.feePayerAddress ? AccountAddress.from(args.feePayerAddress) : undefined);\n}\n\n/**\n * Generate a signed transaction for simulation before submitting it to the chain.\n * This function helps in preparing a transaction that can be simulated, allowing users to verify its validity and expected behavior.\n *\n * @param args - The input data required to generate the signed transaction for simulation.\n * @param args.transaction - An Aptos transaction type to sign.\n * @param args.signerPublicKey - The public key of the signer.\n * @param args.secondarySignersPublicKeys - Optional. The public keys of secondary signers if it is a multi-signer transaction.\n * @param args.feePayerPublicKey - Optional. The public key of the fee payer in a sponsored transaction.\n * @param args.options - Optional. Additional options for simulating the transaction.\n *\n * @returns A signed serialized transaction that can be simulated.\n * @group Implementation\n * @category Transactions\n */\nexport function generateSignedTransactionForSimulation(args: InputSimulateTransactionData): Uint8Array {\n  const { signerPublicKey, transaction, secondarySignersPublicKeys, feePayerPublicKey } = args;\n\n  const accountAuthenticator = getAuthenticatorForSimulation(signerPublicKey);\n\n  // fee payer transaction\n  if (transaction.feePayerAddress) {\n    const transactionToSign = new FeePayerRawTransaction(\n      transaction.rawTransaction,\n      transaction.secondarySignerAddresses ?? [],\n      transaction.feePayerAddress,\n    );\n    let secondaryAccountAuthenticators: Array<AccountAuthenticator> = [];\n    if (transaction.secondarySignerAddresses) {\n      if (secondarySignersPublicKeys) {\n        secondaryAccountAuthenticators = secondarySignersPublicKeys.map((publicKey) =>\n          getAuthenticatorForSimulation(publicKey),\n        );\n      } else {\n        secondaryAccountAuthenticators = Array.from({ length: transaction.secondarySignerAddresses.length }, () =>\n          getAuthenticatorForSimulation(undefined),\n        );\n      }\n    }\n    const feePayerAuthenticator = getAuthenticatorForSimulation(feePayerPublicKey);\n\n    const transactionAuthenticator = new TransactionAuthenticatorFeePayer(\n      accountAuthenticator,\n      transaction.secondarySignerAddresses ?? [],\n      secondaryAccountAuthenticators,\n      {\n        address: transaction.feePayerAddress,\n        authenticator: feePayerAuthenticator,\n      },\n    );\n    return new SignedTransaction(transactionToSign.raw_txn, transactionAuthenticator).bcsToBytes();\n  }\n\n  // multi agent transaction\n  if (transaction.secondarySignerAddresses) {\n    const transactionToSign = new MultiAgentRawTransaction(\n      transaction.rawTransaction,\n      transaction.secondarySignerAddresses,\n    );\n\n    let secondaryAccountAuthenticators: Array<AccountAuthenticator> = [];\n\n    if (secondarySignersPublicKeys) {\n      secondaryAccountAuthenticators = secondarySignersPublicKeys.map((publicKey) =>\n        getAuthenticatorForSimulation(publicKey),\n      );\n    } else {\n      secondaryAccountAuthenticators = Array.from({ length: transaction.secondarySignerAddresses.length }, () =>\n        getAuthenticatorForSimulation(undefined),\n      );\n    }\n\n    const transactionAuthenticator = new TransactionAuthenticatorMultiAgent(\n      accountAuthenticator,\n      transaction.secondarySignerAddresses,\n      secondaryAccountAuthenticators,\n    );\n\n    return new SignedTransaction(transactionToSign.raw_txn, transactionAuthenticator).bcsToBytes();\n  }\n\n  // single signer raw transaction\n  let transactionAuthenticator;\n  if (accountAuthenticator instanceof AccountAuthenticatorEd25519) {\n    transactionAuthenticator = new TransactionAuthenticatorEd25519(\n      accountAuthenticator.public_key,\n      accountAuthenticator.signature,\n    );\n  } else if (\n    accountAuthenticator instanceof AccountAuthenticatorSingleKey ||\n    accountAuthenticator instanceof AccountAuthenticatorMultiKey\n  ) {\n    transactionAuthenticator = new TransactionAuthenticatorSingleSender(accountAuthenticator);\n  } else if (accountAuthenticator instanceof AccountAuthenticatorNoAccountAuthenticator) {\n    transactionAuthenticator = new TransactionAuthenticatorSingleSender(accountAuthenticator);\n  } else {\n    throw new Error(\"Invalid public key\");\n  }\n  return new SignedTransaction(transaction.rawTransaction, transactionAuthenticator).bcsToBytes();\n}\n\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function getAuthenticatorForSimulation(publicKey?: PublicKey) {\n  if (!publicKey) {\n    return new AccountAuthenticatorNoAccountAuthenticator();\n  }\n\n  // Wrap the public key types below with AnyPublicKey as they are only support through single sender.\n  // Learn more about AnyPublicKey here - https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-55.md\n  const convertToAnyPublicKey =\n    KeylessPublicKey.isInstance(publicKey) ||\n    FederatedKeylessPublicKey.isInstance(publicKey) ||\n    Secp256k1PublicKey.isInstance(publicKey);\n  const accountPublicKey = convertToAnyPublicKey ? new AnyPublicKey(publicKey) : publicKey;\n\n  // No need to for the signature to be matching in scheme. All that matters for simulations is that it's not valid\n  const invalidSignature = new Ed25519Signature(new Uint8Array(64));\n\n  if (Ed25519PublicKey.isInstance(accountPublicKey)) {\n    return new AccountAuthenticatorEd25519(accountPublicKey, invalidSignature);\n  }\n\n  if (AnyPublicKey.isInstance(accountPublicKey)) {\n    if (KeylessPublicKey.isInstance(accountPublicKey.publicKey)) {\n      return new AccountAuthenticatorSingleKey(\n        accountPublicKey,\n        new AnySignature(KeylessSignature.getSimulationSignature()),\n      );\n    }\n    return new AccountAuthenticatorSingleKey(accountPublicKey, new AnySignature(invalidSignature));\n  }\n\n  if (MultiKey.isInstance(accountPublicKey)) {\n    return new AccountAuthenticatorMultiKey(\n      accountPublicKey,\n      new MultiKeySignature({\n        signatures: accountPublicKey.publicKeys.map((pubKey) => {\n          if (KeylessPublicKey.isInstance(pubKey.publicKey) || FederatedKeylessPublicKey.isInstance(pubKey.publicKey)) {\n            return new AnySignature(KeylessSignature.getSimulationSignature());\n          }\n          return new AnySignature(invalidSignature);\n        }),\n        bitmap: accountPublicKey.createBitmap({\n          bits: Array(accountPublicKey.publicKeys.length)\n            .fill(0)\n            .map((_, i) => i),\n        }),\n      }),\n    );\n  }\n\n  throw new Error(\"Unsupported PublicKey used for simulations\");\n}\n\n/**\n * Generate a signed transaction ready for submission to the blockchain.\n * This function prepares the transaction by authenticating the sender and any additional signers based on the provided arguments.\n *\n * @param args - The input data required to generate the signed transaction.\n * @param args.transaction - An Aptos transaction type containing the details of the transaction.\n * @param args.senderAuthenticator - The account authenticator of the transaction sender.\n * @param args.feePayerAuthenticator - The authenticator for the fee payer, required if the transaction has a fee payer address.\n * @param args.additionalSignersAuthenticators - Optional authenticators for additional signers in a multi-signer transaction.\n *\n * @returns A Uint8Array representing the signed transaction in bytes.\n *\n * @throws Error if the feePayerAuthenticator is not provided for a fee payer transaction.\n * @throws Error if additionalSignersAuthenticators are not provided for a multi-signer transaction.\n * @group Implementation\n * @category Transactions\n */\nexport function generateSignedTransaction(args: InputSubmitTransactionData): Uint8Array {\n  const { transaction, feePayerAuthenticator, additionalSignersAuthenticators } = args;\n  const senderAuthenticator = normalizeBundle(AccountAuthenticator, args.senderAuthenticator);\n\n  let txnAuthenticator: TransactionAuthenticator;\n  if (transaction.feePayerAddress) {\n    if (!feePayerAuthenticator) {\n      throw new Error(\"Must provide a feePayerAuthenticator argument to generate a signed fee payer transaction\");\n    }\n    txnAuthenticator = new TransactionAuthenticatorFeePayer(\n      senderAuthenticator,\n      transaction.secondarySignerAddresses ?? [],\n      additionalSignersAuthenticators ?? [],\n      {\n        address: transaction.feePayerAddress,\n        authenticator: feePayerAuthenticator,\n      },\n    );\n  } else if (transaction.secondarySignerAddresses) {\n    if (!additionalSignersAuthenticators) {\n      throw new Error(\n        \"Must provide a additionalSignersAuthenticators argument to generate a signed multi agent transaction\",\n      );\n    }\n    txnAuthenticator = new TransactionAuthenticatorMultiAgent(\n      senderAuthenticator,\n      transaction.secondarySignerAddresses,\n      additionalSignersAuthenticators,\n    );\n  } else if (senderAuthenticator instanceof AccountAuthenticatorEd25519) {\n    txnAuthenticator = new TransactionAuthenticatorEd25519(\n      senderAuthenticator.public_key,\n      senderAuthenticator.signature,\n    );\n  } else if (senderAuthenticator instanceof AccountAuthenticatorMultiEd25519) {\n    txnAuthenticator = new TransactionAuthenticatorMultiEd25519(\n      senderAuthenticator.public_key,\n      senderAuthenticator.signature,\n    );\n  } else {\n    txnAuthenticator = new TransactionAuthenticatorSingleSender(senderAuthenticator);\n  }\n\n  return new SignedTransaction(transaction.rawTransaction, txnAuthenticator).bcsToBytes();\n}\n\n/**\n * Hashes the set of values using a SHA-3 256 hash algorithm.\n * @param input - An array of UTF-8 strings or Uint8Array byte arrays to be hashed.\n * @group Implementation\n * @category Transactions\n */\nexport function hashValues(input: (Uint8Array | string)[]): Uint8Array {\n  const hash = sha3Hash.create();\n  for (const item of input) {\n    hash.update(item);\n  }\n  return hash.digest();\n}\n\n/**\n * The domain separated prefix for hashing transactions\n * @group Implementation\n * @category Transactions\n */\nconst TRANSACTION_PREFIX = hashValues([\"APTOS::Transaction\"]);\n\n/**\n * Generates a user transaction hash for the provided transaction payload, which must already have an authenticator.\n * This function helps ensure the integrity and uniqueness of the transaction by producing a hash based on the signed transaction data.\n *\n * @param args - The input data required to submit the transaction.\n * @param args.authenticator - The authenticator for the transaction.\n * @param args.payload - The payload containing the transaction details.\n * @param args.sender - The address of the sender initiating the transaction.\n * @param args.sequenceNumber - The sequence number of the transaction for the sender.\n * @group Implementation\n * @category Transactions\n */\nexport function generateUserTransactionHash(args: InputSubmitTransactionData): string {\n  const signedTransaction = generateSignedTransaction(args);\n\n  // Transaction signature is defined as, the domain separated prefix based on struct (Transaction)\n  // Then followed by the type of the transaction for the enum, UserTransaction is 0\n  // Then followed by BCS encoded bytes of the signed transaction\n  return new Hex(hashValues([TRANSACTION_PREFIX, new Uint8Array([0]), signedTransaction])).toString();\n}\n\n/**\n * Fetches and caches ABIs while allowing for pass-through on provided ABIs.\n *\n * @param key - A unique identifier for the cached ABI.\n * @param moduleAddress - The address of the module from which to fetch the ABI.\n * @param moduleName - The name of the module containing the function.\n * @param functionName - The name of the function whose ABI is being fetched.\n * @param aptosConfig - Configuration settings for Aptos.\n * @param abi - An optional ABI to use if already available.\n * @param fetch - A function to fetch the ABI if it is not provided.\n * @group Implementation\n * @category Transactions\n */\nasync function fetchAbi<T extends FunctionABI>({\n  key,\n  moduleAddress,\n  moduleName,\n  functionName,\n  aptosConfig,\n  abi,\n  fetch,\n}: {\n  key: string;\n  moduleAddress: string;\n  moduleName: string;\n  functionName: string;\n  aptosConfig: AptosConfig;\n  abi?: T;\n  fetch: (moduleAddress: string, moduleName: string, functionName: string, aptosConfig: AptosConfig) => Promise<T>;\n}): Promise<T> {\n  if (abi !== undefined) {\n    return abi;\n  }\n\n  // We fetch the entry function ABI, and then pretend that we already had the ABI\n  return memoizeAsync(\n    async () => fetch(moduleAddress, moduleName, functionName, aptosConfig),\n    `${key}-${aptosConfig.network}-${moduleAddress}-${moduleName}-${functionName}`,\n    1000 * 60 * 5, // 5 minutes\n  )();\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  StructTag,\n  TypeTag,\n  TypeTagAddress,\n  TypeTagBool,\n  TypeTagGeneric,\n  TypeTagReference,\n  TypeTagSigner,\n  TypeTagStruct,\n  TypeTagU128,\n  TypeTagU16,\n  TypeTagU256,\n  TypeTagU32,\n  TypeTagU64,\n  TypeTagU8,\n  TypeTagVector,\n} from \".\";\nimport { AccountAddress } from \"../../core\";\nimport { Identifier } from \"../instances/identifier\";\n\n/**\n * Determines if the provided string is a valid Move identifier, which can only contain alphanumeric characters and underscores.\n * @param str - The string to validate as a Move identifier.\n * @group Implementation\n * @category Transactions\n */\nfunction isValidIdentifier(str: string) {\n  return !!str.match(/^[_a-zA-Z0-9]+$/);\n}\n\n/**\n * Determines if the provided character is a whitespace character. This function only works for single characters.\n * @param char - The character to check for whitespace.\n * @group Implementation\n * @category Transactions\n */\nfunction isValidWhitespaceCharacter(char: string) {\n  return !!char.match(/\\s/);\n}\n\n/**\n * Determines if a given string represents a generic type from the ABI, specifically in the format T0, T1, etc.\n * @param str - The string to evaluate for generic type format.\n * @group Implementation\n * @category Transactions\n */\nfunction isGeneric(str: string) {\n  return !!str.match(/^T[0-9]+$/);\n}\n\n/**\n * Determines if the provided string is a reference type, which is indicated by starting with an ampersand (&).\n * @param str - The string to evaluate for reference type.\n * @group Implementation\n * @category Transactions\n */\nfunction isRef(str: string) {\n  return !!str.match(/^&.+$/);\n}\n\n/**\n * Determines if the provided string represents a primitive type.\n * @param str - The string to evaluate as a potential primitive type.\n * @returns A boolean indicating whether the string is a primitive type.\n * @group Implementation\n * @category Transactions\n */\nfunction isPrimitive(str: string) {\n  switch (str) {\n    case \"signer\":\n    case \"address\":\n    case \"bool\":\n    case \"u8\":\n    case \"u16\":\n    case \"u32\":\n    case \"u64\":\n    case \"u128\":\n    case \"u256\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Consumes all whitespace characters in a string starting from a specified position.\n *\n * @param tagStr - The string from which to consume whitespace.\n * @param pos - The position in the string to start consuming whitespace from.\n * @returns The new position in the string after consuming whitespace.\n * @group Implementation\n * @category Transactions\n */\nfunction consumeWhitespace(tagStr: string, pos: number) {\n  let i = pos;\n  for (; i < tagStr.length; i += 1) {\n    const innerChar = tagStr[i];\n\n    if (!isValidWhitespaceCharacter(innerChar)) {\n      // If it's not colons, and it's an invalid character, we will stop here\n      break;\n    }\n  }\n  return i;\n}\n\n/**\n * State for TypeTag parsing, maintained on a stack to track the current parsing state.\n * @group Implementation\n * @category Transactions\n */\ntype TypeTagState = {\n  savedExpectedTypes: number;\n  savedStr: string;\n  savedTypes: Array<TypeTag>;\n};\n\n/**\n * Error types related to parsing type tags, indicating various issues encountered during the parsing process.\n * @group Implementation\n * @category Transactions\n */\nexport enum TypeTagParserErrorType {\n  InvalidTypeTag = \"unknown type\",\n  UnexpectedGenericType = \"unexpected generic type\",\n  UnexpectedTypeArgumentClose = \"unexpected '>'\",\n  UnexpectedWhitespaceCharacter = \"unexpected whitespace character\",\n  UnexpectedComma = \"unexpected ','\",\n  TypeArgumentCountMismatch = \"type argument count doesn't match expected amount\",\n  MissingTypeArgumentClose = \"no matching '>' for '<'\",\n  MissingTypeArgument = \"no type argument before ','\",\n  UnexpectedPrimitiveTypeArguments = \"primitive types not expected to have type arguments\",\n  UnexpectedVectorTypeArgumentCount = \"vector type expected to have exactly one type argument\",\n  UnexpectedStructFormat = \"unexpected struct format, must be of the form 0xaddress::module_name::struct_name\",\n  InvalidModuleNameCharacter = \"module name must only contain alphanumeric or '_' characters\",\n  InvalidStructNameCharacter = \"struct name must only contain alphanumeric or '_' characters\",\n  InvalidAddress = \"struct address must be valid\",\n}\n\n/**\n * Represents an error that occurs during the parsing of a type tag.\n * This error extends the built-in Error class and provides additional context\n * regarding the specific type tag that failed to parse and the reason for the failure.\n *\n * @param typeTagStr - The type tag string that failed to be parsed.\n * @param invalidReason - The reason why the type tag string is considered invalid.\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagParserError extends Error {\n  /**\n   * Constructs an error indicating a failure to parse a type tag.\n   * This error provides details about the specific type tag that could not be parsed and the reason for the failure.\n   *\n   * @param typeTagStr - The string representation of the type tag that failed to parse.\n   * @param invalidReason - The reason why the type tag is considered invalid.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(typeTagStr: string, invalidReason: TypeTagParserErrorType) {\n    super(`Failed to parse typeTag '${typeTagStr}', ${invalidReason}`);\n  }\n}\n\n/**\n * Parses a type string into a structured representation of type tags, accommodating various formats including generics and\n * nested types.\n *\n * This function can help you accurately interpret type strings, which can include simple types, standalone structs, and complex\n * nested generics.\n * It supports multiple generics, spacing within generics, and nested generics of varying depths.\n * All types are made of a few parts they're either:\n * 1. A simple type e.g. u8\n * 2. A standalone struct e.g. 0x1::account::Account\n * 3. A nested struct e.g. 0x1::coin::Coin<0x1234::coin::MyCoin>\n *\n * There are a few more special cases that need to be handled, however.\n * 1. Multiple generics e.g. 0x1::pair::Pair<u8, u16>\n * 2. Spacing in the generics e.g. 0x1::pair::Pair< u8 , u16>\n * 3. Nested generics of different depths e.g. 0x1::pair::Pair<0x1::coin::Coin<0x1234::coin::MyCoin>, u8>\n * 4. Generics for types in ABIs are filled in with placeholders e.g. T1, T2, T3\n * @param typeStr - The string representation of the type to be parsed.\n * @param options - Optional settings for parsing behavior.\n * @param options.allowGenerics - A flag indicating whether to allow generics in the parsing process.\n * @returns The parsed type tag representation.\n * @throws TypeTagParserError if the type string is malformed or does not conform to expected formats.\n * @group Implementation\n * @category Transactions\n */\nexport function parseTypeTag(typeStr: string, options?: { allowGenerics?: boolean }) {\n  const allowGenerics = options?.allowGenerics ?? false;\n\n  const saved: Array<TypeTagState> = [];\n  // This represents the internal types for a type tag e.g. '0x1::coin::Coin<innerTypes>'\n  let innerTypes: Array<TypeTag> = [];\n  // This represents the current parsed types in a comma list e.g. 'u8, u8'\n  let curTypes: Array<TypeTag> = [];\n  // This represents the current character index\n  let cur: number = 0;\n  // This represents the current working string as a type or struct name\n  let currentStr: string = \"\";\n  let expectedTypes: number = 1;\n\n  // Iterate through each character, and handle the border conditions\n  while (cur < typeStr.length) {\n    const char = typeStr[cur];\n\n    if (char === \"<\") {\n      // Start of a type argument, push current state onto a stack\n      saved.push({\n        savedExpectedTypes: expectedTypes,\n        savedStr: currentStr,\n        savedTypes: curTypes,\n      });\n\n      // Clear current state\n      currentStr = \"\";\n      curTypes = [];\n      expectedTypes = 1;\n    } else if (char === \">\") {\n      // Process last type, if there is no type string, then don't parse it\n      if (currentStr !== \"\") {\n        const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n        curTypes.push(newType);\n      }\n\n      // Pop off stack outer type, if there's nothing left, there were too many '>'\n      const savedPop = saved.pop();\n      if (savedPop === undefined) {\n        throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedTypeArgumentClose);\n      }\n\n      // If the expected types don't match the number of commas, then we also fail\n      if (expectedTypes !== curTypes.length) {\n        throw new TypeTagParserError(typeStr, TypeTagParserErrorType.TypeArgumentCountMismatch);\n      }\n\n      // Add in the new created type, shifting the current types to the inner types\n      const { savedStr, savedTypes, savedExpectedTypes } = savedPop;\n      innerTypes = curTypes;\n      curTypes = savedTypes;\n      currentStr = savedStr;\n      expectedTypes = savedExpectedTypes;\n    } else if (char === \",\") {\n      // Comma means we need to start parsing a new tag, push the previous one to the curTypes\n\n      // No top level commas (not in a type <> are allowed)\n      if (saved.length === 0) {\n        throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedComma);\n      }\n      // If there was no actual value before the comma, then it's missing a type argument\n      if (currentStr.length === 0) {\n        throw new TypeTagParserError(typeStr, TypeTagParserErrorType.MissingTypeArgument);\n      }\n\n      // Process characters before as a type\n      const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n\n      // parse type tag and push it on the types\n      innerTypes = [];\n      curTypes.push(newType);\n      currentStr = \"\";\n      expectedTypes += 1;\n    } else if (isValidWhitespaceCharacter(char)) {\n      // This means we should save what we have and everything else should skip until the next\n      let parsedTypeTag = false;\n      if (currentStr.length !== 0) {\n        const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n\n        // parse type tag and push it on the types\n        innerTypes = [];\n        curTypes.push(newType);\n        currentStr = \"\";\n        parsedTypeTag = true;\n      }\n\n      // Skip ahead on any more whitespace\n      cur = consumeWhitespace(typeStr, cur);\n\n      // The next space MUST be a comma, or a closing > if there was something parsed before\n      // e.g. `u8 u8` is invalid but `u8, u8` is valid\n      const nextChar = typeStr[cur];\n      if (cur < typeStr.length && parsedTypeTag && nextChar !== \",\" && nextChar !== \">\") {\n        throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedWhitespaceCharacter);\n      }\n\n      // eslint-disable-next-line no-continue\n      continue;\n    } else {\n      // Any other characters just append to the current string\n      currentStr += char;\n    }\n\n    cur += 1;\n  }\n\n  // This prevents a missing '>' on type arguments\n  if (saved.length > 0) {\n    throw new TypeTagParserError(typeStr, TypeTagParserErrorType.MissingTypeArgumentClose);\n  }\n\n  // This prevents 'u8, u8' as an input\n  switch (curTypes.length) {\n    case 0:\n      return parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n    case 1:\n      if (currentStr === \"\") {\n        return curTypes[0];\n      }\n      throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedComma);\n    default:\n      throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedWhitespaceCharacter);\n  }\n}\n\n/**\n * Parses a type tag with internal types associated, allowing for the inclusion of generics if specified. This function helps in\n * constructing the appropriate type tags based on the provided string representation and associated types.\n *\n * @param str - The string representation of the type tag to parse.\n * @param types - An array of TypeTag instances that represent internal types associated with the type tag.\n * @param allowGenerics - A boolean indicating whether generics are allowed in the parsing of the type tag.\n * @group Implementation\n * @category Transactions\n */\nfunction parseTypeTagInner(str: string, types: Array<TypeTag>, allowGenerics: boolean): TypeTag {\n  const trimmedStr = str.trim();\n  const lowerCaseTrimmed = trimmedStr.toLowerCase();\n  if (isPrimitive(lowerCaseTrimmed)) {\n    if (types.length > 0) {\n      throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);\n    }\n  }\n\n  switch (trimmedStr.toLowerCase()) {\n    case \"signer\":\n      return new TypeTagSigner();\n    case \"bool\":\n      return new TypeTagBool();\n    case \"address\":\n      return new TypeTagAddress();\n    case \"u8\":\n      return new TypeTagU8();\n    case \"u16\":\n      return new TypeTagU16();\n    case \"u32\":\n      return new TypeTagU32();\n    case \"u64\":\n      return new TypeTagU64();\n    case \"u128\":\n      return new TypeTagU128();\n    case \"u256\":\n      return new TypeTagU256();\n    case \"vector\":\n      if (types.length !== 1) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedVectorTypeArgumentCount);\n      }\n      return new TypeTagVector(types[0]);\n    default:\n      // Reference will have to handle the inner type\n      if (isRef(trimmedStr)) {\n        const actualType = trimmedStr.substring(1);\n        return new TypeTagReference(parseTypeTagInner(actualType, types, allowGenerics));\n      }\n\n      // Generics are always expected to be T0 or T1\n      if (isGeneric(trimmedStr)) {\n        if (allowGenerics) {\n          return new TypeTagGeneric(Number(trimmedStr.split(\"T\")[1]));\n        }\n        throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedGenericType);\n      }\n\n      // If the value doesn't contain a colon, then we'll assume it isn't trying to be a struct\n      if (!trimmedStr.match(/:/)) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.InvalidTypeTag);\n      }\n\n      // Parse for a struct tag\n      // eslint-disable-next-line no-case-declarations\n      const structParts = trimmedStr.split(\"::\");\n      if (structParts.length !== 3) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedStructFormat);\n      }\n\n      // Validate struct address\n      // eslint-disable-next-line no-case-declarations\n      let address: AccountAddress;\n      try {\n        address = AccountAddress.fromString(structParts[0]);\n      } catch (error: any) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.InvalidAddress);\n      }\n\n      // Validate identifier characters\n      if (!isValidIdentifier(structParts[1])) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.InvalidModuleNameCharacter);\n      }\n      if (!isValidIdentifier(structParts[2])) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.InvalidStructNameCharacter);\n      }\n\n      return new TypeTagStruct(\n        new StructTag(address, new Identifier(structParts[1]), new Identifier(structParts[2]), types),\n      );\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  EntryFunctionArgumentTypes,\n  InputGenerateTransactionPayloadData,\n  InputGenerateTransactionPayloadDataWithRemoteABI,\n  InputScriptData,\n  SimpleEntryFunctionArgumentTypes,\n} from \"../types\";\nimport { Bool, FixedBytes, MoveOption, MoveString, MoveVector, U128, U16, U256, U32, U64, U8 } from \"../../bcs\";\nimport { AccountAddress } from \"../../core\";\nimport { MoveFunction } from \"../../types\";\n\n/**\n * Determines if the provided argument is of type boolean.\n * This can help in validating input types before processing them further.\n *\n * @param arg - The argument to check, which can be of various types.\n * @returns A boolean indicating whether the argument is a boolean.\n * @group Implementation\n * @category Transactions\n */\nexport function isBool(arg: SimpleEntryFunctionArgumentTypes): arg is boolean {\n  return typeof arg === \"boolean\";\n}\n\n/**\n * Checks if the provided argument is of type string.\n *\n * @param arg - The value to be checked for string type.\n * @returns A boolean indicating whether the argument is a string.\n * @group Implementation\n * @category Transactions\n */\nexport function isString(arg: any): arg is string {\n  return typeof arg === \"string\";\n}\n\n/**\n * Determines if the provided argument is of type number.\n *\n * @param arg - The argument to check, which can be of various types.\n * @returns A boolean indicating whether the argument is a number.\n * @group Implementation\n * @category Transactions\n */\nexport function isNumber(arg: SimpleEntryFunctionArgumentTypes): arg is number {\n  return typeof arg === \"number\";\n}\n\n/**\n * Converts a number or a string representation of a number into a number type.\n * This function is useful for ensuring that the input is in a consistent numeric format,\n * which can help prevent type mismatches in further processing.\n *\n * @param arg - The input value to be converted. This can be a number, a string representing a number, or any other type.\n * @returns Returns the converted number if the input is valid; otherwise, it returns undefined.\n * @group Implementation\n * @category Transactions\n */\nexport function convertNumber(arg: SimpleEntryFunctionArgumentTypes): number | undefined {\n  if (isNumber(arg)) {\n    return arg;\n  }\n  if (isString(arg) && arg !== \"\") {\n    return Number.parseInt(arg, 10);\n  }\n\n  return undefined;\n}\n\n/**\n * Determines if the provided argument is a large number, which can be a number, bigint, or string representation of a number.\n *\n * @param arg - The argument to check, which can be of type number, bigint, or string.\n * @group Implementation\n * @category Transactions\n */\nexport function isLargeNumber(arg: SimpleEntryFunctionArgumentTypes): arg is number | bigint | string {\n  return typeof arg === \"number\" || typeof arg === \"bigint\" || typeof arg === \"string\";\n}\n\n/**\n * Checks if the provided argument is empty, meaning it is either null or undefined.\n *\n * @param arg - The argument to check for emptiness.\n * @returns A boolean indicating whether the argument is empty.\n * @group Implementation\n * @category Transactions\n */\nexport function isEmptyOption(arg: SimpleEntryFunctionArgumentTypes): arg is null | undefined {\n  return arg === null || arg === undefined;\n}\n\n/**\n * Determines if the provided argument is a valid encoded entry function argument type.\n * This function helps validate that the argument conforms to the expected types for entry function parameters.\n *\n * @param arg - The argument to check, which can be of type EntryFunctionArgumentTypes or SimpleEntryFunctionArgumentTypes.\n * @group Implementation\n * @category Transactions\n */\nexport function isEncodedEntryFunctionArgument(\n  arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes,\n): arg is EntryFunctionArgumentTypes {\n  return (\n    /**\n     * Determines if the provided argument is an instance of the Bool class.\n     *\n     * @param arg - The argument to check, which can be of type EntryFunctionArgumentTypes or SimpleEntryFunctionArgumentTypes.\n     * @group Implementation\n     * @category Transactions\n     */\n    isBcsBool(arg) ||\n    /**\n     * Determines if the provided argument is an instance of U8.\n     * This function helps validate the type of the argument passed to ensure it is a U8 type.\n     *\n     * @param arg - The argument to be checked, which can be of type EntryFunctionArgumentTypes or SimpleEntryFunctionArgumentTypes.\n     * @group Implementation\n     * @category Transactions\n     */\n    isBcsU8(arg) ||\n    /**\n     * Determines if the provided argument is an instance of U16.\n     *\n     * @param arg - The argument to check, which can be of type EntryFunctionArgumentTypes or SimpleEntryFunctionArgumentTypes.\n     * @group Implementation\n     * @category Transactions\n     */\n    isBcsU16(arg) ||\n    /**\n     * Determines if the provided argument is an instance of U32.\n     *\n     * @param arg - The argument to check, which can be of type EntryFunctionArgumentTypes or SimpleEntryFunctionArgumentTypes.\n     * @returns A boolean indicating whether the argument is a U32 instance.\n     * @group Implementation\n     * @category Transactions\n     */\n    isBcsU32(arg) ||\n    /**\n     * Determine if the provided argument is an instance of U64.\n     * This function helps validate that the argument conforms to the expected U64 type.\n     *\n     * @param arg - The argument to check, which can be of type EntryFunctionArgumentTypes or SimpleEntryFunctionArgumentTypes.\n     * @group Implementation\n     * @category Transactions\n     */\n    isBcsU64(arg) ||\n    /**\n     * Determines if the provided argument is an instance of U128.\n     * This function helps validate the type of the argument passed to ensure it is a U128 type.\n     *\n     * @param arg - The argument to be checked, which can be of type EntryFunctionArgumentTypes or SimpleEntryFunctionArgumentTypes.\n     * @group Implementation\n     * @category Transactions\n     */\n    isBcsU128(arg) ||\n    /**\n     * Determines if the provided argument is an instance of U256.\n     *\n     * @param arg - The argument to check, which can be of type EntryFunctionArgumentTypes or SimpleEntryFunctionArgumentTypes.\n     * @returns A boolean indicating whether the argument is a U256 instance.\n     * @group Implementation\n     * @category Transactions\n     */\n    isBcsU256(arg) ||\n    /**\n     * Determines if the provided argument is an instance of AccountAddress.\n     * This function helps validate whether a given input corresponds to a valid BCS address type.\n     *\n     * @param arg - The argument to check, which can be of type EntryFunctionArgumentTypes or SimpleEntryFunctionArgumentTypes.\n     * @group Implementation\n     * @category Transactions\n     */\n    isBcsAddress(arg) ||\n    /**\n     * Determine if the provided argument is an instance of MoveString.\n     *\n     * @param arg - The argument to check, which can be of types EntryFunctionArgumentTypes or SimpleEntryFunctionArgumentTypes.\n     * @group Implementation\n     * @category Transactions\n     */\n    isBcsString(arg) ||\n    /**\n     * Determine if the provided argument is an instance of FixedBytes.\n     * This function helps to validate the type of the argument being passed.\n     *\n     * @param arg - The argument to check, which can be of type EntryFunctionArgumentTypes or SimpleEntryFunctionArgumentTypes.\n     * @group Implementation\n     * @category Transactions\n     */\n    isBcsFixedBytes(arg) ||\n    arg instanceof MoveVector ||\n    arg instanceof MoveOption\n  );\n}\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function isBcsBool(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is Bool {\n  return arg instanceof Bool;\n}\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function isBcsAddress(\n  arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes,\n): arg is AccountAddress {\n  return arg instanceof AccountAddress;\n}\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function isBcsString(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is MoveString {\n  return arg instanceof MoveString;\n}\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function isBcsFixedBytes(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is FixedBytes {\n  return arg instanceof FixedBytes;\n}\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function isBcsU8(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is U8 {\n  return arg instanceof U8;\n}\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function isBcsU16(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is U16 {\n  return arg instanceof U16;\n}\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function isBcsU32(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is U32 {\n  return arg instanceof U32;\n}\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function isBcsU64(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is U64 {\n  return arg instanceof U64;\n}\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function isBcsU128(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is U128 {\n  return arg instanceof U128;\n}\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function isBcsU256(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is U256 {\n  return arg instanceof U256;\n}\n\n/**\n * Determines if the provided argument contains script data input by checking for the presence of bytecode.\n *\n * @param arg - The input data to be checked, which can either be a payload with remote ABI or a standard payload.\n * @param arg.bytecode - The bytecode of the script, present if the input is script data.\n * @param arg.function - The function associated with the transaction, which is relevant for standard payloads.\n * @param arg.args - The arguments for the function, applicable in the context of standard payloads.\n * @group Implementation\n * @category Transactions\n */\nexport function isScriptDataInput(\n  arg: InputGenerateTransactionPayloadDataWithRemoteABI | InputGenerateTransactionPayloadData,\n): arg is InputScriptData {\n  return \"bytecode\" in arg;\n}\n\n/**\n * Throws an error indicating a type mismatch for a specified argument position.\n * This function helps in debugging by providing clear feedback on expected types.\n *\n * @param expectedType - The type that was expected for the argument.\n * @param position - The position of the argument that caused the type mismatch.\n * @group Implementation\n * @category Transactions\n */\nexport function throwTypeMismatch(expectedType: string, position: number) {\n  throw new Error(`Type mismatch for argument ${position}, expected '${expectedType}'`);\n}\n\n/**\n * Finds the index of the first non-signer argument in the function ABI parameters.\n *\n * A function is often defined with a `signer` or `&signer` arguments at the start, which are filled in\n * by signatures and not by the caller. This function helps identify the position of the first argument that\n * can be provided by the caller, allowing for easier handling of function parameters.\n *\n * @param functionAbi - The ABI of the function to analyze.\n * @returns The index of the first non-signer argument, or the length of the parameters array if none are found.\n * @group Implementation\n * @category Transactions\n */\nexport function findFirstNonSignerArg(functionAbi: MoveFunction): number {\n  const index = functionAbi.params.findIndex((param) => param !== \"signer\" && param !== \"&signer\");\n  if (index < 0) {\n    return functionAbi.params.length;\n  }\n  return index;\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { parseTypeTag } from \"../typeTag/parser\";\nimport {\n  TypeTag,\n  TypeTagAddress,\n  TypeTagBool,\n  TypeTagStruct,\n  TypeTagU128,\n  TypeTagU16,\n  TypeTagU256,\n  TypeTagU32,\n  TypeTagU64,\n  TypeTagU8,\n} from \"../typeTag\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport {\n  EntryFunctionArgumentTypes,\n  SimpleEntryFunctionArgumentTypes,\n  EntryFunctionABI,\n  ViewFunctionABI,\n  FunctionABI,\n  TypeArgument,\n} from \"../types\";\nimport { Bool, FixedBytes, MoveOption, MoveString, MoveVector, U128, U16, U256, U32, U64, U8 } from \"../../bcs\";\nimport { AccountAddress } from \"../../core\";\nimport { getModule } from \"../../internal/account\";\nimport {\n  findFirstNonSignerArg,\n  isBcsAddress,\n  isBcsBool,\n  isBcsString,\n  isBcsU128,\n  isBcsU16,\n  isBcsU256,\n  isBcsU32,\n  isBcsU64,\n  isBcsU8,\n  isBool,\n  isEncodedEntryFunctionArgument,\n  isLargeNumber,\n  isEmptyOption,\n  isString,\n  throwTypeMismatch,\n  convertNumber,\n} from \"./helpers\";\nimport { CallArgument, MoveFunction, MoveModule } from \"../../types\";\n\nconst TEXT_ENCODER = new TextEncoder();\n\n/**\n * Convert type arguments to only type tags, allowing for string representations of type tags.\n *\n * @param typeArguments - An optional array of type arguments that may include string representations.\n * @returns An array of TypeTag objects derived from the provided type arguments.\n * @group Implementation\n * @category Transactions\n */\nexport function standardizeTypeTags(typeArguments?: Array<TypeArgument>): Array<TypeTag> {\n  return (\n    typeArguments?.map((typeArg: TypeArgument): TypeTag => {\n      // Convert to TypeTag if it's a string representation\n      if (isString(typeArg)) {\n        return parseTypeTag(typeArg);\n      }\n      return typeArg;\n    }) ?? []\n  );\n}\n\n/**\n * Fetches the ABI of a specified module from the on-chain module ABI.\n *\n * @param moduleAddress - The address of the module from which to fetch the ABI.\n * @param moduleName - The name of the module containing the ABI.\n * @param aptosConfig - The configuration settings for Aptos.\n * @group Implementation\n * @category Transactions\n */\nexport async function fetchModuleAbi(\n  moduleAddress: string,\n  moduleName: string,\n  aptosConfig: AptosConfig,\n): Promise<MoveModule | undefined> {\n  const moduleBytecode = await getModule({ aptosConfig, accountAddress: moduleAddress, moduleName });\n  return moduleBytecode.abi;\n}\n\n/**\n * Fetches the ABI of a specified function from the on-chain module ABI. This function allows you to access the details of a\n * specific function within a module.\n *\n * @param moduleAddress - The address of the module from which to fetch the function ABI.\n * @param moduleName - The name of the module containing the function.\n * @param functionName - The name of the function whose ABI is to be fetched.\n * @param aptosConfig - The configuration settings for Aptos.\n * @group Implementation\n * @category Transactions\n */\nexport async function fetchFunctionAbi(\n  moduleAddress: string,\n  moduleName: string,\n  functionName: string,\n  aptosConfig: AptosConfig,\n): Promise<MoveFunction | undefined> {\n  const moduleAbi = await fetchModuleAbi(moduleAddress, moduleName, aptosConfig);\n  if (!moduleAbi) throw new Error(`Could not find module ABI for '${moduleAddress}::${moduleName}'`);\n  return moduleAbi.exposed_functions.find((func) => func.name === functionName);\n}\n\n/**\n * @deprecated Use `fetchFunctionAbi` instead and manually parse the type tags.\n */\nexport async function fetchMoveFunctionAbi(\n  moduleAddress: string,\n  moduleName: string,\n  functionName: string,\n  aptosConfig: AptosConfig,\n): Promise<FunctionABI> {\n  const functionAbi = await fetchFunctionAbi(moduleAddress, moduleName, functionName, aptosConfig);\n  if (!functionAbi) {\n    throw new Error(`Could not find function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);\n  }\n  const params: TypeTag[] = [];\n  for (let i = 0; i < functionAbi.params.length; i += 1) {\n    params.push(parseTypeTag(functionAbi.params[i], { allowGenerics: true }));\n  }\n\n  return {\n    typeParameters: functionAbi.generic_type_params,\n    parameters: params,\n  };\n}\n\n/**\n * Fetches the ABI for an entry function from the specified module address.\n * This function validates if the ABI corresponds to an entry function and retrieves its parameters.\n *\n * @param moduleAddress - The address of the module containing the entry function.\n * @param moduleName - The name of the module containing the entry function.\n * @param functionName - The name of the entry function to fetch the ABI for.\n * @param aptosConfig - The configuration settings for Aptos.\n * @returns An object containing the number of signers, type parameters, and function parameters.\n * @throws Error if the ABI cannot be found or if the function is not an entry function.\n * @group Implementation\n * @category Transactions\n */\nexport async function fetchEntryFunctionAbi(\n  moduleAddress: string,\n  moduleName: string,\n  functionName: string,\n  aptosConfig: AptosConfig,\n): Promise<EntryFunctionABI> {\n  const functionAbi = await fetchFunctionAbi(moduleAddress, moduleName, functionName, aptosConfig);\n\n  // If there's no ABI, then the function is invalid\n  if (!functionAbi) {\n    throw new Error(`Could not find entry function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);\n  }\n\n  // Non-entry functions also can't be used\n  if (!functionAbi.is_entry) {\n    throw new Error(`'${moduleAddress}::${moduleName}::${functionName}' is not an entry function`);\n  }\n\n  // Remove the signer arguments\n  const numSigners = findFirstNonSignerArg(functionAbi);\n  const params: TypeTag[] = [];\n  for (let i = numSigners; i < functionAbi.params.length; i += 1) {\n    params.push(parseTypeTag(functionAbi.params[i], { allowGenerics: true }));\n  }\n\n  return {\n    signers: numSigners,\n    typeParameters: functionAbi.generic_type_params,\n    parameters: params,\n  };\n}\n\n/**\n * Fetches the ABI for a view function from the specified module address.\n * This function ensures that the ABI is valid and retrieves the type parameters, parameters, and return types for the view function.\n *\n * @param moduleAddress - The address of the module containing the view function.\n * @param moduleName - The name of the module containing the view function.\n * @param functionName - The name of the view function for which to fetch the ABI.\n * @param aptosConfig - The configuration settings for Aptos.\n * @returns An object containing the type parameters, parameters, and return types of the view function.\n * @throws Error if the ABI cannot be found or if the function is not a view function.\n * @group Implementation\n * @category Transactions\n */\nexport async function fetchViewFunctionAbi(\n  moduleAddress: string,\n  moduleName: string,\n  functionName: string,\n  aptosConfig: AptosConfig,\n): Promise<ViewFunctionABI> {\n  const functionAbi = await fetchFunctionAbi(moduleAddress, moduleName, functionName, aptosConfig);\n\n  // If there's no ABI, then the function is invalid\n  if (!functionAbi) {\n    throw new Error(`Could not find view function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);\n  }\n\n  // Non-view functions can't be used\n  if (!functionAbi.is_view) {\n    throw new Error(`'${moduleAddress}::${moduleName}::${functionName}' is not an view function`);\n  }\n\n  // Type tag parameters for the function\n  const params: TypeTag[] = [];\n  for (let i = 0; i < functionAbi.params.length; i += 1) {\n    params.push(parseTypeTag(functionAbi.params[i], { allowGenerics: true }));\n  }\n\n  // The return types of the view function\n  const returnTypes: TypeTag[] = [];\n  for (let i = 0; i < functionAbi.return.length; i += 1) {\n    returnTypes.push(parseTypeTag(functionAbi.return[i], { allowGenerics: true }));\n  }\n\n  return {\n    typeParameters: functionAbi.generic_type_params,\n    parameters: params,\n    returnTypes,\n  };\n}\n\n/**\n * @deprecated Handle this inline\n *\n * @example\n * ```typescript\n * const callArgument = argument instanceof CallArgument ? argument : CallArgument.newBytes(\n *   convertArgument(functionName, functionAbi, argument, position, genericTypeParams).bcsToBytes()\n * );\n * ```\n */\nexport function convertCallArgument(\n  argument: CallArgument | EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes,\n  functionName: string,\n  functionAbi: FunctionABI,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n): CallArgument {\n  if (argument instanceof CallArgument) {\n    return argument;\n  }\n  return CallArgument.newBytes(\n    convertArgument(functionName, functionAbi, argument, position, genericTypeParams).bcsToBytes(),\n  );\n}\n\n/**\n * Converts a non-BCS encoded argument into BCS encoded, if necessary.\n * This function checks the provided argument against the expected parameter type and converts it accordingly.\n *\n * @param functionName - The name of the function for which the argument is being converted.\n * @param functionAbiOrModuleAbi - The ABI (Application Binary Interface) of the function, which defines its parameters.\n * @param arg - The argument to be converted, which can be of various types.\n * @param position - The index of the argument in the function's parameter list.\n * @param genericTypeParams - An array of type tags for any generic type parameters.\n * @param options - Options for the conversion process.\n * @param options.allowUnknownStructs - If true, unknown structs will be allowed and converted to a `FixedBytes`.\n * @group Implementation\n * @category Transactions\n */\nexport function convertArgument(\n  functionName: string,\n  functionAbiOrModuleAbi: MoveModule | FunctionABI,\n  arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n  options?: { allowUnknownStructs?: boolean },\n) {\n  let param: TypeTag;\n\n  if (\"exposed_functions\" in functionAbiOrModuleAbi) {\n    const functionAbi = functionAbiOrModuleAbi.exposed_functions.find((func) => func.name === functionName);\n    if (!functionAbi) {\n      throw new Error(\n        `Could not find function ABI for '${functionAbiOrModuleAbi.address}::${functionAbiOrModuleAbi.name}::${functionName}'`,\n      );\n    }\n\n    if (position >= functionAbi.params.length) {\n      throw new Error(`Too many arguments for '${functionName}', expected ${functionAbi.params.length}`);\n    }\n\n    param = parseTypeTag(functionAbi.params[position], { allowGenerics: true });\n  } else {\n    if (position >= functionAbiOrModuleAbi.parameters.length) {\n      throw new Error(`Too many arguments for '${functionName}', expected ${functionAbiOrModuleAbi.parameters.length}`);\n    }\n\n    param = functionAbiOrModuleAbi.parameters[position];\n  }\n\n  return checkOrConvertArgument(\n    arg,\n    param,\n    position,\n    genericTypeParams,\n    \"exposed_functions\" in functionAbiOrModuleAbi ? functionAbiOrModuleAbi : undefined,\n    options,\n  );\n}\n\n/**\n * Checks if the provided argument is BCS encoded and converts it if necessary, ensuring type compatibility with the ABI.\n * This function helps in validating and converting arguments for entry functions based on their expected types.\n *\n * @param arg - The argument to check or convert, which can be either a simple or entry function argument type.\n * @param param - The expected type tag for the argument.\n * @param position - The position of the argument in the function call.\n * @param genericTypeParams - An array of generic type parameters that may be used for conversion.\n * @group Implementation\n * @category Transactions\n */\nexport function checkOrConvertArgument(\n  arg: SimpleEntryFunctionArgumentTypes | EntryFunctionArgumentTypes,\n  param: TypeTag,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n  moduleAbi?: MoveModule,\n  options?: { allowUnknownStructs?: boolean },\n) {\n  // If the argument is bcs encoded, we can just use it directly\n  if (isEncodedEntryFunctionArgument(arg)) {\n    // Ensure the type matches the ABI\n\n    /**\n     * Checks the type of the provided argument against the expected type.\n     * This function helps validate that the argument conforms to the specified type requirements.\n     *\n     * @param typeArgs - The expected type arguments.\n     * @param arg - The argument to be checked.\n     * @param position - The position of the argument in the context of the check.\n     * @param moduleAbi - The ABI of the module containing the function, used for type checking.\n     *                    This will typically have information about structs, enums, and other types.\n     * @group Implementation\n     * @category Transactions\n     */\n    checkType(param, arg, position);\n    return arg;\n  }\n\n  // If it is not BCS encoded, we will need to convert it with the ABI\n  return parseArg(arg, param, position, genericTypeParams, moduleAbi, options);\n}\n\n/**\n * Parses a non-BCS encoded argument into a BCS encoded argument recursively.\n * This function helps convert various types of input arguments into their corresponding BCS encoded formats based on the\n * specified parameter type.\n *\n * @param arg - The argument to be parsed, which can be of various types.\n * @param param - The type tag that defines the expected type of the argument.\n * @param position - The position of the argument in the function call, used for error reporting.\n * @param genericTypeParams - An array of type tags for generic type parameters, used when the parameter type is generic.\n * @param moduleAbi - The ABI of the module containing the function, used for type checking.\n *                    This will typically have information about structs, enums, and other types.\n * @param options - Options for the conversion process.\n * @param options.allowUnknownStructs - If true, unknown structs will be allowed and converted to a `FixedBytes`.\n * @group Implementation\n * @category Transactions\n */\nfunction parseArg(\n  arg: SimpleEntryFunctionArgumentTypes,\n  param: TypeTag,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n  moduleAbi?: MoveModule,\n  options?: { allowUnknownStructs?: boolean },\n): EntryFunctionArgumentTypes {\n  if (param.isBool()) {\n    if (isBool(arg)) {\n      return new Bool(arg);\n    }\n    if (isString(arg)) {\n      if (arg === \"true\") return new Bool(true);\n      if (arg === \"false\") return new Bool(false);\n    }\n\n    /**\n     * Throws a type mismatch error for the specified move option.\n     *\n     * @param moveOption - The name of the move option that caused the type mismatch.\n     * @param position - The position where the error occurred.\n     * @group Implementation\n     * @category Transactions\n     */\n    throwTypeMismatch(\"boolean\", position);\n  }\n  // TODO: support uint8array?\n  if (param.isAddress()) {\n    if (isString(arg)) {\n      return AccountAddress.fromString(arg);\n    }\n    throwTypeMismatch(\"string | AccountAddress\", position);\n  }\n  if (param.isU8()) {\n    const num = convertNumber(arg);\n    if (num !== undefined) {\n      return new U8(num);\n    }\n    throwTypeMismatch(\"number | string\", position);\n  }\n  if (param.isU16()) {\n    const num = convertNumber(arg);\n    if (num !== undefined) {\n      return new U16(num);\n    }\n    throwTypeMismatch(\"number | string\", position);\n  }\n  if (param.isU32()) {\n    const num = convertNumber(arg);\n    if (num !== undefined) {\n      return new U32(num);\n    }\n    throwTypeMismatch(\"number | string\", position);\n  }\n  if (param.isU64()) {\n    if (isLargeNumber(arg)) {\n      return new U64(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n  if (param.isU128()) {\n    if (isLargeNumber(arg)) {\n      return new U128(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n  if (param.isU256()) {\n    if (isLargeNumber(arg)) {\n      return new U256(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n\n  // Generic needs to use the subtype\n  if (param.isGeneric()) {\n    const genericIndex = param.value;\n    if (genericIndex < 0 || genericIndex >= genericTypeParams.length) {\n      throw new Error(`Generic argument ${param.toString()} is invalid for argument ${position}`);\n    }\n\n    return checkOrConvertArgument(arg, genericTypeParams[genericIndex], position, genericTypeParams, moduleAbi);\n  }\n\n  // We have to special case some vectors for Vector<u8>\n  if (param.isVector()) {\n    // Check special case for Vector<u8>\n    if (param.value.isU8()) {\n      // We don't allow vector<u8>, but we convert strings to UTF8 Uint8Array\n      // This is legacy behavior from the original SDK\n      if (isString(arg)) {\n        return MoveVector.U8(TEXT_ENCODER.encode(arg));\n      }\n      if (arg instanceof Uint8Array) {\n        return MoveVector.U8(arg);\n      }\n      if (arg instanceof ArrayBuffer) {\n        return MoveVector.U8(new Uint8Array(arg));\n      }\n    }\n\n    if (isString(arg)) {\n      // In a web env, arguments are passing as strings\n      if (arg.startsWith(\"[\")) {\n        return checkOrConvertArgument(JSON.parse(arg), param, position, genericTypeParams);\n      }\n    }\n\n    // TODO: Support Uint16Array, Uint32Array, BigUint64Array?\n\n    if (Array.isArray(arg)) {\n      return new MoveVector(\n        arg.map((item) => checkOrConvertArgument(item, param.value, position, genericTypeParams, moduleAbi)),\n      );\n    }\n\n    throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);\n  }\n\n  // Handle structs as they're more complex\n  if (param.isStruct()) {\n    if (param.isString()) {\n      if (isString(arg)) {\n        return new MoveString(arg);\n      }\n      throwTypeMismatch(\"string\", position);\n    }\n    if (param.isObject()) {\n      // The inner type of Object doesn't matter, since it's just syntactic sugar\n      if (isString(arg)) {\n        return AccountAddress.fromString(arg);\n      }\n      throwTypeMismatch(\"string | AccountAddress\", position);\n    }\n    // Handle known enum types from Aptos framework\n    if (param.isDelegationKey() || param.isRateLimiter()) {\n      if (arg instanceof Uint8Array) {\n        return new FixedBytes(arg);\n      }\n      throwTypeMismatch(\"Uint8Array\", position);\n    }\n\n    if (param.isOption()) {\n      if (isEmptyOption(arg)) {\n        // Here we attempt to reconstruct the underlying type\n        // Note, for some reason the `isBool` etc. does not work with the compiler\n        const innerParam = param.value.typeArgs[0];\n        if (innerParam instanceof TypeTagBool) {\n          return new MoveOption<Bool>(null);\n        }\n        if (innerParam instanceof TypeTagAddress) {\n          return new MoveOption<AccountAddress>(null);\n        }\n        if (innerParam instanceof TypeTagU8) {\n          return new MoveOption<U8>(null);\n        }\n        if (innerParam instanceof TypeTagU16) {\n          return new MoveOption<U16>(null);\n        }\n        if (innerParam instanceof TypeTagU32) {\n          return new MoveOption<U32>(null);\n        }\n        if (innerParam instanceof TypeTagU64) {\n          return new MoveOption<U64>(null);\n        }\n        if (innerParam instanceof TypeTagU128) {\n          return new MoveOption<U128>(null);\n        }\n        if (innerParam instanceof TypeTagU256) {\n          return new MoveOption<U256>(null);\n        }\n\n        // In all other cases, we will use a placeholder, it doesn't actually matter what the type is, but it will be obvious\n        // Note: This is a placeholder U8 type, and does not match the actual type, as that can't be dynamically grabbed\n        return new MoveOption<MoveString>(null);\n      }\n\n      return new MoveOption(\n        checkOrConvertArgument(arg, param.value.typeArgs[0], position, genericTypeParams, moduleAbi),\n      );\n    }\n\n    // We are assuming that fieldless structs are enums, and therefore we cannot typecheck any further due\n    // to limited information from the ABI. This does not work for structs on other modules.\n    const structDefinition = moduleAbi?.structs.find((s) => s.name === param.value.name.identifier);\n    if (structDefinition?.fields.length === 0 && arg instanceof Uint8Array) {\n      return new FixedBytes(arg);\n    }\n\n    if (arg instanceof Uint8Array && options?.allowUnknownStructs) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        // eslint-disable-next-line max-len\n        `Unsupported struct input type for argument ${position}. Continuing since 'allowUnknownStructs' is enabled.`,\n      );\n      return new FixedBytes(arg);\n    }\n\n    throw new Error(`Unsupported struct input type for argument ${position}, type '${param.toString()}'`);\n  }\n\n  throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);\n}\n\n/**\n * Checks that the type of the BCS encoded argument matches the ABI\n * @param param\n * @param arg\n * @param position\n * @group Implementation\n * @category Transactions\n */\nfunction checkType(param: TypeTag, arg: EntryFunctionArgumentTypes, position: number) {\n  if (param.isBool()) {\n    if (isBcsBool(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"Bool\", position);\n  }\n  if (param.isAddress()) {\n    if (isBcsAddress(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"AccountAddress\", position);\n  }\n  if (param.isU8()) {\n    if (isBcsU8(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U8\", position);\n  }\n  if (param.isU16()) {\n    if (isBcsU16(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U16\", position);\n  }\n  if (param.isU32()) {\n    if (isBcsU32(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U32\", position);\n  }\n  if (param.isU64()) {\n    if (isBcsU64(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U64\", position);\n  }\n  if (param.isU128()) {\n    if (isBcsU128(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U128\", position);\n  }\n  if (param.isU256()) {\n    if (isBcsU256(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U256\", position);\n  }\n  if (param.isVector()) {\n    if (arg instanceof MoveVector) {\n      // If there's anything in it, check that the inner types match\n      // Note that since it's typed, the first item should be the same as the rest\n      if (arg.values.length > 0) {\n        checkType(param.value, arg.values[0], position);\n      }\n\n      return;\n    }\n    throwTypeMismatch(\"MoveVector\", position);\n  }\n\n  // Handle structs as they're more complex\n  if (param instanceof TypeTagStruct) {\n    if (param.isString()) {\n      if (isBcsString(arg)) {\n        return;\n      }\n      throwTypeMismatch(\"MoveString\", position);\n    }\n    if (param.isObject()) {\n      if (isBcsAddress(arg)) {\n        return;\n      }\n      throwTypeMismatch(\"AccountAddress\", position);\n    }\n    if (param.isOption()) {\n      if (arg instanceof MoveOption) {\n        // If there's a value, we can check the inner type (otherwise it doesn't really matter)\n        if (arg.value !== undefined) {\n          checkType(param.value.typeArgs[0], arg.value, position);\n        }\n        return;\n      }\n      throwTypeMismatch(\"MoveOption\", position);\n    }\n  }\n\n  throw new Error(`Type mismatch for argument ${position}, expected '${param.toString()}'`);\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ScriptComposerWasm } from \"@aptos-labs/script-composer-pack\";\nimport { AptosApiType, getFunctionParts } from \"../../utils\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport { InputBatchedFunctionData } from \"../types\";\nimport { standardizeTypeTags } from \"../transactionBuilder\";\nimport { CallArgument } from \"../../types\";\nimport { convertArgument, fetchModuleAbi } from \"../transactionBuilder/remoteAbi\";\n\n/**\n * A wrapper class around TransactionComposer, which is a WASM library compiled\n * from aptos-core/aptos-move/script-composer.\n * This class allows the SDK caller to build a transaction that invokes multiple Move functions\n * and allow for arguments to be passed around.\n * */\nexport class AptosScriptComposer {\n  private config: AptosConfig;\n\n  private builder?: any;\n\n  private static transactionComposer?: any;\n\n  constructor(aptosConfig: AptosConfig) {\n    this.config = aptosConfig;\n    this.builder = undefined;\n  }\n\n  // Initializing the wasm needed for the script composer, must be called\n  // before using the composer.\n  async init() {\n    if (!AptosScriptComposer.transactionComposer) {\n      const module = await import(\"@aptos-labs/script-composer-pack\");\n      const { TransactionComposer, initSync } = module;\n      if (!ScriptComposerWasm.isInitialized) {\n        ScriptComposerWasm.init();\n      }\n      initSync({ module: ScriptComposerWasm.wasm });\n      AptosScriptComposer.transactionComposer = TransactionComposer;\n    }\n    this.builder = AptosScriptComposer.transactionComposer.single_signer();\n  }\n\n  // Add a move function invocation to the TransactionComposer.\n  //\n  // Similar to how to create an entry function, the difference is that input arguments could\n  // either be a `CallArgument` which represents an abstract value returned from a previous Move call\n  // or the regular entry function arguments.\n  //\n  // The function would also return a list of `CallArgument` that can be passed on to future calls.\n  async addBatchedCalls(input: InputBatchedFunctionData): Promise<CallArgument[]> {\n    const { moduleAddress, moduleName, functionName } = getFunctionParts(input.function);\n    const nodeUrl = this.config.getRequestUrl(AptosApiType.FULLNODE);\n\n    // Load the calling module into the builder.\n    await this.builder.load_module(nodeUrl, `${moduleAddress}::${moduleName}`);\n\n    // Load the calling type arguments into the loader.\n    if (input.typeArguments !== undefined) {\n      for (const typeArgument of input.typeArguments) {\n        await this.builder.load_type_tag(nodeUrl, typeArgument.toString());\n      }\n    }\n    const typeArguments = standardizeTypeTags(input.typeArguments);\n    const moduleAbi = await fetchModuleAbi(moduleAddress, moduleName, this.config);\n    if (!moduleAbi) {\n      throw new Error(`Could not find module ABI for '${moduleAddress}::${moduleName}'`);\n    }\n\n    // Check the type argument count against the ABI\n    const functionAbi = moduleAbi?.exposed_functions.find((func) => func.name === functionName);\n    if (!functionAbi) {\n      throw new Error(`Could not find function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);\n    }\n\n    if (typeArguments.length !== functionAbi.generic_type_params.length) {\n      throw new Error(\n        `Type argument count mismatch, expected ${functionAbi?.generic_type_params.length}, received ${typeArguments.length}`,\n      );\n    }\n\n    const functionArguments: CallArgument[] = input.functionArguments.map((arg, i) =>\n      arg instanceof CallArgument\n        ? arg\n        : CallArgument.newBytes(\n            convertArgument(functionName, moduleAbi, arg, i, typeArguments, { allowUnknownStructs: true }).bcsToBytes(),\n          ),\n    );\n\n    return this.builder.add_batched_call(\n      `${moduleAddress}::${moduleName}`,\n      functionName,\n      typeArguments.map((arg) => arg.toString()),\n      functionArguments,\n    );\n  }\n\n  build(): Uint8Array {\n    return this.builder.generate_batched_calls(true);\n  }\n}\n","/**\n * This file contains the underlying implementations for exposed submission API surface in\n * the {@link api/transaction}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * transaction namespace and without having a dependency cycle error.\n * @group Implementation\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { Deserializer, MoveVector } from \"../bcs\";\nimport { postAptosFullNode } from \"../client\";\nimport { Account, AbstractKeylessAccount, isKeylessSigner } from \"../account\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { FederatedKeylessPublicKey, KeylessPublicKey, KeylessSignature } from \"../core/crypto\";\nimport { AccountAuthenticator } from \"../transactions/authenticator/account\";\nimport {\n  buildTransaction,\n  generateTransactionPayload,\n  generateSignedTransactionForSimulation,\n  generateSignedTransaction,\n} from \"../transactions/transactionBuilder/transactionBuilder\";\nimport {\n  InputGenerateTransactionData,\n  AnyRawTransaction,\n  InputSimulateTransactionData,\n  InputGenerateTransactionOptions,\n  InputGenerateTransactionPayloadDataWithRemoteABI,\n  InputSubmitTransactionData,\n  InputGenerateMultiAgentRawTransactionData,\n  InputGenerateSingleSignerRawTransactionData,\n  AnyTransactionPayloadInstance,\n  EntryFunctionABI,\n} from \"../transactions/types\";\nimport { UserTransactionResponse, PendingTransactionResponse, MimeType, HexInput } from \"../types\";\nimport { SignedTransaction, TypeTagVector, generateSigningMessageForTransaction } from \"../transactions\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\nimport { MultiAgentTransaction } from \"../transactions/instances/multiAgentTransaction\";\n\n/**\n * We are defining function signatures, each with its specific input and output.\n * These are the possible function signature for `generateTransaction` function.\n * When we call `generateTransaction` function with the relevant type properties,\n * Typescript can infer the return type based on the appropriate function overload.\n * @group Implementation\n */\nexport async function generateTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateSingleSignerRawTransactionData,\n): Promise<SimpleTransaction>;\nexport async function generateTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateMultiAgentRawTransactionData,\n): Promise<MultiAgentTransaction>;\n/**\n * Generates any transaction by passing in the required arguments\n *\n * @param args.sender The transaction sender's account address as a AccountAddressInput\n * @param args.data EntryFunctionData | ScriptData | MultiSigData\n * @param args.feePayerAddress optional. For a fee payer (aka sponsored) transaction\n * @param args.secondarySignerAddresses optional. For a multi-agent or fee payer (aka sponsored) transactions\n * @param args.options optional. GenerateTransactionOptions type\n *\n * @example\n * For a single signer entry function\n * move function name, move function type arguments, move function arguments\n * `\n * data: {\n *  function:\"0x1::aptos_account::transfer\",\n *  typeArguments:[]\n *  functionArguments :[receiverAddress,10]\n * }\n * `\n *\n * @example\n * For a single signer script function\n * module bytecode, move function type arguments, move function arguments\n * ```\n * data: {\n *  bytecode:\"0x001234567\",\n *  typeArguments:[],\n *  functionArguments :[receiverAddress,10]\n * }\n * ```\n *\n * @return An instance of a RawTransaction, plus optional secondary/fee payer addresses\n * ```\n * {\n *  rawTransaction: RawTransaction,\n *  secondarySignerAddresses?: Array<AccountAddress>,\n *  feePayerAddress?: AccountAddress\n * }\n * ```\n * @group Implementation\n */\nexport async function generateTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateTransactionData,\n): Promise<AnyRawTransaction> {\n  const payload = await buildTransactionPayload(args);\n  return buildRawTransaction(args, payload);\n}\n\n/**\n * Builds a transaction payload based on the provided configuration and input data.\n * This function is essential for preparing transaction data for execution on the Aptos blockchain.\n *\n * @param args - The arguments for building the transaction payload.\n * @param args.aptosConfig - Configuration settings for the Aptos network.\n * @param args.data - Input data required to generate the transaction payload, which may include bytecode, multisig address,\n * function name, function arguments, type arguments, and ABI.\n * @returns A promise that resolves to the generated transaction payload instance.\n * @group Implementation\n */\nexport async function buildTransactionPayload(\n  args: { aptosConfig: AptosConfig } & InputGenerateTransactionData,\n): Promise<AnyTransactionPayloadInstance> {\n  const { aptosConfig, data } = args;\n  // Merge in aptosConfig for remote ABI on non-script payloads\n  let generateTransactionPayloadData: InputGenerateTransactionPayloadDataWithRemoteABI;\n  let payload: AnyTransactionPayloadInstance;\n\n  if (\"bytecode\" in data) {\n    // TODO: Add ABI checking later\n    payload = await generateTransactionPayload(data);\n  } else if (\"multisigAddress\" in data) {\n    generateTransactionPayloadData = {\n      aptosConfig,\n      multisigAddress: data.multisigAddress,\n      function: data.function,\n      functionArguments: data.functionArguments,\n      typeArguments: data.typeArguments,\n      abi: data.abi,\n    };\n    payload = await generateTransactionPayload(generateTransactionPayloadData);\n  } else {\n    generateTransactionPayloadData = {\n      aptosConfig,\n      function: data.function,\n      functionArguments: data.functionArguments,\n      typeArguments: data.typeArguments,\n      abi: data.abi,\n    };\n    payload = await generateTransactionPayload(generateTransactionPayloadData);\n  }\n  return payload;\n}\n\n/**\n * Builds a raw transaction based on the provided configuration and payload.\n * This function helps in creating a transaction that can be sent to the Aptos blockchain.\n *\n * @param args - The arguments for generating the transaction.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.sender - The address of the sender of the transaction.\n * @param args.options - Additional options for the transaction.\n * @param payload - The payload of the transaction, which defines the action to be performed.\n * @group Implementation\n */\nexport async function buildRawTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateTransactionData,\n  payload: AnyTransactionPayloadInstance,\n): Promise<AnyRawTransaction> {\n  const { aptosConfig, sender, options } = args;\n\n  let feePayerAddress;\n  if (isFeePayerTransactionInput(args)) {\n    feePayerAddress = AccountAddress.ZERO.toString();\n  }\n\n  if (isMultiAgentTransactionInput(args)) {\n    const { secondarySignerAddresses } = args;\n    return buildTransaction({\n      aptosConfig,\n      sender,\n      payload,\n      options,\n      secondarySignerAddresses,\n      feePayerAddress,\n    });\n  }\n\n  return buildTransaction({\n    aptosConfig,\n    sender,\n    payload,\n    options,\n    feePayerAddress,\n  });\n}\n\n/**\n * Determine if the transaction input includes a fee payer.\n *\n * @param data - The input data for generating a transaction.\n * @param data.withFeePayer - Indicates whether a fee payer is included in the transaction input.\n * @returns A boolean value indicating if the transaction input has a fee payer.\n * @group Implementation\n */\nfunction isFeePayerTransactionInput(data: InputGenerateTransactionData): boolean {\n  return data.withFeePayer === true;\n}\n\n/**\n * Determines whether the provided transaction input data includes multiple agent signatures.\n *\n * @param data - The transaction input data to evaluate.\n * @param data.secondarySignerAddresses - An array of secondary signer addresses, indicating multiple agents.\n * @group Implementation\n */\nfunction isMultiAgentTransactionInput(\n  data: InputGenerateTransactionData,\n): data is InputGenerateMultiAgentRawTransactionData {\n  return \"secondarySignerAddresses\" in data;\n}\n\n/**\n * Builds a signing message that can be signed by external signers.\n *\n * Note: Please prefer using `signTransaction` unless signing outside the SDK.\n *\n * @param args - The arguments for generating the signing message.\n * @param args.transaction - AnyRawTransaction, as generated by `generateTransaction()`.\n *\n * @returns The message to be signed.\n * @group Implementation\n */\nexport function getSigningMessage(args: { transaction: AnyRawTransaction }): Uint8Array {\n  const { transaction } = args;\n  return generateSigningMessageForTransaction(transaction);\n}\n\n/**\n * Sign a transaction that can later be submitted to the chain.\n *\n * @param args The arguments for signing the transaction.\n * @param args.signer The signer account to sign the transaction.\n * @param args.transaction An instance of a RawTransaction, plus optional secondary/fee payer addresses.\n *\n * @return The signer AccountAuthenticator.\n * @group Implementation\n */\nexport function signTransaction(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n  const { signer, transaction } = args;\n  return signer.signTransactionWithAuthenticator(transaction);\n}\n\nexport function signAsFeePayer(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n  const { signer, transaction } = args;\n\n  // if transaction doesn't hold a \"feePayerAddress\" prop it means\n  // this is not a fee payer transaction\n  if (!transaction.feePayerAddress) {\n    throw new Error(`Transaction ${transaction} is not a Fee Payer transaction`);\n  }\n\n  // Set the feePayerAddress to the signer account address\n  transaction.feePayerAddress = signer.accountAddress;\n\n  return signTransaction({\n    signer,\n    transaction,\n  });\n}\n\n/**\n * Simulates a transaction before signing it to evaluate its potential outcome.\n *\n * @param args The arguments for simulating the transaction.\n * @param args.aptosConfig The configuration for the Aptos network.\n * @param args.transaction The raw transaction to simulate.\n * @param args.signerPublicKey Optional. The signer public key.\n * @param args.secondarySignersPublicKeys Optional. For when the transaction involves multiple signers.\n * @param args.feePayerPublicKey Optional. For when the transaction is sponsored by a fee payer.\n * @param args.options Optional. A configuration object to customize the simulation process.\n * @param args.options.estimateGasUnitPrice Optional. Indicates whether to estimate the gas unit price.\n * @param args.options.estimateMaxGasAmount Optional. Indicates whether to estimate the maximum gas amount.\n * @param args.options.estimatePrioritizedGasUnitPrice Optional. Indicates whether to estimate the prioritized gas unit price.\n * @group Implementation\n */\nexport async function simulateTransaction(\n  args: { aptosConfig: AptosConfig } & InputSimulateTransactionData,\n): Promise<Array<UserTransactionResponse>> {\n  const { aptosConfig, transaction, signerPublicKey, secondarySignersPublicKeys, feePayerPublicKey, options } = args;\n\n  const signedTransaction = generateSignedTransactionForSimulation({\n    transaction,\n    signerPublicKey,\n    secondarySignersPublicKeys,\n    feePayerPublicKey,\n    options,\n  });\n\n  const { data } = await postAptosFullNode<Uint8Array, Array<UserTransactionResponse>>({\n    aptosConfig,\n    body: signedTransaction,\n    path: \"transactions/simulate\",\n    params: {\n      estimate_gas_unit_price: args.options?.estimateGasUnitPrice ?? false,\n      estimate_max_gas_amount: args.options?.estimateMaxGasAmount ?? false,\n      estimate_prioritized_gas_unit_price: args.options?.estimatePrioritizedGasUnitPrice ?? false,\n    },\n    originMethod: \"simulateTransaction\",\n    contentType: MimeType.BCS_SIGNED_TRANSACTION,\n  });\n  return data;\n}\n\n/**\n * Submit a transaction to the Aptos blockchain.\n *\n * @param args - The arguments for submitting the transaction.\n * @param args.aptosConfig - The configuration for connecting to the Aptos network.\n * @param args.transaction - The Aptos transaction data to be submitted.\n * @param args.senderAuthenticator - The account authenticator of the transaction sender.\n * @param args.secondarySignerAuthenticators - Optional. Authenticators for additional signers in a multi-signer transaction.\n *\n * @returns PendingTransactionResponse - The response containing the status of the submitted transaction.\n * @group Implementation\n */\nexport async function submitTransaction(\n  args: {\n    aptosConfig: AptosConfig;\n  } & InputSubmitTransactionData,\n): Promise<PendingTransactionResponse> {\n  const { aptosConfig } = args;\n  const signedTransaction = generateSignedTransaction({ ...args });\n  try {\n    const { data } = await postAptosFullNode<Uint8Array, PendingTransactionResponse>({\n      aptosConfig,\n      body: signedTransaction,\n      path: \"transactions\",\n      originMethod: \"submitTransaction\",\n      contentType: MimeType.BCS_SIGNED_TRANSACTION,\n    });\n    return data;\n  } catch (e) {\n    const signedTxn = SignedTransaction.deserialize(new Deserializer(signedTransaction));\n    if (\n      signedTxn.authenticator.isSingleSender() &&\n      signedTxn.authenticator.sender.isSingleKey() &&\n      (signedTxn.authenticator.sender.public_key.publicKey instanceof KeylessPublicKey ||\n        signedTxn.authenticator.sender.public_key.publicKey instanceof FederatedKeylessPublicKey)\n    ) {\n      await AbstractKeylessAccount.fetchJWK({\n        aptosConfig,\n        publicKey: signedTxn.authenticator.sender.public_key.publicKey,\n        kid: (signedTxn.authenticator.sender.signature.signature as KeylessSignature).getJwkKid(),\n      });\n    }\n    throw e;\n  }\n}\n\nexport type FeePayerOrFeePayerAuthenticatorOrNeither =\n  | { feePayer: Account; feePayerAuthenticator?: never }\n  | { feePayer?: never; feePayerAuthenticator: AccountAuthenticator }\n  | { feePayer?: never; feePayerAuthenticator?: never };\n\nexport async function signAndSubmitTransaction(\n  args: FeePayerOrFeePayerAuthenticatorOrNeither & {\n    aptosConfig: AptosConfig;\n    signer: Account;\n    transaction: AnyRawTransaction;\n  },\n): Promise<PendingTransactionResponse> {\n  const { aptosConfig, signer, feePayer, transaction } = args;\n  // If the signer contains a KeylessAccount, await proof fetching in case the proof\n  // was fetched asynchronously.\n  if (isKeylessSigner(signer)) {\n    await signer.checkKeylessAccountValidity(aptosConfig);\n  }\n  if (isKeylessSigner(feePayer)) {\n    await feePayer.checkKeylessAccountValidity(aptosConfig);\n  }\n  const feePayerAuthenticator =\n    args.feePayerAuthenticator || (feePayer && signAsFeePayer({ signer: feePayer, transaction }));\n\n  const senderAuthenticator = signTransaction({ signer, transaction });\n  return submitTransaction({\n    aptosConfig,\n    transaction,\n    senderAuthenticator,\n    feePayerAuthenticator,\n  });\n}\n\nexport async function signAndSubmitAsFeePayer(args: {\n  aptosConfig: AptosConfig;\n  feePayer: Account;\n  senderAuthenticator: AccountAuthenticator;\n  transaction: AnyRawTransaction;\n}): Promise<PendingTransactionResponse> {\n  const { aptosConfig, senderAuthenticator, feePayer, transaction } = args;\n\n  if (isKeylessSigner(feePayer)) {\n    await feePayer.checkKeylessAccountValidity(aptosConfig);\n  }\n\n  const feePayerAuthenticator = signAsFeePayer({ signer: feePayer, transaction });\n\n  return submitTransaction({\n    aptosConfig,\n    transaction,\n    senderAuthenticator,\n    feePayerAuthenticator,\n  });\n}\n\nconst packagePublishAbi: EntryFunctionABI = {\n  typeParameters: [],\n  parameters: [TypeTagVector.u8(), new TypeTagVector(TypeTagVector.u8())],\n};\n\n/**\n * Publishes a package transaction to the Aptos blockchain.\n * This function allows you to create and send a transaction that publishes a package with the specified metadata and bytecode.\n *\n * @param args - The arguments for the package transaction.\n * @param args.aptosConfig - The configuration settings for the Aptos client.\n * @param args.account - The address of the account sending the transaction.\n * @param args.metadataBytes - The metadata associated with the package, represented as hexadecimal input.\n * @param args.moduleBytecode - An array of module bytecode, each represented as hexadecimal input.\n * @param args.options - Optional parameters for generating the transaction.\n * @group Implementation\n */\nexport async function publicPackageTransaction(args: {\n  aptosConfig: AptosConfig;\n  account: AccountAddressInput;\n  metadataBytes: HexInput;\n  moduleBytecode: Array<HexInput>;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, account, metadataBytes, moduleBytecode, options } = args;\n\n  const totalByteCode = moduleBytecode.map((bytecode) => MoveVector.U8(bytecode));\n\n  return generateTransaction({\n    aptosConfig,\n    sender: AccountAddress.from(account),\n    data: {\n      function: \"0x1::code::publish_package_txn\",\n      functionArguments: [MoveVector.U8(metadataBytes), new MoveVector(totalByteCode)],\n      abi: packagePublishAbi,\n    },\n    options,\n  });\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/account}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * account namespace and without having a dependency cycle error.\n * @group Implementation\n */\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport {\n  getAptosFullNode,\n  getPageWithObfuscatedCursor,\n  paginateWithCursor,\n  paginateWithObfuscatedCursor,\n} from \"../client\";\nimport {\n  AccountData,\n  CursorPaginationArgs,\n  GetAccountCoinsDataResponse,\n  GetAccountCollectionsWithOwnedTokenResponse,\n  GetAccountOwnedTokensFromCollectionResponse,\n  GetAccountOwnedTokensQueryResponse,\n  GetObjectDataQueryResponse,\n  LedgerVersionArg,\n  MoveModuleBytecode,\n  MoveResource,\n  MoveStructId,\n  OrderByArg,\n  PaginationArgs,\n  PendingTransactionResponse,\n  TokenStandardArg,\n  TransactionResponse,\n  WhereArg,\n} from \"../types\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { Account, Ed25519Account, MultiEd25519Account } from \"../account\";\nimport { AnyPublicKey, Ed25519PublicKey, PrivateKey } from \"../core/crypto\";\nimport { queryIndexer } from \"./general\";\nimport { getModule as getModuleUtil, getInfo as getInfoUtil } from \"./utils\";\nimport {\n  GetAccountCoinsCountQuery,\n  GetAccountCoinsDataQuery,\n  GetAccountCollectionsWithOwnedTokensQuery,\n  GetObjectDataQuery,\n  GetAccountOwnedTokensFromCollectionQuery,\n  GetAccountOwnedTokensQuery,\n  GetAccountTokensCountQuery,\n  GetAccountTransactionsCountQuery,\n} from \"../types/generated/operations\";\nimport {\n  GetAccountCoinsCount,\n  GetAccountCoinsData,\n  GetAccountCollectionsWithOwnedTokens,\n  GetObjectData,\n  GetAccountOwnedTokens,\n  GetAccountOwnedTokensFromCollection,\n  GetAccountTokensCount,\n  GetAccountTransactionsCount,\n} from \"../types/generated/queries\";\nimport { Secp256k1PrivateKey, AuthenticationKey, Ed25519PrivateKey, createObjectAddress } from \"../core\";\nimport { CurrentFungibleAssetBalancesBoolExp } from \"../types/generated/types\";\nimport { getTableItem } from \"./table\";\nimport { APTOS_COIN } from \"../utils\";\nimport { AptosApiError } from \"../errors\";\nimport { signAndSubmitTransaction, generateTransaction } from \"./transactionSubmission\";\nimport { EntryFunctionABI, RotationProofChallenge, TypeTagU8, TypeTagVector } from \"../transactions\";\nimport { U8, MoveVector } from \"../bcs\";\nimport { waitForTransaction } from \"./transaction\";\n\n/**\n * Retrieves account information for a specified account address.\n *\n * @param args - The arguments for retrieving account information.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.accountAddress - The address of the account to retrieve information for.\n * @group Implementation\n */\nexport async function getInfo(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<AccountData> {\n  return getInfoUtil(args);\n}\n\n/**\n * Retrieves the modules associated with a specified account address.\n *\n * @param args - The arguments for retrieving modules.\n * @param args.aptosConfig - The configuration for connecting to the Aptos blockchain.\n * @param args.accountAddress - The address of the account whose modules are to be retrieved.\n * @param args.options - Optional parameters for pagination and ledger version.\n * @param args.options.limit - The maximum number of modules to retrieve (default is 1000).\n * @param args.options.offset - The starting point for pagination.  Note, this is obfuscated and is not an index.\n * @param args.options.ledgerVersion - The specific ledger version to query.\n * @group Implementation\n */\nexport async function getModules(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: { limit?: number } & LedgerVersionArg;\n}): Promise<MoveModuleBytecode[]> {\n  const { aptosConfig, accountAddress, options } = args;\n  return paginateWithObfuscatedCursor<{}, MoveModuleBytecode[]>({\n    aptosConfig,\n    originMethod: \"getModules\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/modules`,\n    params: {\n      ledger_version: options?.ledgerVersion,\n      limit: options?.limit ?? 1000,\n    },\n  });\n}\n\n/**\n * Retrieves the modules associated with a specified account address.\n *\n * @param args - The arguments for retrieving modules.\n * @param args.aptosConfig - The configuration for connecting to the Aptos blockchain.\n * @param args.accountAddress - The address of the account whose modules are to be retrieved.\n * @param args.options - Optional parameters for pagination and ledger version.\n * @param args.options.cursor - The starting point for pagination.  Note, this is obfuscated and is not an index.\n * @param args.options.limit - The maximum number of modules to retrieve (default is 100).\n * @param args.options.ledgerVersion - The specific ledger version to query.\n * @group Implementation\n */\nexport async function getModulesPage(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: CursorPaginationArgs & LedgerVersionArg;\n}): Promise<{ modules: MoveModuleBytecode[]; cursor: string | undefined }> {\n  const { aptosConfig, accountAddress, options } = args;\n  const { response, cursor } = await getPageWithObfuscatedCursor<{}, MoveModuleBytecode[]>({\n    aptosConfig,\n    originMethod: \"getModulesPage\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/modules`,\n    params: {\n      ledger_version: options?.ledgerVersion,\n      cursor: options?.cursor,\n      limit: options?.limit ?? 100,\n    },\n  });\n\n  return { modules: response.data, cursor };\n}\n\n/**\n * Queries for a move module given an account address and module name.\n * This function can help you retrieve the module's ABI and other relevant information.\n *\n * @param args - The arguments for retrieving the module.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.accountAddress - The account address in hex-encoded 32 byte format.\n * @param args.moduleName - The name of the module to retrieve.\n * @param args.options - Optional parameters for the request.\n * @param args.options.ledgerVersion - Specifies the ledger version of transactions. By default, the latest version will be used.\n * @returns The move module.\n * @group Implementation\n */\nexport async function getModule(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  moduleName: string;\n  options?: LedgerVersionArg;\n}): Promise<MoveModuleBytecode> {\n  return getModuleUtil(args);\n}\n\n/**\n * Retrieves a list of transactions associated with a specific account address.\n * This function allows you to paginate through the transactions for better performance and usability.\n *\n * @param args - The arguments for retrieving transactions.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.accountAddress - The account address for which to retrieve transactions.\n * @param args.options - Optional pagination parameters.\n * @param args.options.offset - The starting point for pagination.\n * @param args.options.limit - The maximum number of transactions to retrieve.\n * @group Implementation\n */\nexport async function getTransactions(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs;\n}): Promise<TransactionResponse[]> {\n  const { aptosConfig, accountAddress, options } = args;\n  return paginateWithCursor<{}, TransactionResponse[]>({\n    aptosConfig,\n    originMethod: \"getTransactions\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/transactions`,\n    params: { start: options?.offset, limit: options?.limit },\n  });\n}\n\n/**\n * Retrieves a list of resources associated with a specific account address.\n *\n * @param args - The arguments for retrieving resources.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.accountAddress - The address of the account to fetch resources for.\n * @param args.options - Optional pagination and ledger version parameters.\n * @param args.options.limit - The maximum number of resources to retrieve (default is 999).\n * @param args.options.ledgerVersion - The specific ledger version to query.\n * @group Implementation\n */\nexport async function getResources(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: { limit?: number } & LedgerVersionArg;\n}): Promise<MoveResource[]> {\n  const { aptosConfig, accountAddress, options } = args;\n  return paginateWithObfuscatedCursor<{}, MoveResource[]>({\n    aptosConfig,\n    originMethod: \"getResources\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/resources`,\n    params: {\n      ledger_version: options?.ledgerVersion,\n      limit: options?.limit ?? 999,\n    },\n  });\n}\n\n/**\n * Retrieves a page of resources associated with a specific account address.\n *\n * @param args - The arguments for retrieving resources.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.accountAddress - The address of the account to fetch resources for.\n * @param args.options - Optional pagination and ledger version parameters.\n * @param args.options.cursor - The starting point for pagination.  Note, this is obfuscated and is not an index.\n * @param args.options.limit - The maximum number of resources to retrieve (default is 100).\n * @param args.options.ledgerVersion - The specific ledger version to query.\n * @group Implementation\n */\nexport async function getResourcesPage(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: CursorPaginationArgs & LedgerVersionArg;\n}): Promise<{ resources: MoveResource[]; cursor: string | undefined }> {\n  const { aptosConfig, accountAddress, options } = args;\n  const { response, cursor } = await getPageWithObfuscatedCursor<{}, MoveResource[]>({\n    aptosConfig,\n    originMethod: \"getResourcesPage\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/resources`,\n    params: {\n      ledger_version: options?.ledgerVersion,\n      cursor: options?.cursor,\n      limit: options?.limit ?? 100,\n    },\n  });\n\n  return { resources: response.data, cursor };\n}\n\n/**\n * Retrieves a specific resource of a given type for the specified account address.\n *\n * @param args - The arguments for retrieving the resource.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.accountAddress - The address of the account from which to retrieve the resource.\n * @param args.resourceType - The type of the resource to retrieve, specified as a MoveStructId.\n * @param args.options - Optional parameters for specifying the ledger version.\n * @group Implementation\n */\nexport async function getResource<T extends {}>(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  resourceType: MoveStructId;\n  options?: LedgerVersionArg;\n}): Promise<T> {\n  const { aptosConfig, accountAddress, resourceType, options } = args;\n  const { data } = await getAptosFullNode<{}, MoveResource>({\n    aptosConfig,\n    originMethod: \"getResource\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/resource/${resourceType}`,\n    params: { ledger_version: options?.ledgerVersion },\n  });\n  return data.data as T;\n}\n\n/**\n * Retrieves the original account address associated with a given authentication key, which is useful for handling key rotations.\n *\n * @param args - The arguments for the lookup.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.authenticationKey - The authentication key for which to look up the original address.\n * @param args.options - Optional parameters for specifying the ledger version.\n * @returns The original account address or the provided authentication key address if not found.\n * @throws Throws an error if the lookup fails for reasons other than the address not being found.\n * @group Implementation\n */\nexport async function lookupOriginalAccountAddress(args: {\n  aptosConfig: AptosConfig;\n  authenticationKey: AccountAddressInput;\n  options?: LedgerVersionArg;\n}): Promise<AccountAddress> {\n  const { aptosConfig, authenticationKey, options } = args;\n  type OriginatingAddress = {\n    address_map: { handle: string };\n  };\n  const resource = await getResource<OriginatingAddress>({\n    aptosConfig,\n    accountAddress: \"0x1\",\n    resourceType: \"0x1::account::OriginatingAddress\",\n    options,\n  });\n\n  const {\n    address_map: { handle },\n  } = resource;\n\n  const authKeyAddress = AccountAddress.from(authenticationKey);\n\n  // If the address is not found in the address map, which means its not rotated\n  // then return the address as is\n  try {\n    const originalAddress = await getTableItem<string>({\n      aptosConfig,\n      handle,\n      data: {\n        key: authKeyAddress.toString(),\n        key_type: \"address\",\n        value_type: \"address\",\n      },\n      options,\n    });\n\n    return AccountAddress.from(originalAddress);\n  } catch (err) {\n    if (err instanceof AptosApiError && err.data.error_code === \"table_item_not_found\") {\n      return authKeyAddress;\n    }\n\n    throw err;\n  }\n}\n\n/**\n * Retrieves the count of tokens owned by a specific account address.\n *\n * @param args - The arguments for retrieving the account tokens count.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.accountAddress - The address of the account for which to count the tokens.\n * @returns The count of tokens owned by the specified account.\n * @group Implementation\n */\nexport async function getAccountTokensCount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress } = args;\n\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string }; amount: { _gt: number } } = {\n    owner_address: { _eq: address },\n    amount: { _gt: 0 },\n  };\n\n  const graphqlQuery = {\n    query: GetAccountTokensCount,\n    variables: { where_condition: whereCondition },\n  };\n\n  const data = await queryIndexer<GetAccountTokensCountQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountTokensCount\",\n  });\n\n  // commonjs (aka cjs) doesn't handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return data.current_token_ownerships_v2_aggregate.aggregate\n    ? data.current_token_ownerships_v2_aggregate.aggregate.count\n    : 0;\n}\n\n/**\n * Retrieves the tokens owned by a specified account address.\n *\n * @param args - The arguments for retrieving the account's tokens.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.accountAddress - The address of the account whose tokens are being queried.\n * @param args.options - Optional parameters for filtering and pagination.\n * @param args.options.tokenStandard - The specific token standard to filter the results.\n * @param args.options.offset - The number of records to skip before starting to collect the result set.\n * @param args.options.limit - The maximum number of records to return.\n * @param args.options.orderBy - The criteria for ordering the results.\n * @returns A promise that resolves to the current token ownerships of the specified account.\n * @group Implementation\n */\nexport async function getAccountOwnedTokens(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensQueryResponse[0]>;\n}): Promise<GetAccountOwnedTokensQueryResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string }; amount: { _gt: number }; token_standard?: { _eq: string } } =\n    {\n      owner_address: { _eq: address },\n      amount: { _gt: 0 },\n    };\n\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountOwnedTokens,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountOwnedTokensQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedTokens\",\n  });\n\n  return data.current_token_ownerships_v2;\n}\n\n/**\n * Retrieves the tokens owned by a specific account from a particular collection address.\n *\n * @param args - The parameters required to fetch the owned tokens.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.accountAddress - The address of the account whose tokens are being queried.\n * @param args.collectionAddress - The address of the collection from which tokens are being retrieved.\n * @param args.options - Optional parameters for filtering and pagination, including token standard, pagination arguments, and\n * order by options.\n * @group Implementation\n */\nexport async function getAccountOwnedTokensFromCollectionAddress(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  collectionAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensFromCollectionResponse[0]>;\n}): Promise<GetAccountOwnedTokensFromCollectionResponse> {\n  const { aptosConfig, accountAddress, collectionAddress, options } = args;\n  const ownerAddress = AccountAddress.from(accountAddress).toStringLong();\n  const collAddress = AccountAddress.from(collectionAddress).toStringLong();\n\n  const whereCondition: {\n    owner_address: { _eq: string };\n    current_token_data: { collection_id: { _eq: string } };\n    amount: { _gt: number };\n    token_standard?: { _eq: string };\n  } = {\n    owner_address: { _eq: ownerAddress },\n    current_token_data: { collection_id: { _eq: collAddress } },\n    amount: { _gt: 0 },\n  };\n\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountOwnedTokensFromCollection,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountOwnedTokensFromCollectionQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedTokensFromCollectionAddress\",\n  });\n\n  return data.current_token_ownerships_v2;\n}\n\n/**\n * Retrieves the collections owned by a specified account along with the tokens in those collections.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.accountAddress - The address of the account whose collections are being queried.\n * @param args.options - Optional parameters for filtering and pagination.\n * @param args.options.tokenStandard - An optional token standard to filter the collections.\n * @param args.options.offset - An optional offset for pagination.\n * @param args.options.limit - An optional limit for the number of results returned.\n * @param args.options.orderBy - An optional parameter to specify the order of the results.\n * @group Implementation\n */\nexport async function getAccountCollectionsWithOwnedTokens(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountCollectionsWithOwnedTokenResponse[0]>;\n}): Promise<GetAccountCollectionsWithOwnedTokenResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: {\n    owner_address: { _eq: string };\n    current_collection?: { token_standard: { _eq: string } };\n  } = {\n    owner_address: { _eq: address },\n  };\n\n  if (options?.tokenStandard) {\n    whereCondition.current_collection = {\n      token_standard: { _eq: options?.tokenStandard },\n    };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountCollectionsWithOwnedTokens,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountCollectionsWithOwnedTokensQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCollectionsWithOwnedTokens\",\n  });\n\n  return data.current_collection_ownership_v2_view;\n}\n\n/**\n * Retrieves the count of transactions associated with a specified account.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.accountAddress - The address of the account for which to retrieve the transaction count.\n * @returns The number of transactions associated with the specified account.\n * @group Implementation\n */\nexport async function getAccountTransactionsCount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress } = args;\n\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const graphqlQuery = {\n    query: GetAccountTransactionsCount,\n    variables: { address },\n  };\n\n  const data = await queryIndexer<GetAccountTransactionsCountQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountTransactionsCount\",\n  });\n\n  // commonjs (aka cjs) doesn't handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return data.account_transactions_aggregate.aggregate ? data.account_transactions_aggregate.aggregate.count : 0;\n}\n\n/**\n * Retrieves the amount of a specific coin held by an account.\n *\n * @param args - The parameters for the request.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.accountAddress - The address of the account to query.\n * @param args.coinType - Optional; the type of coin to check the amount for.\n * @param args.faMetadataAddress - Optional; the address of the fungible asset metadata.\n * @returns The amount of the specified coin held by the account, or 0 if none is found.\n * @throws Error if neither coinType nor faMetadataAddress is provided.\n * @group Implementation\n */\nexport async function getAccountCoinAmount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  coinType?: MoveStructId;\n  faMetadataAddress?: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress, coinType, faMetadataAddress } = args;\n\n  let coinAssetType: string | undefined = coinType;\n  let faAddress: string;\n\n  if (coinType !== undefined && faMetadataAddress !== undefined) {\n    faAddress = AccountAddress.from(faMetadataAddress).toStringLong();\n  } else if (coinType !== undefined && faMetadataAddress === undefined) {\n    // TODO Move to a separate function as defined in the AIP for coin migration\n    if (coinType === APTOS_COIN) {\n      faAddress = AccountAddress.A.toStringLong();\n    } else {\n      faAddress = createObjectAddress(AccountAddress.A, coinType).toStringLong();\n    }\n  } else if (coinType === undefined && faMetadataAddress !== undefined) {\n    const addr = AccountAddress.from(faMetadataAddress);\n    faAddress = addr.toStringLong();\n    if (addr === AccountAddress.A) {\n      coinAssetType = APTOS_COIN;\n    }\n    // The paired CoinType should be populated outside of this function in another\n    // async call. We cannot do this internally due to dependency cycles issue.\n  } else {\n    throw new Error(\"Either coinType, fungibleAssetAddress, or both must be provided\");\n  }\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  // Search by fungible asset address, unless it has a coin it migrated from\n  let where: any = { asset_type: { _eq: faAddress } };\n  if (coinAssetType !== undefined) {\n    where = { asset_type: { _in: [coinAssetType, faAddress] } };\n  }\n\n  const data = await getAccountCoinsData({\n    aptosConfig,\n    accountAddress: address,\n    options: {\n      where,\n    },\n  });\n\n  // commonjs (aka cjs) doesn't handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return data[0] ? data[0].amount : 0;\n}\n\n/**\n * Retrieves the current fungible asset balances for a specified account.\n *\n * @param args - The arguments for retrieving account coins data.\n * @param args.aptosConfig - The configuration for connecting to the Aptos network.\n * @param args.accountAddress - The address of the account for which to retrieve coin data.\n * @param args.options - Optional parameters for pagination and filtering the results.\n * @param args.options.offset - The number of items to skip before starting to collect the result set.\n * @param args.options.limit - The maximum number of items to return.\n * @param args.options.orderBy - The criteria for ordering the results.\n * @param args.options.where - Conditions to filter the results based on the current fungible asset balances.\n * @group Implementation\n */\nexport async function getAccountCoinsData(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & OrderByArg<GetAccountCoinsDataResponse[0]> & WhereArg<CurrentFungibleAssetBalancesBoolExp>;\n}): Promise<GetAccountCoinsDataResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string } } = {\n    ...options?.where,\n    owner_address: { _eq: address },\n  };\n\n  const graphqlQuery = {\n    query: GetAccountCoinsData,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountCoinsDataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCoinsData\",\n  });\n\n  return data.current_fungible_asset_balances;\n}\n\n/**\n * Retrieves the count of fungible asset coins held by a specified account.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.accountAddress - The address of the account for which to retrieve the coin count.\n * @throws Error if the count of account coins cannot be retrieved.\n * @group Implementation\n */\nexport async function getAccountCoinsCount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const graphqlQuery = {\n    query: GetAccountCoinsCount,\n    variables: { address },\n  };\n\n  const data = await queryIndexer<GetAccountCoinsCountQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCoinsCount\",\n  });\n\n  if (!data.current_fungible_asset_balances_aggregate.aggregate) {\n    throw Error(\"Failed to get the count of account coins\");\n  }\n\n  return data.current_fungible_asset_balances_aggregate.aggregate.count;\n}\n\n/**\n * Retrieves the objects owned by a specified account.\n *\n * @param args - The parameters for the request.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.accountAddress - The address of the account whose owned objects are to be retrieved.\n * @param args.options - Optional parameters for pagination and ordering of the results.\n * @param args.options.offset - The number of items to skip before starting to collect the result set.\n * @param args.options.limit - The maximum number of items to return.\n * @param args.options.orderBy - The criteria to order the results by.\n * @returns A promise that resolves to the current objects owned by the specified account.\n * @group Implementation\n */\nexport async function getAccountOwnedObjects(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & OrderByArg<GetObjectDataQueryResponse[0]>;\n}): Promise<GetObjectDataQueryResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string } } = {\n    owner_address: { _eq: address },\n  };\n  const graphqlQuery = {\n    query: GetObjectData,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n  const data = await queryIndexer<GetObjectDataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedObjects\",\n  });\n\n  return data.current_objects;\n}\n\n/**\n * Derives an account from the provided private key and Aptos configuration.\n * This function helps in obtaining the account details associated with a given private key,\n * considering both unified and legacy authentication schemes.\n *\n * NOTE: There is a potential issue once the unified single signer scheme is adopted by the community.\n * Because one could create two accounts with the same private key with this new authenticator type,\n * weâll need to determine the order in which we look up the accounts: first unified scheme and then legacy scheme,\n * or first legacy scheme and then unified scheme.\n *\n * @param args - The arguments for deriving the account.\n * @param args.aptosConfig - The Aptos configuration used for account lookup.\n * @param args.privateKey - The private key used to derive the account.\n * @throws Error if the account cannot be derived from the private key.\n * @group Implementation\n * @deprecated Note that more inspection is needed by the user to determine which account exists on-chain\n */\nexport async function deriveAccountFromPrivateKey(args: {\n  aptosConfig: AptosConfig;\n  privateKey: PrivateKey;\n}): Promise<Account> {\n  const { aptosConfig, privateKey } = args;\n  const publicKey = new AnyPublicKey(privateKey.publicKey());\n\n  if (privateKey instanceof Secp256k1PrivateKey) {\n    // private key is secp256k1, therefore we know it for sure uses a single signer key\n    const authKey = AuthenticationKey.fromPublicKey({ publicKey });\n    const address = authKey.derivedAddress();\n    return Account.fromPrivateKey({ privateKey, address });\n  }\n\n  if (privateKey instanceof Ed25519PrivateKey) {\n    // lookup legacy ed25519\n    const legacyAuthKey = AuthenticationKey.fromPublicKey({\n      publicKey: publicKey.publicKey as Ed25519PublicKey,\n    });\n    const isLegacyEd25519 = await isAccountExist({ authKey: legacyAuthKey, aptosConfig });\n    if (isLegacyEd25519) {\n      const address = legacyAuthKey.derivedAddress();\n      return Account.fromPrivateKey({ privateKey, address, legacy: true });\n    }\n    // lookup single sender ed25519\n    const singleSenderTransactionAuthenticatorAuthKey = AuthenticationKey.fromPublicKey({\n      publicKey,\n    });\n    const isSingleSenderTransactionAuthenticator = await isAccountExist({\n      authKey: singleSenderTransactionAuthenticatorAuthKey,\n      aptosConfig,\n    });\n    if (isSingleSenderTransactionAuthenticator) {\n      const address = singleSenderTransactionAuthenticatorAuthKey.derivedAddress();\n      return Account.fromPrivateKey({ privateKey, address, legacy: false });\n    }\n  }\n  // if we are here, it means we couldn't find an address with an\n  // auth key that matches the provided private key\n  throw new Error(`Can't derive account from private key ${privateKey}`);\n}\n\n/**\n * Checks if an account exists by verifying its information against the Aptos blockchain.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration for connecting to the Aptos blockchain.\n * @param args.authKey - The authentication key used to derive the account address.\n * @returns A promise that resolves to a boolean indicating whether the account exists.\n *\n * @throws Throws an Error if there is an issue while looking for account information.\n * @group Implementation\n */\nexport async function isAccountExist(args: { aptosConfig: AptosConfig; authKey: AuthenticationKey }): Promise<boolean> {\n  const { aptosConfig, authKey } = args;\n  const accountAddress = await lookupOriginalAccountAddress({\n    aptosConfig,\n    authenticationKey: authKey.derivedAddress(),\n  });\n\n  try {\n    await getInfo({\n      aptosConfig,\n      accountAddress,\n    });\n    return true;\n  } catch (error: any) {\n    // account not found\n    if (error.status === 404) {\n      return false;\n    }\n    throw new Error(`Error while looking for an account info ${accountAddress.toString()}`);\n  }\n}\n\nconst rotateAuthKeyAbi: EntryFunctionABI = {\n  typeParameters: [],\n  parameters: [\n    new TypeTagU8(),\n    TypeTagVector.u8(),\n    new TypeTagU8(),\n    TypeTagVector.u8(),\n    TypeTagVector.u8(),\n    TypeTagVector.u8(),\n  ],\n};\n\n/**\n * Rotates the authentication key for a given account.\n *\n * @param args - The arguments for rotating the authentication key.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.fromAccount - The account from which the authentication key will be rotated.\n * @param args.toAccount - (Optional) The target account to rotate to. Required if not using toNewPrivateKey or toAuthKey.\n * @param args.toNewPrivateKey - (Optional) The new private key to rotate to. Required if not using toAccount or toAuthKey.\n * @param args.toAuthKey - (Optional) The new authentication key to rotate to. Can only be used with dangerouslySkipVerification=true.\n * @param args.dangerouslySkipVerification - (Optional) If true, skips verification steps after rotation. Required when using toAuthKey.\n *\n * @remarks\n * This function supports three modes of rotation:\n * 1. Using a target Account object (toAccount)\n * 2. Using a new private key (toNewPrivateKey)\n * 3. Using a raw authentication key (toAuthKey) - requires dangerouslySkipVerification=true\n *\n * When not using dangerouslySkipVerification, the function performs additional safety checks and account setup.\n *\n * If the new key is a multi key, skipping verification is dangerous because verification will publish the public key onchain and\n * prevent users from being locked out of the account from loss of knowledge of one of the public keys.\n *\n * @returns A promise that resolves to the pending transaction response.\n * @throws Error if the rotation fails or verification fails.\n *\n * @group Implementation\n */\nexport async function rotateAuthKey(\n  args: {\n    aptosConfig: AptosConfig;\n    fromAccount: Account;\n  } & (\n    | { toAccount: Account; dangerouslySkipVerification?: never }\n    | { toNewPrivateKey: Ed25519PrivateKey; dangerouslySkipVerification?: never }\n    | { toAuthKey: AuthenticationKey; dangerouslySkipVerification: true }\n  ),\n): Promise<PendingTransactionResponse> {\n  const { aptosConfig, fromAccount, dangerouslySkipVerification } = args;\n  if (\"toNewPrivateKey\" in args) {\n    return rotateAuthKeyWithChallenge({\n      aptosConfig,\n      fromAccount,\n      toNewPrivateKey: args.toNewPrivateKey,\n    });\n  }\n  let authKey: AuthenticationKey;\n  if (\"toAccount\" in args) {\n    if (args.toAccount instanceof Ed25519Account) {\n      return rotateAuthKeyWithChallenge({ aptosConfig, fromAccount, toNewPrivateKey: args.toAccount.privateKey });\n    }\n    if (args.toAccount instanceof MultiEd25519Account) {\n      return rotateAuthKeyWithChallenge({ aptosConfig, fromAccount, toAccount: args.toAccount });\n    }\n    authKey = args.toAccount.publicKey.authKey();\n  } else if (\"toAuthKey\" in args) {\n    authKey = args.toAuthKey;\n  } else {\n    throw new Error(\"Invalid arguments\");\n  }\n\n  const pendingTxn = await rotateAuthKeyUnverified({\n    aptosConfig,\n    fromAccount,\n    toAuthKey: authKey,\n  });\n\n  if (dangerouslySkipVerification === true) {\n    return pendingTxn;\n  }\n\n  const rotateAuthKeyTxnResponse = await waitForTransaction({\n    aptosConfig,\n    transactionHash: pendingTxn.hash,\n  });\n  if (!rotateAuthKeyTxnResponse.success) {\n    throw new Error(`Failed to rotate authentication key - ${rotateAuthKeyTxnResponse}`);\n  }\n\n  // Verify the rotation by setting the originating address to the new account.\n  // This verifies the rotation even if the transaction payload fails to execute successfully.\n  const verificationTxn = await generateTransaction({\n    aptosConfig,\n    sender: fromAccount.accountAddress,\n    data: {\n      function: \"0x1::account::set_originating_address\",\n      functionArguments: [],\n    },\n  });\n\n  return signAndSubmitTransaction({\n    aptosConfig,\n    signer: args.toAccount, // Use the new account to sign\n    transaction: verificationTxn,\n  });\n}\n\nasync function rotateAuthKeyWithChallenge(\n  args: {\n    aptosConfig: AptosConfig;\n    fromAccount: Account;\n  } & ({ toNewPrivateKey: Ed25519PrivateKey } | { toAccount: MultiEd25519Account }),\n): Promise<PendingTransactionResponse> {\n  const { aptosConfig, fromAccount } = args;\n  const accountInfo = await getInfo({\n    aptosConfig,\n    accountAddress: fromAccount.accountAddress,\n  });\n\n  let newAccount: Account;\n  if (\"toNewPrivateKey\" in args) {\n    newAccount = Account.fromPrivateKey({ privateKey: args.toNewPrivateKey, legacy: true });\n  } else {\n    newAccount = args.toAccount;\n  }\n\n  const challenge = new RotationProofChallenge({\n    sequenceNumber: BigInt(accountInfo.sequence_number),\n    originator: fromAccount.accountAddress,\n    currentAuthKey: AccountAddress.from(accountInfo.authentication_key),\n    newPublicKey: newAccount.publicKey,\n  });\n\n  // Sign the challenge\n  const challengeHex = challenge.bcsToBytes();\n  const proofSignedByCurrentKey = fromAccount.sign(challengeHex);\n  const proofSignedByNewKey = newAccount.sign(challengeHex);\n\n  // Generate transaction\n  const rawTxn = await generateTransaction({\n    aptosConfig,\n    sender: fromAccount.accountAddress,\n    data: {\n      function: \"0x1::account::rotate_authentication_key\",\n      functionArguments: [\n        new U8(fromAccount.signingScheme), // from scheme\n        MoveVector.U8(fromAccount.publicKey.toUint8Array()),\n        new U8(newAccount.signingScheme), // to scheme\n        MoveVector.U8(newAccount.publicKey.toUint8Array()),\n        MoveVector.U8(proofSignedByCurrentKey.toUint8Array()),\n        MoveVector.U8(proofSignedByNewKey.toUint8Array()),\n      ],\n      abi: rotateAuthKeyAbi,\n    },\n  });\n  return signAndSubmitTransaction({\n    aptosConfig,\n    signer: fromAccount,\n    transaction: rawTxn,\n  });\n}\n\nconst rotateAuthKeyUnverifiedAbi: EntryFunctionABI = {\n  typeParameters: [],\n  parameters: [TypeTagVector.u8()],\n};\n\nasync function rotateAuthKeyUnverified(args: {\n  aptosConfig: AptosConfig;\n  fromAccount: Account;\n  toAuthKey: AuthenticationKey;\n}): Promise<PendingTransactionResponse> {\n  const { aptosConfig, fromAccount, toAuthKey } = args;\n  const authKey = toAuthKey;\n  const rawTxn = await generateTransaction({\n    aptosConfig,\n    sender: fromAccount.accountAddress,\n    data: {\n      function: \"0x1::account::rotate_authentication_key_call\",\n      functionArguments: [MoveVector.U8(authKey.toUint8Array())],\n      abi: rotateAuthKeyUnverifiedAbi,\n    },\n  });\n  return signAndSubmitTransaction({\n    aptosConfig,\n    signer: fromAccount,\n    transaction: rawTxn,\n  });\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { LedgerVersionArg, MimeType, MoveValue } from \"../types\";\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport {\n  generateViewFunctionPayload,\n  InputViewFunctionData,\n  InputViewFunctionJsonData,\n  ViewFunctionJsonPayload,\n} from \"../transactions\";\nimport { Serializer } from \"../bcs\";\nimport { postAptosFullNode } from \"../client\";\n\nexport async function view<T extends Array<MoveValue> = Array<MoveValue>>(args: {\n  aptosConfig: AptosConfig;\n  payload: InputViewFunctionData;\n  options?: LedgerVersionArg;\n}): Promise<T> {\n  const { aptosConfig, payload, options } = args;\n  const viewFunctionPayload = await generateViewFunctionPayload({\n    ...payload,\n    aptosConfig,\n  });\n\n  const serializer = new Serializer();\n  viewFunctionPayload.serialize(serializer);\n  const bytes = serializer.toUint8Array();\n\n  const { data } = await postAptosFullNode<Uint8Array, MoveValue[]>({\n    aptosConfig,\n    path: \"view\",\n    originMethod: \"view\",\n    contentType: MimeType.BCS_VIEW_FUNCTION,\n    params: { ledger_version: options?.ledgerVersion },\n    body: bytes,\n  });\n\n  return data as T;\n}\n\nexport async function viewJson<T extends Array<MoveValue> = Array<MoveValue>>(args: {\n  aptosConfig: AptosConfig;\n  payload: InputViewFunctionJsonData;\n  options?: LedgerVersionArg;\n}): Promise<T> {\n  const { aptosConfig, payload, options } = args;\n  const { data } = await postAptosFullNode<ViewFunctionJsonPayload, MoveValue[]>({\n    aptosConfig,\n    originMethod: \"viewJson\",\n    path: \"view\",\n    params: { ledger_version: options?.ledgerVersion },\n    body: {\n      function: payload.function,\n      type_arguments: payload.typeArguments ?? [],\n      arguments: payload.functionArguments ?? [],\n    },\n  });\n\n  return data as T;\n}\n","import {\n  SimpleTransaction,\n  InputGenerateTransactionOptions,\n  TypeTagAddress,\n  TypeTagStruct,\n  stringStructTag,\n} from \"../transactions\";\nimport { AccountAddressInput } from \"../core\";\nimport { generateTransaction } from \"./transactionSubmission\";\nimport { MoveFunctionId } from \"../types\";\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { getFunctionParts } from \"../utils/helpers\";\n\nexport async function addAuthenticationFunctionTransaction(args: {\n  aptosConfig: AptosConfig;\n  sender: AccountAddressInput;\n  authenticationFunction: string;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, sender, authenticationFunction, options } = args;\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(authenticationFunction as MoveFunctionId);\n  return generateTransaction({\n    aptosConfig,\n    sender,\n    data: {\n      function: \"0x1::account_abstraction::add_authentication_function\",\n      typeArguments: [],\n      functionArguments: [moduleAddress, moduleName, functionName],\n      abi: {\n        typeParameters: [],\n        parameters: [new TypeTagAddress(), new TypeTagStruct(stringStructTag()), new TypeTagStruct(stringStructTag())],\n      },\n    },\n    options,\n  });\n}\n\nexport async function removeAuthenticationFunctionTransaction(args: {\n  aptosConfig: AptosConfig;\n  sender: AccountAddressInput;\n  authenticationFunction: string;\n  options?: InputGenerateTransactionOptions;\n}) {\n  const { aptosConfig, sender, authenticationFunction, options } = args;\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(authenticationFunction as MoveFunctionId);\n  return generateTransaction({\n    aptosConfig,\n    sender,\n    data: {\n      function: \"0x1::account_abstraction::remove_authentication_function\",\n      typeArguments: [],\n      functionArguments: [moduleAddress, moduleName, functionName],\n      abi: {\n        typeParameters: [],\n        parameters: [new TypeTagAddress(), new TypeTagStruct(stringStructTag()), new TypeTagStruct(stringStructTag())],\n      },\n    },\n    options,\n  });\n}\n\nexport async function removeDispatchableAuthenticatorTransaction(args: {\n  aptosConfig: AptosConfig;\n  sender: AccountAddressInput;\n  options?: InputGenerateTransactionOptions;\n}) {\n  const { aptosConfig, sender, options } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender,\n    data: {\n      function: \"0x1::account_abstraction::remove_authenticator\",\n      typeArguments: [],\n      functionArguments: [],\n      abi: { typeParameters: [], parameters: [] },\n    },\n    options,\n  });\n}\n","import { AccountAddress, AccountAddressInput } from \"../../core\";\nimport {\n  addAuthenticationFunctionTransaction,\n  removeAuthenticationFunctionTransaction,\n  removeDispatchableAuthenticatorTransaction,\n} from \"../../internal/abstraction\";\nimport { view } from \"../../internal/view\";\nimport { InputGenerateTransactionOptions, TypeTagAddress } from \"../../transactions\";\nimport { MoveFunctionId } from \"../../types\";\nimport { getFunctionParts } from \"../../utils/helpers\";\nimport { AptosConfig } from \"../aptosConfig\";\n\nexport class AccountAbstraction {\n  constructor(readonly config: AptosConfig) {}\n\n  /**\n   * Adds a dispatchable authentication function to the account.\n   *\n   * @example\n   * ```ts\n   * const txn = await aptos.abstraction.addAuthenticationFunctionTransaction({\n   *   accountAddress: alice.accountAddress,\n   *   authenticationFunction: `${alice.accountAddress}::any_authenticator::authenticate`,\n   * });\n   *\n   * const txn =  await aptos.signAndSubmitTransaction({ signer: alice, transaction});\n   * await aptos.waitForTransaction({ transactionHash: txn.hash });\n   * ```\n   *\n   * @param args.accountAddress - The account to add the authentication function to.\n   * @param args.authenticationFunction - The authentication function info to add.\n   * @param args.options - The options for the transaction.\n   * @returns A transaction to add the authentication function to the account.\n   */\n  public async addAuthenticationFunctionTransaction(args: {\n    accountAddress: AccountAddressInput;\n    authenticationFunction: string;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    const { accountAddress, authenticationFunction, options } = args;\n    return addAuthenticationFunctionTransaction({\n      aptosConfig: this.config,\n      authenticationFunction,\n      sender: accountAddress,\n      options,\n    });\n  }\n\n  /**\n   * Removes a dispatchable authentication function from the account.\n   *\n   * @example\n   * ```ts\n   * const txn = await aptos.abstraction.removeAuthenticationFunctionTransaction({\n   *   accountAddress: alice.accountAddress,\n   *   authenticationFunction: `${alice.accountAddress}::any_authenticator::authenticate`,\n   * });\n   *\n   * const txn = await aptos.signAndSubmitTransaction({ signer: alice, transaction: txn });\n   * await aptos.waitForTransaction({ transactionHash: txn.hash });\n   * ```\n   *\n   * @param args.accountAddress - The account to remove the authentication function from.\n   * @param args.authenticationFunction - The authentication function info to remove.\n   * @param args.options - The options for the transaction.\n   * @returns A transaction to remove the authentication function from the account.\n   */\n  public async removeAuthenticationFunctionTransaction(args: {\n    accountAddress: AccountAddressInput;\n    authenticationFunction: string;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    const { accountAddress, authenticationFunction, options } = args;\n    return removeAuthenticationFunctionTransaction({\n      aptosConfig: this.config,\n      sender: accountAddress,\n      authenticationFunction,\n      options,\n    });\n  }\n\n  /**\n   * Removes a dispatchable authenticator from the account.\n   *\n   * @example\n   * ```ts\n   * const txn = await aptos.abstraction.removeDispatchableAuthenticatorTransaction({\n   *   accountAddress: alice.accountAddress,\n   * });\n   *\n   * const txn = await aptos.signAndSubmitTransaction({ signer: alice, transaction: txn });\n   * await aptos.waitForTransaction({ transactionHash: txn.hash });\n   * ```\n   *\n   * @param args.accountAddress - The account to remove the authenticator from.\n   * @param args.options - The options for the transaction.\n   * @returns A transaction to remove the authenticator from the account.\n   */\n  public async removeDispatchableAuthenticatorTransaction(args: {\n    accountAddress: AccountAddressInput;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    const { accountAddress, options } = args;\n    return removeDispatchableAuthenticatorTransaction({ aptosConfig: this.config, sender: accountAddress, options });\n  }\n\n  /**\n   * Gets the dispatchable authentication function for the account.\n   *\n   * @example\n   * ```ts\n   * const functionInfos = await aptos.abstraction.getAuthenticationFunction({\n   *   accountAddress: alice.accountAddress,\n   * });\n   *\n   * if (functionInfos) {\n   *   console.log(`Account ${alice.accountAddress.toString()} is using account abstraction!`);\n   * } else {\n   *   console.log(`Account ${alice.accountAddress.toString()} is not using account abstraction.`);\n   * }\n   * ```\n   *\n   * @param args.accountAddress - The account to get the dispatchable authentication function for.\n   * @returns The dispatchable authentication function for the account.\n   */\n  public async getAuthenticationFunction(args: { accountAddress: AccountAddressInput }) {\n    const { accountAddress } = args;\n    const [{ vec: functionInfoOption }] = await view<\n      [{ vec: { function_name: string; module_name: string; module_address: string }[][] }]\n    >({\n      aptosConfig: this.config,\n      payload: {\n        function: \"0x1::account_abstraction::dispatchable_authenticator\",\n        functionArguments: [AccountAddress.from(accountAddress)],\n        abi: { typeParameters: [], parameters: [new TypeTagAddress()], returnTypes: [] },\n      },\n    });\n\n    if (functionInfoOption.length === 0) return undefined;\n\n    return functionInfoOption[0].map((functionInfo) => ({\n      moduleAddress: AccountAddress.fromString(functionInfo.module_address),\n      moduleName: functionInfo.module_name,\n      functionName: functionInfo.function_name,\n    }));\n  }\n\n  /**\n   * Will return true if the account is abstracted, otherwise false.\n   *\n   * @example\n   * ```ts\n   * const isAccountAbstractionEnabled = await aptos.abstraction.isAccountAbstractionEnabled({\n   *   accountAddress: alice.accountAddress,\n   *   authenticationFunction: `${alice.accountAddress}::any_authenticator::authenticate`,\n   * });\n   * if (isAccountAbstractionEnabled) {\n   *   console.log(`Account ${alice.accountAddress.toString()} is using account abstraction!`);\n   * } else {\n   *   console.log(`Account ${alice.accountAddress.toString()} is not using account abstraction.`);\n   * }\n   * ```\n   *\n   * @param args.accountAddress - The account to check.\n   * @returns Whether the account is abstracted.\n   */\n  public isAccountAbstractionEnabled = async (args: {\n    accountAddress: AccountAddressInput;\n    authenticationFunction: string;\n  }) => {\n    const functionInfos = await this.getAuthenticationFunction(args);\n    const { moduleAddress, moduleName, functionName } = getFunctionParts(args.authenticationFunction as MoveFunctionId);\n    return (\n      functionInfos?.some(\n        (functionInfo) =>\n          AccountAddress.fromString(moduleAddress).equals(functionInfo.moduleAddress) &&\n          moduleName === functionInfo.moduleName &&\n          functionName === functionInfo.functionName,\n      ) ?? false\n    );\n  };\n\n  /**\n   * Creates a transaction to enable account abstraction with the given authentication function.\n   *\n   * @example\n   * ```ts\n   * const txn = await aptos.abstraction.enableAccountAbstractionTransaction({\n   *   accountAddress: alice.accountAddress,\n   *   authenticationFunction: `{alice.accountAddress}::any_authenticator::authenticate`,\n   * });\n   *\n   * const txn = await aptos.signAndSubmitTransaction({ signer: alice, transaction: txn });\n   * await aptos.waitForTransaction({ transactionHash: txn.hash });\n   * ```\n   *\n   * @param args.accountAddress - The account to enable account abstraction for.\n   * @param args.authenticationFunction - The authentication function info to use.\n   * @param args.options - The options for the transaction.\n   * @returns A transaction to enable account abstraction for the account.\n   */\n  public enableAccountAbstractionTransaction = this.addAuthenticationFunctionTransaction;\n\n  /**\n   * Creates a transaction to disable account abstraction. If an authentication function is provided, it will specify to\n   * remove the authentication function.\n   *\n   * @example\n   * ```ts\n   * const txn = await aptos.abstraction.disableAccountAbstractionTransaction({\n   *   accountAddress: alice.accountAddress,\n   *   authenticationFunction: `${alice.accountAddress}::any_authenticator::authenticate`,\n   * });\n   *\n   * const txn = await aptos.signAndSubmitTransaction({ signer: alice, transaction: txn });\n   * await aptos.waitForTransaction({ transactionHash: txn.hash });\n   * ```\n   *\n   * @param args.accountAddress - The account to disable account abstraction for.\n   * @param args.authenticationFunction - The authentication function info to remove.\n   * @param args.options - The options for the transaction.\n   * @returns A transaction to disable account abstraction for the account.\n   */\n  public disableAccountAbstractionTransaction = async (args: {\n    accountAddress: AccountAddressInput;\n    authenticationFunction?: string;\n    options?: InputGenerateTransactionOptions;\n  }) => {\n    const { accountAddress, authenticationFunction, options } = args;\n    if (authenticationFunction) {\n      return this.removeAuthenticationFunctionTransaction({\n        accountAddress,\n        authenticationFunction,\n        options,\n      });\n    }\n    return this.removeDispatchableAuthenticatorTransaction({ accountAddress, options });\n  };\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Account as AccountModule } from \"../account\";\nimport { AccountAddress, PrivateKey, AccountAddressInput, createObjectAddress } from \"../core\";\nimport {\n  AccountData,\n  AnyNumber,\n  CursorPaginationArgs,\n  GetAccountCoinsDataResponse,\n  GetAccountCollectionsWithOwnedTokenResponse,\n  GetAccountOwnedTokensFromCollectionResponse,\n  GetAccountOwnedTokensQueryResponse,\n  GetObjectDataQueryResponse,\n  LedgerVersionArg,\n  MoveModuleBytecode,\n  MoveResource,\n  MoveStructId,\n  MoveValue,\n  OrderByArg,\n  PaginationArgs,\n  TokenStandardArg,\n  TransactionResponse,\n  WhereArg,\n} from \"../types\";\nimport {\n  deriveAccountFromPrivateKey,\n  getAccountCoinsCount,\n  getAccountCoinsData,\n  getAccountCollectionsWithOwnedTokens,\n  getAccountOwnedObjects,\n  getAccountOwnedTokens,\n  getAccountOwnedTokensFromCollectionAddress,\n  getAccountTokensCount,\n  getAccountTransactionsCount,\n  getInfo,\n  getModule,\n  getModules,\n  getModulesPage,\n  getResource,\n  getResources,\n  getResourcesPage,\n  getTransactions,\n  lookupOriginalAccountAddress,\n} from \"../internal/account\";\nimport { APTOS_COIN, APTOS_FA, ProcessorType } from \"../utils/const\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { waitForIndexerOnVersion } from \"./utils\";\nimport { CurrentFungibleAssetBalancesBoolExp } from \"../types/generated/types\";\nimport { view } from \"../internal/view\";\nimport { isEncodedStruct, parseEncodedStruct } from \"../utils\";\nimport { memoizeAsync } from \"../utils/memoize\";\nimport { AccountAbstraction } from \"./account/abstraction\";\n\n/**\n * A class to query all `Account` related queries on Aptos.\n * @group Account\n */\nexport class Account {\n  abstraction: AccountAbstraction;\n\n  /**\n   * Creates an instance of the Aptos client with the provided configuration.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Initialize the Aptos client with testnet configuration\n   *     const config = new AptosConfig({ network: Network.TESTNET }); // specify your own network if needed\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  constructor(readonly config: AptosConfig) {\n    this.abstraction = new AccountAbstraction(config);\n  }\n\n  /**\n   * Queries the current state for an Aptos account given its account address.\n   *\n   * @param args - The arguments for retrieving account information.\n   * @param args.accountAddress - The Aptos account address to query.\n   * @returns The account data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *     // Retrieve account information for a specific address\n   *     const accountInfo = await aptos.getAccountInfo({ accountAddress: \"0x1\" }); // replace with a real account address\n   *     console.log(accountInfo);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountInfo(args: { accountAddress: AccountAddressInput }): Promise<AccountData> {\n    return getInfo({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries for all modules in an account given an account address.\n   * This function may call the API multiple times to auto paginate through results.\n   *\n   * @param args.accountAddress - The Aptos account address to query modules for.\n   * @param args.options.limit - The maximum number of results to return.\n   * @param args.options.ledgerVersion - The ledger version to query; if not provided, it retrieves the latest version.\n   *\n   * @returns - The account modules associated with the specified address.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching account modules for a specific account\n   *   const accountModules = await aptos.getAccountModules({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       limit: 10, // limiting to 10 modules\n   *     },\n   *   });\n   *\n   *   console.log(accountModules);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountModules(args: {\n    accountAddress: AccountAddressInput;\n    options?: { limit?: number } & LedgerVersionArg;\n  }): Promise<MoveModuleBytecode[]> {\n    return getModules({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries for a page of modules in an account given an account address.\n   *\n   * @param args.accountAddress - The Aptos account address to query modules for.\n   * @param args.options.cursor - The cursor to start returning results from.  Note, this is obfuscated and is not an index.\n   * @param args.options.limit - The maximum number of results to return.\n   * @param args.options.ledgerVersion - The ledger version to query; if not provided, it retrieves the latest version.\n   *\n   * @returns - The account modules associated with the specified address. Along with a cursor for future pagination. If the cursor is undefined, it means there are no more modules to fetch.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching account modules for a specific account\n   *   const {modules, cursor} = await aptos.getAccountModulesPage({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       cursor: undefined, // starting from the first module\n   *       limit: 10, // limiting to 10 modules\n   *     },\n   *   });\n   *\n   *   console.log(modules);\n   *   console.log(`More to fetch: ${cursor !== undefined}`);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountModulesPage(args: {\n    accountAddress: AccountAddressInput;\n    options?: CursorPaginationArgs & LedgerVersionArg;\n  }): Promise<{ modules: MoveModuleBytecode[]; cursor: string | undefined }> {\n    return getModulesPage({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries for a specific account module given an account address and module name.\n   *\n   * @param args.accountAddress - The Aptos account address.\n   * @param args.moduleName - The name of the module.\n   * @param args.options.ledgerVersion - The ledger version to query; if not provided, it will get the latest version.\n   *\n   * @returns The account module associated with the specified account address and module name.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the account module for a specific account address and module name\n   *   const module = await aptos.getAccountModule({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     moduleName: \"MyModule\" // specify the module name\n   *   });\n   *\n   *   console.log(module);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountModule(args: {\n    accountAddress: AccountAddressInput;\n    moduleName: string;\n    options?: LedgerVersionArg;\n  }): Promise<MoveModuleBytecode> {\n    return getModule({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries account transactions given an account address.\n   * This function may call the API multiple times to auto paginate and retrieve all account transactions.\n   *\n   * @param args.accountAddress - The Aptos account address to query transactions for.\n   * @param args.options - Optional pagination arguments.\n   * @param args.options.offset - The number of transactions to start returning results from.\n   * @param args.options.limit - The maximum number of results to return.\n   *\n   * @returns The account transactions.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetch transactions for a specific account\n   *   const transactions = await aptos.getAccountTransactions({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       offset: 0, // starting from the first transaction\n   *       limit: 10, // limiting to 10 transactions\n   *     },\n   *   });\n   *\n   *   console.log(transactions);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountTransactions(args: {\n    accountAddress: AccountAddressInput;\n    options?: PaginationArgs;\n  }): Promise<TransactionResponse[]> {\n    return getTransactions({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries all account resources given an account address.\n   * This function may call the API multiple times to auto paginate through results.\n   *\n   * @param args.accountAddress - The Aptos account address to query resources for.\n   * @param args.options.limit - The maximum number of results to return.\n   * @param args.options.ledgerVersion - The ledger version to query; if not provided, it will get the latest version.\n   * @returns Account resources.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching account resources for a specific account address\n   *   const resources = await aptos.getAccountResources({ accountAddress: \"0x1\" }); // replace with a real account address\n   *   console.log(resources);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountResources(args: {\n    accountAddress: AccountAddressInput;\n    options?: PaginationArgs & LedgerVersionArg;\n  }): Promise<MoveResource[]> {\n    return getResources({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries a page of account resources given an account address.\n   *\n   * @param args.accountAddress - The Aptos account address to query resources for.\n   * @param args.options.cursor - The cursor to start returning results from.  Note, this is obfuscated and is not an index.\n   * @param args.options.limit - The maximum number of results to return.\n   * @param args.options.ledgerVersion - The ledger version to query; if not provided, it will get the latest version.\n   * @returns Account resources.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching account resources for a specific account address\n   *   const resources = await aptos.getAccountResourcesPage({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       cursor: undefined, // starting from the first resource\n   *       limit: 10, // limiting to 10 resources\n   *     },\n   *   });\n   *   console.log(resources);\n   *   console.log(`More to fetch: ${resources.cursor !== undefined}`);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountResourcesPage(args: {\n    accountAddress: AccountAddressInput;\n    options?: CursorPaginationArgs & LedgerVersionArg;\n  }): Promise<{ resources: MoveResource[]; cursor: string | undefined }> {\n    return getResourcesPage({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries a specific account resource given an account address and resource type.\n   *\n   * @template T - The typed output of the resource.\n   * @param args.accountAddress - The Aptos account address to query.\n   * @param args.resourceType - The string representation of an on-chain Move struct type, e.g., \"0x1::aptos_coin::AptosCoin\".\n   * @param args.options.ledgerVersion - The ledger version to query; if not provided, it will get the latest version.\n   * @returns The account resource of the specified type.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the account resource for a specific account address and resource type\n   *   const resource = await aptos.getAccountResource({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     resourceType: \"0x1::aptos_coin::AptosCoin\"\n   *   });\n   *\n   *   console.log(resource);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountResource<T extends {} = any>(args: {\n    accountAddress: AccountAddressInput;\n    resourceType: MoveStructId;\n    options?: LedgerVersionArg;\n  }): Promise<T> {\n    return getResource<T>({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Looks up the account address for a given authentication key, handling both rotated and non-rotated keys.\n   *\n   * @param args.authenticationKey - The authentication key for which to look up the account address.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options.ledgerVersion - The ledger version to query; if not provided, it will get the latest version.\n   * @returns Promise<AccountAddress> - The account address associated with the authentication key.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Look up the original account address for a given authentication key\n   *   const accountAddress = await aptos.lookupOriginalAccountAddress({\n   *     authenticationKey: \"0x1\", // replace with a real authentication key\n   *   });\n   *\n   *   console.log(\"Original Account Address:\", accountAddress);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async lookupOriginalAccountAddress(args: {\n    authenticationKey: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: LedgerVersionArg;\n  }): Promise<AccountAddress> {\n    return lookupOriginalAccountAddress({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries the current count of tokens owned by a specified account.\n   *\n   * @param args - The parameters for the query.\n   * @param args.accountAddress - The account address to query the token count for.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @returns The current count of tokens owned by the account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the count of tokens owned by the account\n   *   const tokensCount = await aptos.getAccountTokensCount({ accountAddress: \"0x1\" }); // replace with a real account address\n   *   console.log(`Tokens Count: ${tokensCount}`);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountTokensCount(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<number> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.ACCOUNT_TRANSACTION_PROCESSOR,\n    });\n    return getAccountTokensCount({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries the tokens currently owned by a specified account, including NFTs and fungible tokens.\n   * If desired, you can filter the results by a specific token standard.\n   *\n   * @param args.accountAddress The account address for which to retrieve owned tokens.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to before querying.\n   * @param args.options.tokenStandard Optional filter for the NFT standard to query for.\n   * @param args.options.offset Optional number to start returning results from.\n   * @param args.options.limit Optional number of results to return.\n   * @param args.options.orderBy Optional order to sort the tokens by.\n   * @returns An array of tokens with their respective data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the tokens owned by a specific account\n   *   const accountOwnedTokens = await aptos.getAccountOwnedTokens({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       limit: 10, // specify how many tokens to return\n   *       orderBy: \"created_at\", // specify the order of the results\n   *     },\n   *   });\n   *\n   *   console.log(accountOwnedTokens);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountOwnedTokens(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensQueryResponse[0]>;\n  }): Promise<GetAccountOwnedTokensQueryResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getAccountOwnedTokens({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries all current tokens of a specific collection that an account owns by the collection address.\n   * This query returns all tokens (v1 and v2 standards) an account owns, including NFTs, fungible, soulbound, etc.\n   * If you want to get only the token from a specific standard, you can pass an optional tokenStandard parameter.\n   *\n   * @param args.accountAddress - The account address we want to get the tokens for.\n   * @param args.collectionAddress - The address of the collection being queried.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to, before querying.\n   * @param args.options.tokenStandard - The NFT standard to query for.\n   * @param args.options.offset - The number token to start returning results from.\n   * @param args.options.limit - The number of results to return.\n   * @param args.options.orderBy - The order to sort the tokens by.\n   * @returns Tokens array with the token data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get tokens owned by a specific account in a specific collection\n   *   const accountOwnedTokens = await aptos.getAccountOwnedTokensFromCollectionAddress({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     collectionAddress: \"0x2\", // replace with a real collection address\n   *   });\n   *\n   *   console.log(accountOwnedTokens);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountOwnedTokensFromCollectionAddress(args: {\n    accountAddress: AccountAddressInput;\n    collectionAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensFromCollectionResponse[0]>;\n  }): Promise<GetAccountOwnedTokensFromCollectionResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getAccountOwnedTokensFromCollectionAddress({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries for all collections that an account currently has tokens for, including NFTs, fungible tokens, and soulbound tokens.\n   * If you want to filter by a specific token standard, you can pass an optional tokenStandard parameter.\n   *\n   * @param args.accountAddress - The account address we want to get the collections for.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options.tokenStandard - The NFT standard to query for.\n   * @param args.options.offset - The number of the collection to start returning results from.\n   * @param args.options.limit - The number of results to return.\n   * @param args.options.orderBy - The order to sort the tokens by.\n   * @returns Collections array with the collections data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get account collections with owned tokens for a specific account\n   *   const accountCollectionsWithOwnedTokens = await aptos.getAccountCollectionsWithOwnedTokens({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       tokenStandard: \"NFT\", // specify the token standard if needed\n   *       limit: 10, // specify the number of results to return\n   *     },\n   *   });\n   *\n   *   console.log(accountCollectionsWithOwnedTokens);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountCollectionsWithOwnedTokens(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountCollectionsWithOwnedTokenResponse[0]>;\n  }): Promise<GetAccountCollectionsWithOwnedTokenResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getAccountCollectionsWithOwnedTokens({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries the current count of transactions submitted by an account.\n   *\n   * @param args - The parameters for the query.\n   * @param args.accountAddress - The account address we want to get the total count for.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @returns Current count of transactions made by an account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the count of transactions for a specific account\n   *   const accountTransactionsCount = await aptos.getAccountTransactionsCount({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     minimumLedgerVersion: 1, // specify your own minimum ledger version if needed\n   *   });\n   *\n   *   console.log(accountTransactionsCount);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountTransactionsCount(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<number> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.ACCOUNT_TRANSACTION_PROCESSOR,\n    });\n    return getAccountTransactionsCount({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Retrieves the coins data for a specified account.\n   *\n   * @param args.accountAddress - The account address for which to retrieve the coin's data.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options.offset - Optional. The number of coins to start returning results from.\n   * @param args.options.limit - Optional. The number of results to return.\n   * @param args.options.orderBy - Optional. The order to sort the coins by.\n   * @param args.options.where - Optional. Filter the results by specific criteria.\n   * @returns An array containing the coins data for the specified account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching coins data for a specific account\n   *   const accountCoinsData = await aptos.getAccountCoinsData({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       limit: 10, // specify the number of results to return\n   *       orderBy: { asset_type: \"asc\" }, // specify the order of results\n   *     },\n   *   });\n   *\n   *   console.log(accountCoinsData);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountCoinsData(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs &\n      OrderByArg<GetAccountCoinsDataResponse[0]> &\n      WhereArg<CurrentFungibleAssetBalancesBoolExp>;\n  }): Promise<GetAccountCoinsDataResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.FUNGIBLE_ASSET_PROCESSOR,\n    });\n    return getAccountCoinsData({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Retrieves the current count of an account's coins aggregated across all types.\n   *\n   * @param args The parameters for the account coins count query.\n   * @param args.accountAddress The account address we want to get the total count for.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to before querying.\n   * @returns The current count of the aggregated coins for the specified account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Getting the account coins count for a specific account\n   *   const accountCoinsCount = await aptos.getAccountCoinsCount({ accountAddress: \"0x1\" }); // replace with a real account address\n   *   console.log(\"Account Coins Count:\", accountCoinsCount);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountCoinsCount(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<number> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.FUNGIBLE_ASSET_PROCESSOR,\n    });\n    return getAccountCoinsCount({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieves the current amount of APT for a specified account. If the account does not exist, it will return 0.\n   *\n   * @param args The arguments for the account query.\n   * @param args.accountAddress The account address for which to retrieve the APT amount.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to before querying.\n   * @returns The current amount of APT for the specified account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the APT amount for a specific account\n   *   const accountAPTAmount = await aptos.getAccountAPTAmount({ accountAddress: \"0x1\" }); // replace with a real account address\n   *   console.log(\"Account APT Amount:\", accountAPTAmount);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountAPTAmount(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<number> {\n    return this.getAccountCoinAmount({ coinType: APTOS_COIN, faMetadataAddress: APTOS_FA, ...args });\n  }\n\n  /**\n   * Queries the current amount of a specified coin held by an account.\n   *\n   * @param args The parameters for querying the account's coin amount.\n   * @param args.accountAddress The account address to query for the coin amount.\n   * @param args.coinType The coin type to query. Note: If not provided, it may be automatically populated if `faMetadataAddress`\n   * is specified.\n   * @param args.faMetadataAddress The fungible asset metadata address to query. Note: If not provided, it may be automatically\n   * populated if `coinType` is specified.\n   * @param args.minimumLedgerVersion Not used anymore, here for backward compatibility\n   * see https://github.com/aptos-labs/aptos-ts-sdk/pull/519, will be removed in the near future.\n   * Optional ledger version to sync up to before querying.\n   * @returns The current amount of the specified coin held by the account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Query the account's coin amount for a specific coin type\n   *   const accountCoinAmount = await aptos.getAccountCoinAmount({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     coinType: \"0x1::aptos_coin::AptosCoin\" // specify the coin type\n   *   });\n   *\n   *   console.log(`Account coin amount: ${accountCoinAmount}`);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountCoinAmount(args: {\n    accountAddress: AccountAddressInput;\n    coinType?: MoveStructId;\n    faMetadataAddress?: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<number> {\n    const { accountAddress, coinType, faMetadataAddress, minimumLedgerVersion } = args;\n\n    if (minimumLedgerVersion) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `minimumLedgerVersion is not used anymore, here for backward \n        compatibility see https://github.com/aptos-labs/aptos-ts-sdk/pull/519, \n        will be removed in the near future`,\n      );\n    }\n    // Attempt to populate the CoinType field if the FA address is provided.\n    // We cannot do this internally due to dependency cycles issue.\n    let coinAssetType: MoveStructId | undefined = coinType;\n    if (coinType === undefined && faMetadataAddress !== undefined) {\n      coinAssetType = await memoizeAsync(\n        async () => {\n          try {\n            const pairedCoinTypeStruct = (\n              await view({\n                aptosConfig: this.config,\n                payload: { function: \"0x1::coin::paired_coin\", functionArguments: [faMetadataAddress] },\n              })\n            ).at(0) as { vec: MoveValue[] };\n\n            // Check if the Option has a value, and if so, parse the struct\n            if (pairedCoinTypeStruct.vec.length > 0 && isEncodedStruct(pairedCoinTypeStruct.vec[0])) {\n              return parseEncodedStruct(pairedCoinTypeStruct.vec[0]) as MoveStructId;\n            }\n          } catch (error) {\n            /* No paired coin type found */\n          }\n          return undefined;\n        },\n        `coin-mapping-${faMetadataAddress.toString()}`,\n        1000 * 60 * 5, // 5 minutes\n      )();\n    }\n\n    let faAddress: string;\n\n    if (coinType !== undefined && faMetadataAddress !== undefined) {\n      faAddress = AccountAddress.from(faMetadataAddress).toStringLong();\n    } else if (coinType !== undefined && faMetadataAddress === undefined) {\n      // TODO Move to a separate function as defined in the AIP for coin migration\n      if (coinType === APTOS_COIN) {\n        faAddress = AccountAddress.A.toStringLong();\n      } else {\n        faAddress = createObjectAddress(AccountAddress.A, coinType).toStringLong();\n      }\n    } else if (coinType === undefined && faMetadataAddress !== undefined) {\n      const addr = AccountAddress.from(faMetadataAddress);\n      faAddress = addr.toStringLong();\n      if (addr === AccountAddress.A) {\n        coinAssetType = APTOS_COIN;\n      }\n      // The paired CoinType should be populated outside of this function in another\n      // async call. We cannot do this internally due to dependency cycles issue.\n    } else {\n      throw new Error(\"Either coinType, faMetadataAddress, or both must be provided\");\n    }\n\n    // When there is a coin mapping, use that first, otherwise use the fungible asset address\n    // TODO: This function's signature at the top, returns number, but it could be greater than can be represented\n    if (coinAssetType !== undefined) {\n      const [balanceStr] = await view<[string]>({\n        aptosConfig: this.config,\n        payload: {\n          function: \"0x1::coin::balance\",\n          typeArguments: [coinAssetType],\n          functionArguments: [accountAddress],\n        },\n      });\n      return parseInt(balanceStr, 10);\n    }\n    const [balanceStr] = await view<[string]>({\n      aptosConfig: this.config,\n      payload: {\n        function: \"0x1::primary_fungible_store::balance\",\n        typeArguments: [\"0x1::object::ObjectCore\"],\n        functionArguments: [accountAddress, faAddress],\n      },\n    });\n    return parseInt(balanceStr, 10);\n  }\n\n  /**\n   * Queries an account's owned objects.\n   *\n   * @param args.accountAddress The account address we want to get the objects for.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to before querying.\n   * @param args.options.offset The starting position to start returning results from.\n   * @param args.options.limit The number of results to return.\n   * @param args.options.orderBy The order to sort the objects by.\n   * @returns Objects array with the object data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the objects owned by the specified account\n   *   const accountOwnedObjects = await aptos.getAccountOwnedObjects({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     minimumLedgerVersion: 1, // optional, specify if needed\n   *     options: {\n   *       offset: 0, // optional, specify if needed\n   *       limit: 10, // optional, specify if needed\n   *       orderBy: \"created_at\", // optional, specify if needed\n   *     },\n   *   });\n   *\n   *   console.log(accountOwnedObjects);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountOwnedObjects(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & OrderByArg<GetObjectDataQueryResponse[0]>;\n  }): Promise<GetObjectDataQueryResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.DEFAULT,\n    });\n    return getAccountOwnedObjects({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Derives an account by providing a private key. This function resolves the provided private key type and derives the public\n   * key from it.\n   *\n   * If the privateKey is a Secp256k1 type, it derives the account using the derived public key and auth key using the SingleKey\n   * scheme locally.\n   * If the privateKey is an ED25519 type, it looks up the authentication key on chain to determine whether it is a Legacy ED25519\n   * key or a Unified ED25519 key, and then derives the account based on that.\n   *\n   * @param args - The arguments for deriving the account.\n   * @param args.privateKey - An account private key.\n   * @returns The derived Account type.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Ed25519PrivateKey } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *     // Deriving an account from a private key\n   *     const account = await aptos.deriveAccountFromPrivateKey({\n   *         privateKey: new Ed25519PrivateKey(\"0x123\") // replace with a real private key\n   *     });\n   *\n   *     console.log(account);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   * @deprecated Note that more inspection is needed by the user to determine which account exists on-chain\n   */\n  async deriveAccountFromPrivateKey(args: { privateKey: PrivateKey }): Promise<AccountModule> {\n    return deriveAccountFromPrivateKey({ aptosConfig: this.config, ...args });\n  }\n}\n","import { AptosConfig } from \"../api/aptosConfig\";\nimport { AccountAddressInput } from \"../core\";\nimport { EntryFunctionABI, InputGenerateTransactionOptions } from \"../transactions/types\";\nimport { AnyNumber, MoveStructId } from \"../types\";\nimport { APTOS_COIN } from \"../utils/const\";\nimport { generateTransaction } from \"./transactionSubmission\";\nimport { TypeTagAddress, TypeTagU64 } from \"../transactions\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\n\nconst coinTransferAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [] }],\n  parameters: [new TypeTagAddress(), new TypeTagU64()],\n};\n\n/**\n * Generates a transaction to transfer coins from one account to another.\n * This function allows you to specify the sender, recipient, amount, and coin type for the transaction.\n *\n * @param args - The parameters for the transaction.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.sender - The address of the account sending the coins.\n * @param args.recipient - The address of the account receiving the coins.\n * @param args.amount - The amount of coins to transfer.\n * @param args.coinType - (Optional) The type of coin to transfer, defaults to Aptos Coin if not specified.\n * @param args.options - (Optional) Options for generating the transaction.\n * @group Implementation\n */\nexport async function transferCoinTransaction(args: {\n  aptosConfig: AptosConfig;\n  sender: AccountAddressInput;\n  recipient: AccountAddressInput;\n  amount: AnyNumber;\n  coinType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, sender, recipient, amount, coinType, options } = args;\n  const coinStructType = coinType ?? APTOS_COIN;\n  return generateTransaction({\n    aptosConfig,\n    sender,\n    data: {\n      function: \"0x1::aptos_account::transfer_coins\",\n      typeArguments: [coinStructType],\n      functionArguments: [recipient, amount],\n      abi: coinTransferAbi,\n    },\n    options,\n  });\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountAddressInput } from \"../core\";\nimport { transferCoinTransaction } from \"../internal/coin\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\nimport { InputGenerateTransactionOptions } from \"../transactions/types\";\nimport { AnyNumber, MoveStructId } from \"../types\";\nimport { AptosConfig } from \"./aptosConfig\";\n\n/**\n * A class to handle all `Coin` operations.\n * @group Coin\n */\nexport class Coin {\n  /**\n   * Initializes a new instance of the Aptos client with the specified configuration.\n   * This allows you to interact with the Aptos blockchain using the provided settings.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a new Aptos client with testnet configuration\n   *     const config = new AptosConfig({ network: Network.TESTNET });\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Coin\n   */\n  constructor(readonly config: AptosConfig) {}\n\n  /**\n   * Generate a transfer coin transaction that can be simulated, signed, and submitted.\n   * This function helps you create a transaction to transfer a specified amount of coins\n   * from one account to another within the Aptos network.\n   *\n   * @param args The arguments for the transfer transaction.\n   * @param args.sender The sender account address.\n   * @param args.recipient The recipient account address.\n   * @param args.amount The amount of coins to transfer.\n   * @param args.coinType Optional. The coin struct type to transfer. Defaults to 0x1::aptos_coin::AptosCoin.\n   * @param args.options Optional. Additional options for generating the transaction.\n   *\n   * @returns SimpleTransaction\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Generate a transfer coin transaction\n   *   const transaction = await aptos.transferCoinTransaction({\n   *     sender: \"0x1\", // replace with a real sender account address\n   *     recipient: \"0x2\", // replace with a real recipient account address\n   *     amount: 10,\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Coin\n   */\n  async transferCoinTransaction(args: {\n    sender: AccountAddressInput;\n    recipient: AccountAddressInput;\n    amount: AnyNumber;\n    coinType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return transferCoinTransaction({ aptosConfig: this.config, ...args });\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/digitalAsset}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * digitalAsset namespace and without having a dependency cycle error.\n * @group Implementation\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { Bool, MoveString, MoveVector, U64 } from \"../bcs\";\nimport { AccountAddress, AccountAddressInput } from \"../core\";\nimport { Account } from \"../account\";\nimport { EntryFunctionABI, InputGenerateTransactionOptions } from \"../transactions/types\";\nimport {\n  AnyNumber,\n  GetCollectionDataResponse,\n  GetCurrentTokenOwnershipResponse,\n  GetOwnedTokensResponse,\n  GetTokenActivityResponse,\n  GetTokenDataResponse,\n  MoveAbility,\n  MoveStructId,\n  OrderByArg,\n  PaginationArgs,\n  TokenStandardArg,\n  WhereArg,\n} from \"../types\";\nimport {\n  GetCollectionDataQuery,\n  GetCurrentTokenOwnershipQuery,\n  GetTokenActivityQuery,\n  GetTokenDataQuery,\n} from \"../types/generated/operations\";\nimport {\n  GetCollectionData,\n  GetCurrentTokenOwnership,\n  GetTokenActivity,\n  GetTokenData,\n} from \"../types/generated/queries\";\nimport { queryIndexer } from \"./general\";\nimport { generateTransaction } from \"./transactionSubmission\";\nimport { MAX_U64_BIG_INT } from \"../bcs/consts\";\nimport {\n  CurrentCollectionsV2BoolExp,\n  CurrentTokenOwnershipsV2BoolExp,\n  TokenActivitiesV2BoolExp,\n} from \"../types/generated/types\";\nimport {\n  checkOrConvertArgument,\n  objectStructTag,\n  parseTypeTag,\n  stringStructTag,\n  TypeTagAddress,\n  TypeTagBool,\n  TypeTagGeneric,\n  TypeTagStruct,\n  TypeTagU64,\n  TypeTagVector,\n} from \"../transactions\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\n\n// A property type map for the user input and what Move expects\nconst PropertyTypeMap = {\n  BOOLEAN: \"bool\",\n  U8: \"u8\",\n  U16: \"u16\",\n  U32: \"u32\",\n  U64: \"u64\",\n  U128: \"u128\",\n  U256: \"u256\",\n  ADDRESS: \"address\",\n  STRING: \"0x1::string::String\",\n  ARRAY: \"vector<u8>\",\n};\n\n/**\n * The keys of the PropertyTypeMap, representing different property types.\n * @group Implementation\n */\nexport type PropertyType = keyof typeof PropertyTypeMap;\n\n/**\n * Accepted property value types for user input, including boolean, number, bigint, string, AccountAddress, and Uint8Array.\n * To pass in an Array, use Uint8Array type\n * for example `new MoveVector([new MoveString(\"hello\"), new MoveString(\"world\")]).bcsToBytes()`\n * @group Implementation\n */\nexport type PropertyValue = boolean | number | bigint | string | AccountAddress | Uint8Array;\n\n// The default digital asset type to use if non provided\nconst defaultDigitalAssetType = \"0x4::token::Token\";\n\n// FETCH QUERIES\n\n/**\n * Retrieves data for a specific digital asset using its address.\n *\n * @param args - The arguments for fetching digital asset data.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.digitalAssetAddress - The address of the digital asset to retrieve data for.\n * @returns The data of the specified digital asset.\n * @group Implementation\n */\nexport async function getDigitalAssetData(args: {\n  aptosConfig: AptosConfig;\n  digitalAssetAddress: AccountAddressInput;\n}): Promise<GetTokenDataResponse> {\n  const { aptosConfig, digitalAssetAddress } = args;\n\n  const whereCondition: { token_data_id: { _eq: string } } = {\n    token_data_id: { _eq: AccountAddress.from(digitalAssetAddress).toStringLong() },\n  };\n\n  const graphqlQuery = {\n    query: GetTokenData,\n    variables: {\n      where_condition: whereCondition,\n    },\n  };\n\n  const data = await queryIndexer<GetTokenDataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getDigitalAssetData\",\n  });\n\n  return data.current_token_datas_v2[0];\n}\n\n/**\n * Retrieves the current ownership details of a specified digital asset.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.digitalAssetAddress - The address of the digital asset to query ownership for.\n * @returns The current ownership details of the specified digital asset.\n * @group Implementation\n */\nexport async function getCurrentDigitalAssetOwnership(args: {\n  aptosConfig: AptosConfig;\n  digitalAssetAddress: AccountAddressInput;\n}): Promise<GetCurrentTokenOwnershipResponse> {\n  const { aptosConfig, digitalAssetAddress } = args;\n\n  const whereCondition: CurrentTokenOwnershipsV2BoolExp = {\n    token_data_id: { _eq: AccountAddress.from(digitalAssetAddress).toStringLong() },\n    amount: { _gt: 0 },\n  };\n\n  const graphqlQuery = {\n    query: GetCurrentTokenOwnership,\n    variables: {\n      where_condition: whereCondition,\n    },\n  };\n\n  const data = await queryIndexer<GetCurrentTokenOwnershipQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getCurrentDigitalAssetOwnership\",\n  });\n\n  return data.current_token_ownerships_v2[0];\n}\n\n/**\n * Retrieves the digital assets owned by a specified account address.\n *\n * @param args - The arguments for retrieving owned digital assets.\n * @param args.aptosConfig - The configuration for connecting to the Aptos network.\n * @param args.ownerAddress - The address of the account whose owned digital assets are being queried.\n * @param args.options - Optional pagination and ordering parameters for the query.\n * @param args.options.offset - The number of records to skip for pagination.\n * @param args.options.limit - The maximum number of records to return.\n * @param args.options.orderBy - The criteria for ordering the results.\n *\n * @returns An array of digital assets currently owned by the specified account.\n * @group Implementation\n */\nexport async function getOwnedDigitalAssets(args: {\n  aptosConfig: AptosConfig;\n  ownerAddress: AccountAddressInput;\n  options?: PaginationArgs & OrderByArg<GetTokenActivityResponse[0]>;\n}): Promise<GetOwnedTokensResponse> {\n  const { aptosConfig, ownerAddress, options } = args;\n\n  const whereCondition: CurrentTokenOwnershipsV2BoolExp = {\n    owner_address: { _eq: AccountAddress.from(ownerAddress).toStringLong() },\n    amount: { _gt: 0 },\n  };\n\n  const graphqlQuery = {\n    query: GetCurrentTokenOwnership,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetCurrentTokenOwnershipQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getOwnedDigitalAssets\",\n  });\n\n  return data.current_token_ownerships_v2;\n}\n\n/**\n * Retrieves the activity associated with a specific digital asset.\n * This function allows you to track the token activities for a given digital asset address.\n *\n * @param args - The arguments for retrieving digital asset activity.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.digitalAssetAddress - The address of the digital asset to query.\n * @param args.options - Optional parameters for pagination and ordering.\n * @param args.options.offset - The number of records to skip before starting to collect the result set.\n * @param args.options.limit - The maximum number of records to return.\n * @param args.options.orderBy - The criteria to order the results by.\n * @returns A promise that resolves to an array of token activities for the specified digital asset.\n * @group Implementation\n */\nexport async function getDigitalAssetActivity(args: {\n  aptosConfig: AptosConfig;\n  digitalAssetAddress: AccountAddressInput;\n  options?: PaginationArgs & OrderByArg<GetTokenActivityResponse[0]>;\n}): Promise<GetTokenActivityResponse> {\n  const { aptosConfig, digitalAssetAddress, options } = args;\n\n  const whereCondition: TokenActivitiesV2BoolExp = {\n    token_data_id: { _eq: AccountAddress.from(digitalAssetAddress).toStringLong() },\n  };\n\n  const graphqlQuery = {\n    query: GetTokenActivity,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetTokenActivityQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getDigitalAssetActivity\",\n  });\n\n  return data.token_activities_v2;\n}\n\n/**\n * Options for creating a collection, allowing customization of various attributes such as supply limits, mutability of metadata,\n * and royalty settings.\n *\n * @param maxSupply - Maximum number of tokens that can be minted in the collection.\n * @param mutableDescription - Indicates if the collection description can be changed after creation.\n * @param mutableRoyalty - Indicates if the royalty settings can be modified after creation.\n * @param mutableURI - Indicates if the collection URI can be updated.\n * @param mutableTokenDescription - Indicates if individual token descriptions can be modified.\n * @param mutableTokenName - Indicates if individual token names can be changed.\n * @param mutableTokenProperties - Indicates if individual token properties can be altered.\n * @param mutableTokenURI - Indicates if individual token URIs can be updated.\n * @param tokensBurnableByCreator - Indicates if the creator can burn tokens from the collection.\n * @param tokensFreezableByCreator - Indicates if the creator can freeze tokens in the collection.\n * @param royaltyNumerator - The numerator for calculating royalties.\n * @param royaltyDenominator - The denominator for calculating royalties.\n * @group Implementation\n */\nexport interface CreateCollectionOptions {\n  maxSupply?: AnyNumber;\n  mutableDescription?: boolean;\n  mutableRoyalty?: boolean;\n  mutableURI?: boolean;\n  mutableTokenDescription?: boolean;\n  mutableTokenName?: boolean;\n  mutableTokenProperties?: boolean;\n  mutableTokenURI?: boolean;\n  tokensBurnableByCreator?: boolean;\n  tokensFreezableByCreator?: boolean;\n  royaltyNumerator?: number;\n  royaltyDenominator?: number;\n}\n\nconst createCollectionAbi: EntryFunctionABI = {\n  typeParameters: [],\n  parameters: [\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagU64(),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagBool(),\n    new TypeTagBool(),\n    new TypeTagBool(),\n    new TypeTagBool(),\n    new TypeTagBool(),\n    new TypeTagBool(),\n    new TypeTagBool(),\n    new TypeTagBool(),\n    new TypeTagBool(),\n    new TypeTagU64(),\n    new TypeTagU64(),\n  ],\n};\n\n/**\n * Creates a new collection transaction on the Aptos blockchain.\n * This function allows you to define the properties of the collection, including its name, description, and URI.\n *\n * @param args - The parameters for creating the collection transaction.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.creator - The account that will create the collection.\n * @param args.description - A description of the collection.\n * @param args.name - The name of the collection.\n * @param args.uri - The URI associated with the collection.\n * @param args.options - Optional parameters for generating the transaction.\n * @param args.maxSupply - The maximum supply of tokens in the collection (optional).\n * @param args.mutableDescription - Indicates if the collection description can be changed (optional, defaults to true).\n * @param args.mutableRoyalty - Indicates if the royalty settings can be changed (optional, defaults to true).\n * @param args.mutableURI - Indicates if the URI can be changed (optional, defaults to true).\n * @param args.mutableTokenDescription - Indicates if the token description can be changed (optional, defaults to true).\n * @param args.mutableTokenName - Indicates if the token name can be changed (optional, defaults to true).\n * @param args.mutableTokenProperties - Indicates if the token properties can be changed (optional, defaults to true).\n * @param args.mutableTokenURI - Indicates if the token URI can be changed (optional, defaults to true).\n * @param args.tokensBurnableByCreator - Indicates if tokens can be burned by the creator (optional, defaults to true).\n * @param args.tokensFreezableByCreator - Indicates if tokens can be frozen by the creator (optional, defaults to true).\n * @param args.royaltyNumerator - The numerator for calculating royalties (optional, defaults to 0).\n * @param args.royaltyDenominator - The denominator for calculating royalties (optional, defaults to 1).\n * @group Implementation\n */\nexport async function createCollectionTransaction(\n  args: {\n    aptosConfig: AptosConfig;\n    creator: Account;\n    description: string;\n    name: string;\n    uri: string;\n    options?: InputGenerateTransactionOptions;\n  } & CreateCollectionOptions,\n): Promise<SimpleTransaction> {\n  const { aptosConfig, options, creator } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::create_collection\",\n      functionArguments: [\n        // Do not change the order\n        new MoveString(args.description),\n        new U64(args.maxSupply ?? MAX_U64_BIG_INT),\n        new MoveString(args.name),\n        new MoveString(args.uri),\n        new Bool(args.mutableDescription ?? true),\n        new Bool(args.mutableRoyalty ?? true),\n        new Bool(args.mutableURI ?? true),\n        new Bool(args.mutableTokenDescription ?? true),\n        new Bool(args.mutableTokenName ?? true),\n        new Bool(args.mutableTokenProperties ?? true),\n        new Bool(args.mutableTokenURI ?? true),\n        new Bool(args.tokensBurnableByCreator ?? true),\n        new Bool(args.tokensFreezableByCreator ?? true),\n        new U64(args.royaltyNumerator ?? 0),\n        new U64(args.royaltyDenominator ?? 1),\n      ],\n      abi: createCollectionAbi,\n    },\n    options,\n  });\n}\n\n/**\n * Retrieves data for the current collections based on specified options.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.options - Optional parameters for filtering and pagination.\n * @param args.options.tokenStandard - The token standard to filter the collections (default is \"v2\").\n * @param args.options.offset - The offset for pagination.\n * @param args.options.limit - The limit for pagination.\n * @param args.options.where - The conditions to filter the collections.\n * @returns The data of the current collections.\n * @group Implementation\n */\nexport async function getCollectionData(args: {\n  aptosConfig: AptosConfig;\n  options?: TokenStandardArg & PaginationArgs & WhereArg<CurrentCollectionsV2BoolExp>;\n}): Promise<GetCollectionDataResponse> {\n  const { aptosConfig, options } = args;\n\n  const whereCondition: any = options?.where;\n\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard ?? \"v2\" };\n  }\n\n  const graphqlQuery = {\n    query: GetCollectionData,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n    },\n  };\n  const data = await queryIndexer<GetCollectionDataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getCollectionData\",\n  });\n\n  return data.current_collections_v2[0];\n}\n\n/**\n * Retrieves collection data based on the creator's address and the collection name.\n *\n * @param args - The arguments for retrieving the collection data.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.creatorAddress - The address of the creator whose collection data is being retrieved.\n * @param args.collectionName - The name of the collection to fetch data for.\n * @param args.options - Optional parameters for filtering the results, including token standard and pagination options.\n * @param args.options.tokenStandard - The token standard to filter the results by (optional).\n * @param args.options.pagination - Pagination options for the results (optional).\n * @group Implementation\n */\nexport async function getCollectionDataByCreatorAddressAndCollectionName(args: {\n  aptosConfig: AptosConfig;\n  creatorAddress: AccountAddressInput;\n  collectionName: string;\n  options?: TokenStandardArg & PaginationArgs;\n}): Promise<GetCollectionDataResponse> {\n  const { aptosConfig, creatorAddress, collectionName, options } = args;\n  const address = AccountAddress.from(creatorAddress);\n\n  const whereCondition: any = {\n    collection_name: { _eq: collectionName },\n    creator_address: { _eq: address.toStringLong() },\n  };\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard ?? \"v2\" };\n  }\n\n  return getCollectionData({ aptosConfig, options: { ...options, where: whereCondition } });\n}\n\n/**\n * Retrieves collection data associated with a specific creator's address.\n * This function allows you to filter the collections based on the creator's address and optional token standards.\n *\n * @param args - The arguments for retrieving collection data.\n * @param args.aptosConfig - The configuration for the Aptos network.\n * @param args.creatorAddress - The address of the creator whose collection data is being retrieved.\n * @param args.options - Optional parameters for filtering the results.\n * @param args.options.tokenStandard - The token standard to filter the collections by.\n * @param args.options.pagination - Pagination options for the results.\n * @group Implementation\n */\nexport async function getCollectionDataByCreatorAddress(args: {\n  aptosConfig: AptosConfig;\n  creatorAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs;\n}): Promise<GetCollectionDataResponse> {\n  const { aptosConfig, creatorAddress, options } = args;\n  const address = AccountAddress.from(creatorAddress);\n\n  const whereCondition: any = {\n    creator_address: { _eq: address.toStringLong() },\n  };\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard ?? \"v2\" };\n  }\n\n  return getCollectionData({ aptosConfig, options: { ...options, where: whereCondition } });\n}\n\n/**\n * Retrieves data for a specific collection using its unique identifier.\n * This function allows you to filter the collection data based on the token standard and pagination options.\n *\n * @param args - The arguments for retrieving collection data.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.collectionId - The unique identifier for the collection.\n * @param args.options - Optional parameters for filtering by token standard and pagination.\n * @param args.options.tokenStandard - The standard of the token to filter the collection data.\n * @param args.options.page - The page number for pagination.\n * @param args.options.limit - The number of items per page for pagination.\n * @group Implementation\n */\nexport async function getCollectionDataByCollectionId(args: {\n  aptosConfig: AptosConfig;\n  collectionId: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs;\n}): Promise<GetCollectionDataResponse> {\n  const { aptosConfig, collectionId, options } = args;\n  const address = AccountAddress.from(collectionId);\n\n  const whereCondition: any = {\n    collection_id: { _eq: address.toStringLong() },\n  };\n\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard ?? \"v2\" };\n  }\n\n  return getCollectionData({ aptosConfig, options: { ...options, where: whereCondition } });\n}\n\n/**\n * Retrieves the collection ID based on the creator's address and the collection name.\n * This function helps in identifying a specific collection within the Aptos ecosystem.\n *\n * @param args - The parameters for retrieving the collection ID.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.creatorAddress - The address of the creator of the collection.\n * @param args.collectionName - The name of the collection to look up.\n * @param args.options - Optional parameters for additional filtering.\n * @param args.options.tokenStandard - The token standard to filter the collection (default is \"v2\").\n * @returns The ID of the specified collection.\n * @group Implementation\n */\nexport async function getCollectionId(args: {\n  aptosConfig: AptosConfig;\n  creatorAddress: AccountAddressInput;\n  collectionName: string;\n  options?: TokenStandardArg;\n}): Promise<string> {\n  const { creatorAddress, collectionName, options, aptosConfig } = args;\n  const address = AccountAddress.from(creatorAddress);\n\n  const whereCondition: any = {\n    collection_name: { _eq: collectionName },\n    creator_address: { _eq: address.toStringLong() },\n  };\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard ?? \"v2\" };\n  }\n\n  return (await getCollectionData({ aptosConfig, options: { where: whereCondition } })).collection_id;\n}\n\n// TRANSACTIONS\n\nconst mintDigitalAssetAbi: EntryFunctionABI = {\n  typeParameters: [],\n  parameters: [\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagVector(new TypeTagStruct(stringStructTag())),\n    new TypeTagVector(new TypeTagStruct(stringStructTag())),\n    new TypeTagVector(TypeTagVector.u8()),\n  ],\n};\n\n/**\n * Creates a transaction to mint a digital asset on the Aptos blockchain.\n * This function allows you to specify various attributes of the asset, including its collection, description, name, and URI.\n *\n * @param args - The arguments for minting the digital asset.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.creator - The account that will create the digital asset.\n * @param args.collection - The name of the collection to which the asset belongs.\n * @param args.description - A brief description of the digital asset.\n * @param args.name - The name of the digital asset.\n * @param args.uri - The URI pointing to the asset's metadata.\n * @param [args.propertyKeys] - Optional array of property keys associated with the asset.\n * @param [args.propertyTypes] - Optional array of property types corresponding to the asset's properties.\n * @param [args.propertyValues] - Optional array of property values for the asset's properties.\n * @param [args.options] - Optional transaction generation options.\n * @group Implementation\n */\nexport async function mintDigitalAssetTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  collection: string;\n  description: string;\n  name: string;\n  uri: string;\n  propertyKeys?: Array<string>;\n  propertyTypes?: Array<PropertyType>;\n  propertyValues?: Array<PropertyValue>;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const {\n    aptosConfig,\n    options,\n    creator,\n    collection,\n    description,\n    name,\n    uri,\n    propertyKeys,\n    propertyTypes,\n    propertyValues,\n  } = args;\n  const convertedPropertyType = propertyTypes?.map((type) => PropertyTypeMap[type]);\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::mint\",\n      functionArguments: [\n        new MoveString(collection),\n        new MoveString(description),\n        new MoveString(name),\n        new MoveString(uri),\n        MoveVector.MoveString(propertyKeys ?? []),\n        MoveVector.MoveString(convertedPropertyType ?? []),\n\n        /**\n         * Retrieves the raw values of specified properties from an array of property values based on their types.\n         *\n         * @param propertyValues - An array of property values from which to extract the raw data.\n         * @param propertyTypes - An array of strings representing the types of properties to retrieve.\n         * @returns An array of Uint8Array containing the raw values for the specified property types.\n         * @group Implementation\n         */\n        getPropertyValueRaw(propertyValues ?? [], convertedPropertyType ?? []),\n      ],\n      abi: mintDigitalAssetAbi,\n    },\n    options,\n  });\n}\n\nconst transferDigitalAssetAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }],\n  parameters: [new TypeTagStruct(objectStructTag(new TypeTagGeneric(0))), new TypeTagAddress()],\n};\n\n/**\n * Initiates a transaction to transfer a digital asset from one account to another.\n * This function helps in executing the transfer of digital assets securely and efficiently.\n *\n * @param args - The arguments required to perform the transfer.\n * @param args.aptosConfig - Configuration settings for the Aptos client.\n * @param args.sender - The account initiating the transfer.\n * @param args.digitalAssetAddress - The address of the digital asset being transferred.\n * @param args.recipient - The address of the account receiving the digital asset.\n * @param args.digitalAssetType - (Optional) The type of the digital asset being transferred.\n * @param args.options - (Optional) Additional options for generating the transaction.\n * @group Implementation\n */\nexport async function transferDigitalAssetTransaction(args: {\n  aptosConfig: AptosConfig;\n  sender: Account;\n  digitalAssetAddress: AccountAddressInput;\n  recipient: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, sender, digitalAssetAddress, recipient, digitalAssetType, options } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress,\n    data: {\n      function: \"0x1::object::transfer\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType],\n      functionArguments: [AccountAddress.from(digitalAssetAddress), AccountAddress.from(recipient)],\n      abi: transferDigitalAssetAbi,\n    },\n    options,\n  });\n}\n\nconst mintSoulBoundAbi: EntryFunctionABI = {\n  typeParameters: [],\n  parameters: [\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagVector(new TypeTagStruct(stringStructTag())),\n    new TypeTagVector(new TypeTagStruct(stringStructTag())),\n    new TypeTagVector(TypeTagVector.u8()),\n    new TypeTagAddress(),\n  ],\n};\n\n/**\n * Creates a transaction to mint a soul-bound token.\n * This function allows you to specify the token's attributes and recipient, facilitating the creation of unique digital assets.\n *\n * @param args - The parameters required to mint the soul-bound token.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.account - The account initiating the minting transaction.\n * @param args.collection - The name of the collection to which the token belongs.\n * @param args.description - A description of the token being minted.\n * @param args.name - The name of the token.\n * @param args.uri - The URI pointing to the token's metadata.\n * @param args.recipient - The address of the account that will receive the minted token.\n * @param [args.propertyKeys] - Optional array of property keys associated with the token.\n * @param [args.propertyTypes] - Optional array of property types corresponding to the property keys.\n * @param [args.propertyValues] - Optional array of property values that match the property keys and types.\n * @param [args.options] - Optional transaction generation options.\n * @throws Error if the counts of property keys, property types, and property values do not match.\n * @group Implementation\n */\nexport async function mintSoulBoundTransaction(args: {\n  aptosConfig: AptosConfig;\n  account: Account;\n  collection: string;\n  description: string;\n  name: string;\n  uri: string;\n  recipient: AccountAddressInput;\n  propertyKeys?: Array<string>;\n  propertyTypes?: Array<PropertyType>;\n  propertyValues?: Array<PropertyValue>;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const {\n    aptosConfig,\n    account,\n    collection,\n    description,\n    name,\n    uri,\n    recipient,\n    propertyKeys,\n    propertyTypes,\n    propertyValues,\n    options,\n  } = args;\n  if (propertyKeys?.length !== propertyValues?.length) {\n    throw new Error(\"Property keys and property values counts do not match\");\n  }\n  if (propertyTypes?.length !== propertyValues?.length) {\n    throw new Error(\"Property types and property values counts do not match\");\n  }\n  const convertedPropertyType = propertyTypes?.map((type) => PropertyTypeMap[type]);\n  return generateTransaction({\n    aptosConfig,\n    sender: account.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::mint_soul_bound\",\n      functionArguments: [\n        collection,\n        description,\n        name,\n        uri,\n        MoveVector.MoveString(propertyKeys ?? []),\n        MoveVector.MoveString(convertedPropertyType ?? []),\n        getPropertyValueRaw(propertyValues ?? [], convertedPropertyType ?? []),\n        recipient,\n      ],\n      abi: mintSoulBoundAbi,\n    },\n    options,\n  });\n}\n\nconst burnDigitalAssetAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }],\n  parameters: [new TypeTagStruct(objectStructTag(new TypeTagGeneric(0)))],\n};\n\n/**\n * Creates a transaction to burn a specified digital asset.\n * This function allows users to permanently remove a digital asset from their account.\n *\n * @param args - The arguments for the transaction.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.creator - The account that is initiating the burn transaction.\n * @param args.digitalAssetAddress - The address of the digital asset to be burned.\n * @param args.digitalAssetType - Optional; the type of the digital asset being burned.\n * @param args.options - Optional; additional options for generating the transaction.\n * @group Implementation\n */\nexport async function burnDigitalAssetTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  digitalAssetAddress: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, creator, digitalAssetAddress, digitalAssetType, options } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::burn\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType],\n      functionArguments: [AccountAddress.from(digitalAssetAddress)],\n      abi: burnDigitalAssetAbi,\n    },\n    options,\n  });\n}\n\nconst freezeDigitalAssetAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }],\n  parameters: [new TypeTagStruct(objectStructTag(new TypeTagGeneric(0)))],\n};\n\n/**\n * Creates a transaction to freeze the transfer of a digital asset.\n * This function helps you prevent the transfer of a specified digital asset by generating the appropriate transaction.\n *\n * @param args - The parameters for the transaction.\n * @param args.aptosConfig - The configuration settings for the Aptos client.\n * @param args.creator - The account that is creating the transaction.\n * @param args.digitalAssetAddress - The address of the digital asset to be frozen.\n * @param args.digitalAssetType - (Optional) The type of the digital asset as a Move struct ID.\n * @param args.options - (Optional) Additional options for generating the transaction.\n * @group Implementation\n */\nexport async function freezeDigitalAssetTransferTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  digitalAssetAddress: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, creator, digitalAssetAddress, digitalAssetType, options } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::freeze_transfer\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType],\n      functionArguments: [digitalAssetAddress],\n      abi: freezeDigitalAssetAbi,\n    },\n    options,\n  });\n}\n\nconst unfreezeDigitalAssetAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }],\n  parameters: [new TypeTagStruct(objectStructTag(new TypeTagGeneric(0)))],\n};\n\n/**\n * Unfreezes a digital asset transfer transaction, allowing the transfer of the specified digital asset.\n *\n * @param args - The arguments for unfreezing the digital asset transfer transaction.\n * @param args.aptosConfig - The Aptos configuration settings.\n * @param args.creator - The account that is initiating the unfreeze transaction.\n * @param args.digitalAssetAddress - The address of the digital asset to be unfrozen.\n * @param args.digitalAssetType - (Optional) The type of the digital asset being unfrozen.\n * @param args.options - (Optional) Additional options for generating the transaction.\n * @group Implementation\n */\nexport async function unfreezeDigitalAssetTransferTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  digitalAssetAddress: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, creator, digitalAssetAddress, digitalAssetType, options } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::unfreeze_transfer\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType],\n      functionArguments: [digitalAssetAddress],\n      abi: unfreezeDigitalAssetAbi,\n    },\n    options,\n  });\n}\n\nconst setDigitalAssetDescriptionAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }],\n  parameters: [new TypeTagStruct(objectStructTag(new TypeTagGeneric(0))), new TypeTagStruct(stringStructTag())],\n};\n\n/**\n * Sets the description for a digital asset, allowing users to provide additional context or information about the asset.\n *\n * @param args - The arguments for setting the digital asset description.\n * @param args.aptosConfig - The Aptos configuration to use for the transaction.\n * @param args.creator - The account that is creating the transaction.\n * @param args.description - The new description for the digital asset.\n * @param args.digitalAssetAddress - The address of the digital asset whose description is being set.\n * @param args.digitalAssetType - (Optional) The type of the digital asset.\n * @param args.options - (Optional) Additional options for generating the transaction.\n * @group Implementation\n */\nexport async function setDigitalAssetDescriptionTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  description: string;\n  digitalAssetAddress: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, creator, description, digitalAssetAddress, digitalAssetType, options } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::set_description\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType],\n      functionArguments: [AccountAddress.from(digitalAssetAddress), new MoveString(description)],\n      abi: setDigitalAssetDescriptionAbi,\n    },\n    options,\n  });\n}\n\nconst setDigitalAssetNameAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }],\n  parameters: [new TypeTagStruct(objectStructTag(new TypeTagGeneric(0))), new TypeTagStruct(stringStructTag())],\n};\n\n/**\n * Sets the name of a digital asset on the Aptos blockchain.\n * This function allows you to update the name of a specified digital asset, enabling better identification and categorization.\n *\n * @param args - The parameters for setting the digital asset name.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.creator - The account that is creating the transaction.\n * @param args.name - The new name to assign to the digital asset.\n * @param args.digitalAssetAddress - The address of the digital asset to update.\n * @param args.digitalAssetType - (Optional) The type of the digital asset, represented as a Move struct ID.\n * @param args.options - (Optional) Additional options for generating the transaction.\n * @group Implementation\n */\nexport async function setDigitalAssetNameTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  name: string;\n  digitalAssetAddress: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, creator, name, digitalAssetAddress, digitalAssetType, options } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::set_name\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType],\n      functionArguments: [AccountAddress.from(digitalAssetAddress), new MoveString(name)],\n      abi: setDigitalAssetNameAbi,\n    },\n    options,\n  });\n}\n\nconst setDigitalAssetURIAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }],\n  parameters: [new TypeTagStruct(objectStructTag(new TypeTagGeneric(0))), new TypeTagStruct(stringStructTag())],\n};\n\n/**\n * Sets the URI for a digital asset, allowing you to update the metadata associated with it.\n *\n * @param args - The arguments for setting the digital asset URI.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.creator - The account that is creating the transaction.\n * @param args.uri - The new URI to be set for the digital asset.\n * @param args.digitalAssetAddress - The address of the digital asset whose URI is being set.\n * @param args.digitalAssetType - The optional type of the digital asset; defaults to a predefined type if not provided.\n * @param args.options - Optional settings for generating the transaction.\n * @group Implementation\n */\nexport async function setDigitalAssetURITransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  uri: string;\n  digitalAssetAddress: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, creator, uri, digitalAssetAddress, digitalAssetType, options } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::set_uri\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType],\n      functionArguments: [AccountAddress.from(digitalAssetAddress), new MoveString(uri)],\n      abi: setDigitalAssetURIAbi,\n    },\n    options,\n  });\n}\n\nconst addDigitalAssetPropertyAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }],\n  parameters: [\n    new TypeTagStruct(objectStructTag(new TypeTagGeneric(0))),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagStruct(stringStructTag()),\n    TypeTagVector.u8(),\n  ],\n};\n\n/**\n * Creates a transaction to add a property to a digital asset.\n * This function helps in enhancing the metadata associated with a digital asset by allowing the addition of custom properties.\n *\n * @param args - The arguments for the transaction.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.creator - The account that is creating the transaction.\n * @param args.propertyKey - The key for the property being added.\n * @param args.propertyType - The type of the property being added.\n * @param args.propertyValue - The value of the property being added.\n * @param args.digitalAssetAddress - The address of the digital asset to which the property is being added.\n * @param args.digitalAssetType - The optional type of the digital asset.\n * @param args.options - Optional transaction generation options.\n * @group Implementation\n */\nexport async function addDigitalAssetPropertyTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  propertyKey: string;\n  propertyType: PropertyType;\n  propertyValue: PropertyValue;\n  digitalAssetAddress: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const {\n    aptosConfig,\n    creator,\n    propertyKey,\n    propertyType,\n    propertyValue,\n    digitalAssetAddress,\n    digitalAssetType,\n    options,\n  } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::add_property\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType],\n      functionArguments: [\n        AccountAddress.from(digitalAssetAddress),\n        new MoveString(propertyKey),\n        new MoveString(PropertyTypeMap[propertyType]),\n        MoveVector.U8(getSinglePropertyValueRaw(propertyValue, PropertyTypeMap[propertyType])),\n      ],\n      abi: addDigitalAssetPropertyAbi,\n    },\n    options,\n  });\n}\n\nconst removeDigitalAssetPropertyAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }],\n  parameters: [new TypeTagStruct(objectStructTag(new TypeTagGeneric(0))), new TypeTagStruct(stringStructTag())],\n};\n\n/**\n * Removes a property from a digital asset on the Aptos blockchain.\n * This function helps in managing the attributes of digital assets by allowing the removal of specific properties.\n *\n * @param args - The arguments for the transaction.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.creator - The account that is creating the transaction.\n * @param args.propertyKey - The key of the property to be removed.\n * @param args.digitalAssetAddress - The address of the digital asset from which the property will be removed.\n * @param args.digitalAssetType - The type of the digital asset (optional).\n * @param args.options - Additional options for generating the transaction (optional).\n * @group Implementation\n */\nexport async function removeDigitalAssetPropertyTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  propertyKey: string;\n  digitalAssetAddress: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, creator, propertyKey, digitalAssetAddress, digitalAssetType, options } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::remove_property\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType],\n      functionArguments: [AccountAddress.from(digitalAssetAddress), new MoveString(propertyKey)],\n      abi: removeDigitalAssetPropertyAbi,\n    },\n    options,\n  });\n}\n\nconst updateDigitalAssetPropertyAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }],\n  parameters: [\n    new TypeTagStruct(objectStructTag(new TypeTagGeneric(0))),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagStruct(stringStructTag()),\n    TypeTagVector.u8(),\n  ],\n};\n\n/**\n * Updates a property of a digital asset by generating a transaction for the Aptos blockchain.\n * This function allows you to modify attributes of a digital asset, facilitating dynamic changes to its properties.\n *\n * @param args - The arguments for updating the digital asset property.\n * @param args.aptosConfig - The configuration settings for the Aptos blockchain.\n * @param args.creator - The account that is creating the transaction.\n * @param args.propertyKey - The key of the property to be updated.\n * @param args.propertyType - The type of the property being updated.\n * @param args.propertyValue - The new value for the property.\n * @param args.digitalAssetAddress - The address of the digital asset to update.\n * @param args.digitalAssetType - (Optional) The type of the digital asset.\n * @param args.options - (Optional) Additional options for generating the transaction.\n * @group Implementation\n */\nexport async function updateDigitalAssetPropertyTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  propertyKey: string;\n  propertyType: PropertyType;\n  propertyValue: PropertyValue;\n  digitalAssetAddress: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const {\n    aptosConfig,\n    creator,\n    propertyKey,\n    propertyType,\n    propertyValue,\n    digitalAssetAddress,\n    digitalAssetType,\n    options,\n  } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::update_property\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType],\n      functionArguments: [\n        AccountAddress.from(digitalAssetAddress),\n        new MoveString(propertyKey),\n        new MoveString(PropertyTypeMap[propertyType]),\n\n        /**\n         * Retrieves the raw byte representation of a single property value based on its type.\n         *\n         * @param propertyValue - The value of the property to convert.\n         * @param propertyType - The type of the property, which determines how the value is processed.\n         * @returns The raw byte representation of the property value.\n         * @group Implementation\n         */\n        getSinglePropertyValueRaw(propertyValue, PropertyTypeMap[propertyType]),\n      ],\n      abi: updateDigitalAssetPropertyAbi,\n    },\n    options,\n  });\n}\n\nconst addDigitalAssetTypedPropertyAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }, { constraints: [] }],\n  parameters: [\n    new TypeTagStruct(objectStructTag(new TypeTagGeneric(0))),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagGeneric(1),\n  ],\n};\n\n/**\n * Creates a transaction to add a typed property to a digital asset.\n * This function helps in customizing digital assets by associating them with specific properties.\n *\n * @param args - The arguments required to create the transaction.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.creator - The account that is creating the transaction.\n * @param args.propertyKey - The key for the property being added.\n * @param args.propertyType - The type of the property being added.\n * @param args.propertyValue - The value of the property being added.\n * @param args.digitalAssetAddress - The address of the digital asset to which the property is being added.\n * @param args.digitalAssetType - (Optional) The type of the digital asset.\n * @param args.options - (Optional) Additional options for generating the transaction.\n * @group Implementation\n */\nexport async function addDigitalAssetTypedPropertyTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  propertyKey: string;\n  propertyType: PropertyType;\n  propertyValue: PropertyValue;\n  digitalAssetAddress: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const {\n    aptosConfig,\n    creator,\n    propertyKey,\n    propertyType,\n    propertyValue,\n    digitalAssetAddress,\n    digitalAssetType,\n    options,\n  } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::add_typed_property\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType, PropertyTypeMap[propertyType]],\n      functionArguments: [AccountAddress.from(digitalAssetAddress), new MoveString(propertyKey), propertyValue],\n      abi: addDigitalAssetTypedPropertyAbi,\n    },\n    options,\n  });\n}\n\nconst updateDigitalAssetTypedPropertyAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }, { constraints: [] }],\n  parameters: [\n    new TypeTagStruct(objectStructTag(new TypeTagGeneric(0))),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagGeneric(1),\n  ],\n};\n\n/**\n * Updates the typed property of a digital asset by generating a transaction for the Aptos blockchain.\n *\n * @param args - The arguments for updating the digital asset typed property.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.creator - The account that is creating the transaction.\n * @param args.propertyKey - The key of the property to be updated.\n * @param args.propertyType - The type of the property being updated.\n * @param args.propertyValue - The new value for the property.\n * @param args.digitalAssetAddress - The address of the digital asset to be updated.\n * @param args.digitalAssetType - Optional. The type of the digital asset, if not provided, defaults to the standard type.\n * @param args.options - Optional. Additional options for generating the transaction.\n * @group Implementation\n */\nexport async function updateDigitalAssetTypedPropertyTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  propertyKey: string;\n  propertyType: PropertyType;\n  propertyValue: PropertyValue;\n  digitalAssetAddress: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const {\n    aptosConfig,\n    creator,\n    propertyKey,\n    propertyType,\n    propertyValue,\n    digitalAssetAddress,\n    digitalAssetType,\n    options,\n  } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::update_typed_property\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType, PropertyTypeMap[propertyType]],\n      functionArguments: [AccountAddress.from(digitalAssetAddress), new MoveString(propertyKey), propertyValue],\n      abi: updateDigitalAssetTypedPropertyAbi,\n    },\n    options,\n  });\n}\n\nfunction getPropertyValueRaw(propertyValues: Array<PropertyValue>, propertyTypes: Array<string>): Array<Uint8Array> {\n  const results = new Array<Uint8Array>();\n  propertyTypes.forEach((typ, index) => {\n    results.push(getSinglePropertyValueRaw(propertyValues[index], typ));\n  });\n\n  return results;\n}\n\nfunction getSinglePropertyValueRaw(propertyValue: PropertyValue, propertyType: string): Uint8Array {\n  const typeTag = parseTypeTag(propertyType);\n  const res = checkOrConvertArgument(propertyValue, typeTag, 0, []);\n  return res.bcsToBytes();\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  AnyNumber,\n  GetCollectionDataResponse,\n  GetCurrentTokenOwnershipResponse,\n  GetOwnedTokensResponse,\n  GetTokenActivityResponse,\n  GetTokenDataResponse,\n  MoveStructId,\n  OrderByArg,\n  PaginationArgs,\n  TokenStandardArg,\n} from \"../types\";\nimport { AccountAddress, AccountAddressInput } from \"../core\";\nimport { Account } from \"../account\";\nimport { InputGenerateTransactionOptions } from \"../transactions/types\";\nimport {\n  addDigitalAssetPropertyTransaction,\n  addDigitalAssetTypedPropertyTransaction,\n  burnDigitalAssetTransaction,\n  CreateCollectionOptions,\n  createCollectionTransaction,\n  freezeDigitalAssetTransferTransaction,\n  getCollectionData,\n  getCollectionDataByCollectionId,\n  getCollectionDataByCreatorAddress,\n  getCollectionDataByCreatorAddressAndCollectionName,\n  getCollectionId,\n  getCurrentDigitalAssetOwnership,\n  getDigitalAssetActivity,\n  getDigitalAssetData,\n  getOwnedDigitalAssets,\n  mintDigitalAssetTransaction,\n  mintSoulBoundTransaction,\n  PropertyType,\n  PropertyValue,\n  removeDigitalAssetPropertyTransaction,\n  setDigitalAssetDescriptionTransaction,\n  setDigitalAssetNameTransaction,\n  setDigitalAssetURITransaction,\n  transferDigitalAssetTransaction,\n  unfreezeDigitalAssetTransferTransaction,\n  updateDigitalAssetPropertyTransaction,\n  updateDigitalAssetTypedPropertyTransaction,\n} from \"../internal/digitalAsset\";\nimport { ProcessorType } from \"../utils/const\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { waitForIndexerOnVersion } from \"./utils\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\n\n/**\n * A class to query all `DigitalAsset` related queries on Aptos.\n * @group DigitalAsset\n */\nexport class DigitalAsset {\n  /**\n   * Initializes a new instance of the Aptos client with the specified configuration.\n   * This allows you to interact with the Aptos blockchain using the provided settings.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a configuration for the Aptos client\n   *     const config = new AptosConfig({ network: Network.TESTNET }); // Specify your desired network\n   *\n   *     // Initialize the Aptos client with the configuration\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  constructor(readonly config: AptosConfig) {}\n\n  /**\n   * Queries data of a specific collection by the collection creator address and the collection name.\n   * This function is deprecated; use `getCollectionDataByCreatorAddressAndCollectionName` instead.\n   *\n   * If a creator account has two collections with the same name in v1 and v2, you can pass an optional `tokenStandard` parameter\n   * to query a specific standard.\n   *\n   * @param args - The arguments for querying the collection data.\n   * @param args.creatorAddress - The address of the collection's creator.\n   * @param args.collectionName - The name of the collection.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options - Optional parameters for the query.\n   * @param args.options.tokenStandard - The token standard to query.\n   * @returns GetCollectionDataResponse - The response type containing the collection data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Querying collection data by creator address and collection name\n   *   const collection = await aptos.getCollectionData({\n   *     creatorAddress: \"0x1\", // replace with a real creator address\n   *     collectionName: \"myCollection\", // specify your collection name\n   *   });\n   *\n   *   console.log(collection);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async getCollectionData(args: {\n    creatorAddress: AccountAddressInput;\n    collectionName: string;\n    minimumLedgerVersion?: AnyNumber;\n    options?: TokenStandardArg;\n  }): Promise<GetCollectionDataResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n\n    const { creatorAddress, collectionName, options } = args;\n    const address = AccountAddress.from(creatorAddress);\n\n    const whereCondition: any = {\n      collection_name: { _eq: collectionName },\n      creator_address: { _eq: address.toStringLong() },\n    };\n    if (options?.tokenStandard) {\n      whereCondition.token_standard = { _eq: options?.tokenStandard ?? \"v2\" };\n    }\n\n    return getCollectionData({ aptosConfig: this.config, options: { where: whereCondition } });\n  }\n\n  /**\n   * Queries data of a specific collection by the collection creator address and the collection name.\n   * If a creator account has multiple collections with the same name across different versions,\n   * specify the `tokenStandard` parameter to query a specific standard.\n   *\n   * @param args.creatorAddress - The address of the collection's creator.\n   * @param args.collectionName - The name of the collection.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options.tokenStandard - Optional token standard to query.\n   * @returns GetCollectionDataResponse - The response type containing collection data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching collection data by creator address and collection name\n   *   const collection = await aptos.getCollectionDataByCreatorAddressAndCollectionName({\n   *     creatorAddress: \"0x1\", // replace with a real creator address\n   *     collectionName: \"myCollection\",\n   *     minimumLedgerVersion: 1, // optional, specify if needed\n   *     options: { tokenStandard: \"v2\" } // optional, specify if needed\n   *   });\n   *\n   *   console.log(collection);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async getCollectionDataByCreatorAddressAndCollectionName(args: {\n    creatorAddress: AccountAddressInput;\n    collectionName: string;\n    minimumLedgerVersion?: AnyNumber;\n    options?: TokenStandardArg & PaginationArgs;\n  }): Promise<GetCollectionDataResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n\n    return getCollectionDataByCreatorAddressAndCollectionName({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieves data for a specific collection created by a given creator address.\n   * This function allows you to query collection data while optionally specifying a minimum ledger version and pagination options.\n   *\n   * @param args.creatorAddress - The address of the collection's creator.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options.tokenStandard - Optional token standard to query.\n   * @param args.options.pagination - Optional pagination arguments.\n   * @returns GetCollectionDataResponse - The response type containing collection data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve collection data by creator address\n   *   const collectionData = await aptos.getCollectionDataByCreatorAddress({\n   *     creatorAddress: \"0x1\", // replace with a real creator address\n   *     minimumLedgerVersion: 1, // specify the minimum ledger version if needed\n   *     options: {\n   *       tokenStandard: \"v2\", // specify the token standard if needed\n   *       pagination: { limit: 10, offset: 0 } // specify pagination options if needed\n   *     }\n   *   });\n   *\n   *   console.log(collectionData);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async getCollectionDataByCreatorAddress(args: {\n    creatorAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: TokenStandardArg & PaginationArgs;\n  }): Promise<GetCollectionDataResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n\n    return getCollectionDataByCreatorAddress({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries data of a specific collection by the collection ID.\n   *\n   * @param args.collectionId - The ID of the collection, which is the same as the address of the collection object.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options - Optional parameters for token standard and pagination.\n   * @returns GetCollectionDataResponse - The response type containing the collection data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching collection data by collection ID\n   *   const collection = await aptos.getCollectionDataByCollectionId({\n   *     collectionId: \"0x123\", // replace with a real collection ID\n   *   });\n   *\n   *   console.log(collection);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async getCollectionDataByCollectionId(args: {\n    collectionId: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: TokenStandardArg & PaginationArgs;\n  }): Promise<GetCollectionDataResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getCollectionDataByCollectionId({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries the ID of a specified collection.\n   * This ID corresponds to the collection's object address in V2, while V1 does not utilize objects and lacks an address.\n   *\n   * @param args.creatorAddress - The address of the collection's creator.\n   * @param args.collectionName - The name of the collection.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options.tokenStandard - The token standard to query.\n   * @returns The collection ID.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching the collection ID for a specific creator and collection name\n   *   const collectionId = await aptos.getCollectionId({\n   *     creatorAddress: \"0x1\", // replace with a real creator address\n   *     collectionName: \"myCollection\"\n   *   });\n   *\n   *   console.log(\"Collection ID:\", collectionId);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async getCollectionId(args: {\n    creatorAddress: AccountAddressInput;\n    collectionName: string;\n    minimumLedgerVersion?: AnyNumber;\n    options?: TokenStandardArg;\n  }): Promise<string> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getCollectionId({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieves digital asset data using the address of a digital asset.\n   *\n   * @param args - The parameters for the request.\n   * @param args.digitalAssetAddress - The address of the digital asset.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @returns GetTokenDataResponse containing relevant data for the digital asset.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching digital asset data for a specific address\n   *   const digitalAsset = await aptos.getDigitalAssetData({\n   *     digitalAssetAddress: \"0x123\", // replace with a real digital asset address\n   *   });\n   *\n   *   console.log(digitalAsset);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async getDigitalAssetData(args: {\n    digitalAssetAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<GetTokenDataResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getDigitalAssetData({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieves the current ownership data of a specified digital asset using its address.\n   *\n   * @param args The parameters for the request.\n   * @param args.digitalAssetAddress The address of the digital asset.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to before querying.\n   *\n   * @returns GetCurrentTokenOwnershipResponse containing relevant ownership data of the digital asset.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Getting the current ownership of a digital asset\n   *   const digitalAssetOwner = await aptos.getCurrentDigitalAssetOwnership({\n   *     digitalAssetAddress: \"0x123\", // replace with a real digital asset address\n   *   });\n   *\n   *   console.log(digitalAssetOwner);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async getCurrentDigitalAssetOwnership(args: {\n    digitalAssetAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<GetCurrentTokenOwnershipResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getCurrentDigitalAssetOwnership({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieves the digital assets owned by a specified address.\n   *\n   * @param args.ownerAddress The address of the owner.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to before querying.\n   * @param args.options Optional pagination and ordering parameters for the response.\n   *\n   * @returns GetOwnedTokensResponse containing ownership data of the digital assets belonging to the ownerAddress.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching the digital assets owned by the specified address\n   *   const digitalAssets = await aptos.getOwnedDigitalAssets({\n   *     ownerAddress: \"0x1\", // replace with a real account address\n   *   });\n   *\n   *   console.log(digitalAssets);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async getOwnedDigitalAssets(args: {\n    ownerAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & OrderByArg<GetOwnedTokensResponse[0]>;\n  }): Promise<GetOwnedTokensResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getOwnedDigitalAssets({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieves the activity data for a specified digital asset using its address.\n   *\n   * @param args - The parameters for the request.\n   * @param args.digitalAssetAddress - The address of the digital asset.\n   * @param args.minimumLedgerVersion - Optional minimum ledger version to sync up to before querying.\n   * @param args.options - Optional pagination and ordering parameters.\n   *\n   * @returns A promise that resolves to the activity data related to the digital asset.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the activity data for a digital asset\n   *   const digitalAssetActivity = await aptos.getDigitalAssetActivity({\n   *     digitalAssetAddress: \"0x123\", // replace with a real digital asset address\n   *   });\n   *\n   *   console.log(digitalAssetActivity);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async getDigitalAssetActivity(args: {\n    digitalAssetAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & OrderByArg<GetTokenActivityResponse[0]>;\n  }): Promise<GetTokenActivityResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getDigitalAssetActivity({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Creates a new collection within the specified account.\n   *\n   * @param args.creator - The account of the collection's creator.\n   * @param args.description - The description of the collection.\n   * @param args.name - The name of the collection.\n   * @param args.uri - The URI to additional info about the collection.\n   * @param args.options - Optional parameters for generating the transaction.\n   *\n   * The parameters below are optional:\n   * @param args.maxSupply - Controls the max supply of the digital assets. Defaults to MAX_U64_BIG_INT.\n   * @param args.mutableDescription - Controls mutability of the collection's description. Defaults to true.\n   * @param args.mutableRoyalty - Controls mutability of the collection's royalty. Defaults to true.\n   * @param args.mutableUri - Controls mutability of the collection's URI. Defaults to true.\n   * @param args.mutableTokenDescription - Controls mutability of the digital asset's description. Defaults to true.\n   * @param args.mutableTokenName - Controls mutability of the digital asset's name. Defaults to true.\n   * @param args.mutableTokenProperties - Controls mutability of digital asset's properties. Defaults to true.\n   * @param args.mutableTokenUri - Controls mutability of the digital asset's URI. Defaults to true.\n   * @param args.tokensBurnableByCreator - Controls whether digital assets can be burnable by the creator. Defaults to true.\n   * @param args.tokensFreezableByCreator - Controls whether digital assets can be frozen by the creator. Defaults to true.\n   * @param args.royaltyNumerator - The numerator of the royalty to be paid to the creator when a digital asset is transferred.\n   * Defaults to 0.\n   * @param args.royaltyDenominator - The denominator of the royalty to be paid to the creator when a digital asset is\n   * transferred. Defaults to 1.\n   *\n   * @returns A SimpleTransaction that when submitted will create the collection.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Creating a new collection transaction\n   *   const transaction = await aptos.createCollectionTransaction({\n   *     creator: Account.generate(), // Replace with a real account\n   *     description: \"A unique collection of digital assets.\",\n   *     name: \"My Digital Collection\",\n   *     uri: \"https://mycollection.com\",\n   *   });\n   *\n   *   console.log(\"Transaction created:\", transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async createCollectionTransaction(\n    args: {\n      creator: Account;\n      description: string;\n      name: string;\n      uri: string;\n      options?: InputGenerateTransactionOptions;\n    } & CreateCollectionOptions,\n  ): Promise<SimpleTransaction> {\n    return createCollectionTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Create a transaction to mint a digital asset into the creator's account within an existing collection.\n   * This function helps you generate a transaction that can be simulated or submitted to the blockchain for minting a digital asset.\n   *\n   * @param args.creator - The creator of the collection.\n   * @param args.collection - The name of the collection the digital asset belongs to.\n   * @param args.description - The description of the digital asset.\n   * @param args.name - The name of the digital asset.\n   * @param args.uri - The URI to additional info about the digital asset.\n   * @param args.propertyKeys - Optional array of property keys for the digital asset.\n   * @param args.propertyTypes - Optional array of property types for the digital asset.\n   * @param args.propertyValues - Optional array of property values for the digital asset.\n   * @param args.options - Optional transaction generation options.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Creating a transaction to mint a digital asset\n   *   const transaction = await aptos.mintDigitalAssetTransaction({\n   *     creator: Account.generate(), // replace with a real account\n   *     collection: \"MyCollection\",\n   *     description: \"This is a digital asset.\",\n   *     name: \"MyDigitalAsset\",\n   *     uri: \"https://example.com/my-digital-asset\",\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async mintDigitalAssetTransaction(args: {\n    creator: Account;\n    collection: string;\n    description: string;\n    name: string;\n    uri: string;\n    propertyKeys?: Array<string>;\n    propertyTypes?: Array<PropertyType>;\n    propertyValues?: Array<PropertyValue>;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return mintDigitalAssetTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Transfer ownership of a non-fungible digital asset.\n   * This function allows you to transfer a digital asset only if it is not frozen, meaning the ownership transfer is not disabled.\n   *\n   * @param args The arguments for transferring the digital asset.\n   * @param args.sender The sender account of the current digital asset owner.\n   * @param args.digitalAssetAddress The address of the digital asset being transferred.\n   * @param args.recipient The account address of the recipient.\n   * @param args.digitalAssetType Optional. The type of the digital asset, defaults to \"0x4::token::Token\".\n   * @param args.options Optional. Additional options for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Transfer a digital asset\n   *   const transaction = await aptos.transferDigitalAssetTransaction({\n   *     sender: Account.generate(), // replace with a real sender account\n   *     digitalAssetAddress: \"0x123\", // replace with a real digital asset address\n   *     recipient: \"0x456\", // replace with a real recipient account address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async transferDigitalAssetTransaction(args: {\n    sender: Account;\n    digitalAssetAddress: AccountAddressInput;\n    recipient: AccountAddress;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return transferDigitalAssetTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Mint a soul bound digital asset into a recipient's account.\n   * This function allows you to create a unique digital asset that is bound to a specific account.\n   *\n   * @param args - The arguments for minting the soul bound transaction.\n   * @param args.account - The account that mints the digital asset.\n   * @param args.collection - The collection name that the digital asset belongs to.\n   * @param args.description - The digital asset description.\n   * @param args.name - The digital asset name.\n   * @param args.uri - The digital asset URL.\n   * @param args.recipient - The account address where the digital asset will be created.\n   * @param args.propertyKeys - The property keys for storing on-chain properties.\n   * @param args.propertyTypes - The type of property values.\n   * @param args.propertyValues - The property values to be stored on-chain.\n   * @param args.options - Additional options for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Mint a soul bound digital asset\n   *   const transaction = await aptos.mintSoulBoundTransaction({\n   *     account: Account.generate(), // Replace with a real account\n   *     collection: \"collectionName\",\n   *     description: \"collectionDescription\",\n   *     name: \"digitalAssetName\",\n   *     uri: \"digital-asset-uri.com\",\n   *     recipient: \"0x123\" // Replace with a real recipient account address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async mintSoulBoundTransaction(args: {\n    account: Account;\n    collection: string;\n    description: string;\n    name: string;\n    uri: string;\n    recipient: AccountAddressInput;\n    propertyKeys?: Array<string>;\n    propertyTypes?: Array<PropertyType>;\n    propertyValues?: Array<PropertyValue>;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return mintSoulBoundTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Burn a digital asset by its creator, allowing for the removal of a specified digital asset from the blockchain.\n   *\n   * @param args The arguments for burning the digital asset.\n   * @param args.creator The creator account that is burning the digital asset.\n   * @param args.digitalAssetAddress The address of the digital asset to be burned.\n   * @param args.digitalAssetType Optional. The type of the digital asset being burned.\n   * @param args.options Optional. Additional options for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Account } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const creator = Account.generate(); // Replace with a real creator account\n   *   const transaction = await aptos.burnDigitalAssetTransaction({\n   *     creator: creator,\n   *     digitalAssetAddress: \"0x123\", // Replace with a real digital asset address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async burnDigitalAssetTransaction(args: {\n    creator: Account;\n    digitalAssetAddress: AccountAddressInput;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    return burnDigitalAssetTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Freeze the ability to transfer a specified digital asset.\n   * This function allows the creator to restrict the transfer capability of a digital asset.\n   *\n   * @param args The arguments for freezing the digital asset transfer.\n   * @param args.creator The creator account initiating the freeze.\n   * @param args.digitalAssetAddress The address of the digital asset to be frozen.\n   * @param args.digitalAssetType Optional. The type of the digital asset being frozen.\n   * @param args.options Optional. Additional options for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Freeze the digital asset transfer\n   *   const transaction = await aptos.freezeDigitalAssetTransaferTransaction({\n   *     creator: Account.generate(), // Replace with a real account if needed\n   *     digitalAssetAddress: \"0x123\", // Replace with a real digital asset address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async freezeDigitalAssetTransaferTransaction(args: {\n    creator: Account;\n    digitalAssetAddress: AccountAddressInput;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    return freezeDigitalAssetTransferTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Unfreeze the ability to transfer a digital asset.\n   * This function allows the specified creator account to unfreeze the transfer of a digital asset identified by its address.\n   *\n   * @param args The parameters for unfreezing the digital asset transfer.\n   * @param args.creator The creator account that is unfreezing the digital asset transfer.\n   * @param args.digitalAssetAddress The address of the digital asset to unfreeze.\n   * @param args.digitalAssetType Optional. The type of the digital asset being unfrozen.\n   * @param args.options Optional. Additional options for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Unfreeze the ability to transfer a digital asset\n   *   const transaction = await aptos.unfreezeDigitalAssetTransaferTransaction({\n   *     creator: Account.generate(), // replace with a real creator account\n   *     digitalAssetAddress: \"0x123\", // replace with a real digital asset address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  // TODO: Rename Transafer to Transfer\n  async unfreezeDigitalAssetTransaferTransaction(args: {\n    creator: Account;\n    digitalAssetAddress: AccountAddressInput;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    return unfreezeDigitalAssetTransferTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Set the digital asset description to provide additional context or information about the asset.\n   *\n   * @param args The parameters for setting the digital asset description.\n   * @param args.creator The creator account responsible for the digital asset.\n   * @param args.description The digital asset description to be set.\n   * @param args.digitalAssetAddress The address of the digital asset.\n   * @param args.digitalAssetType Optional. The type of the digital asset.\n   * @param args.options Optional. Additional options for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Set the digital asset description\n   *   const transaction = await aptos.setDigitalAssetDescriptionTransaction({\n   *     creator: Account.generate(), // replace with a real account\n   *     description: \"This is a digital asset description.\",\n   *     digitalAssetAddress: \"0x123\", // replace with a real digital asset address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async setDigitalAssetDescriptionTransaction(args: {\n    creator: Account;\n    description: string;\n    digitalAssetAddress: AccountAddressInput;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    return setDigitalAssetDescriptionTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Set the digital asset name, allowing you to define a name for a specific digital asset on the blockchain.\n   *\n   * @param args The parameters for setting the digital asset name.\n   * @param args.creator The creator account responsible for the transaction.\n   * @param args.name The desired name for the digital asset.\n   * @param args.digitalAssetAddress The address of the digital asset.\n   * @param args.digitalAssetType Optional. The type of the digital asset, represented as a Move struct ID.\n   * @param args.options Optional. Additional options for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the blockchain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Account } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const creator = Account.generate(); // Generate a new account for the creator\n   *   const digitalAssetAddress = \"0x123\"; // replace with a real digital asset address\n   *\n   *   // Set the digital asset name\n   *   const transaction = await aptos.setDigitalAssetNameTransaction({\n   *     creator: creator,\n   *     name: \"digitalAssetName\",\n   *     digitalAssetAddress: digitalAssetAddress,\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async setDigitalAssetNameTransaction(args: {\n    creator: Account;\n    name: string;\n    digitalAssetAddress: AccountAddressInput;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    return setDigitalAssetNameTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Set the URI for a digital asset, allowing you to associate a unique identifier with the asset.\n   *\n   * @param args The parameters for the transaction.\n   * @param args.creator The creator account initiating the transaction.\n   * @param args.uri The digital asset URI to be set.\n   * @param args.digitalAssetAddress The address of the digital asset.\n   * @param args.digitalAssetType Optional. The type of the digital asset.\n   * @param args.options Optional. Additional options for generating the transaction.\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Set the URI for a digital asset\n   *   const transaction = await aptos.setDigitalAssetURITransaction({\n   *     creator: Account.generate(), // Replace with a real creator account\n   *     uri: \"digital-asset-uri.com\",\n   *     digitalAssetAddress: \"0x123\", // Replace with a real digital asset address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async setDigitalAssetURITransaction(args: {\n    creator: Account;\n    uri: string;\n    digitalAssetAddress: AccountAddressInput;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    return setDigitalAssetURITransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Add a digital asset property to the blockchain.\n   * This function allows you to specify a new property for a digital asset, including its key, type, and value.\n   *\n   * @param args - The arguments for adding a digital asset property.\n   * @param args.creator - The account that mints the digital asset.\n   * @param args.propertyKey - The property key for storing on-chain properties.\n   * @param args.propertyType - The type of property value.\n   * @param args.propertyValue - The property value to be stored on-chain.\n   * @param args.digitalAssetAddress - The digital asset address.\n   * @param args.digitalAssetType - (Optional) The type of the digital asset.\n   * @param args.options - (Optional) Options for generating the transaction.\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Add a digital asset property\n   *   const transaction = await aptos.addDigitalAssetPropertyTransaction({\n   *     creator: Account.generate(), // Replace with a real account\n   *     propertyKey: \"newKey\",\n   *     propertyType: \"BOOLEAN\",\n   *     propertyValue: true,\n   *     digitalAssetAddress: \"0x123\", // Replace with a real digital asset address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async addDigitalAssetPropertyTransaction(args: {\n    creator: Account;\n    propertyKey: string;\n    propertyType: PropertyType;\n    propertyValue: PropertyValue;\n    digitalAssetAddress: AccountAddressInput;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    return addDigitalAssetPropertyTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Remove a digital asset property from the blockchain.\n   * This function allows you to delete an existing property associated with a digital asset.\n   *\n   * @param args The parameters required to remove the digital asset property.\n   * @param args.creator The account that mints the digital asset.\n   * @param args.propertyKey The property key for storing on-chain properties.\n   * @param args.propertyType The type of property value.\n   * @param args.propertyValue The property value to be stored on-chain.\n   * @param args.digitalAssetAddress The digital asset address.\n   * @param args.digitalAssetType Optional. The type of the digital asset.\n   * @param args.options Optional. Additional options for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Remove a digital asset property\n   *   const transaction = await aptos.removeDigitalAssetPropertyTransaction({\n   *     creator: Account.generate(), // replace with a real account\n   *     propertyKey: \"newKey\",\n   *     propertyType: \"BOOLEAN\",\n   *     propertyValue: true,\n   *     digitalAssetAddress: \"0x123\", // replace with a real digital asset address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async removeDigitalAssetPropertyTransaction(args: {\n    creator: Account;\n    propertyKey: string;\n    propertyType: PropertyType;\n    propertyValue: PropertyValue;\n    digitalAssetAddress: AccountAddressInput;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    return removeDigitalAssetPropertyTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Update a digital asset property on-chain.\n   *\n   * @param args The parameters for updating the digital asset property.\n   * @param args.creator The account that mints the digital asset.\n   * @param args.digitalAssetAddress The address of the digital asset.\n   * @param args.propertyKey The property key for storing on-chain properties.\n   * @param args.propertyType The type of property value.\n   * @param args.propertyValue The property value to be stored on-chain.\n   * @param args.digitalAssetType Optional. The type of the digital asset.\n   * @param args.options Optional. Additional options for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Update a digital asset property\n   *   const transaction = await aptos.updateDigitalAssetPropertyTransaction({\n   *     creator: Account.generate(), // replace with a real account\n   *     propertyKey: \"newKey\",\n   *     propertyType: \"BOOLEAN\",\n   *     propertyValue: false,\n   *     digitalAssetAddress: \"0x123\", // replace with a real digital asset address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async updateDigitalAssetPropertyTransaction(args: {\n    creator: Account;\n    propertyKey: string;\n    propertyType: PropertyType;\n    propertyValue: PropertyValue;\n    digitalAssetAddress: AccountAddressInput;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    return updateDigitalAssetPropertyTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Add a typed digital asset property to the blockchain.\n   * This function allows you to define and store a specific property for a digital asset, enabling better categorization and\n   * management of digital assets.\n   *\n   * @param args - The parameters for adding the typed property.\n   * @param args.creator - The account that mints the digital asset.\n   * @param args.propertyKey - The property key for storing on-chain properties.\n   * @param args.propertyType - The type of property value.\n   * @param args.propertyValue - The property value to be stored on-chain.\n   * @param args.digitalAssetAddress - The digital asset address.\n   * @param args.digitalAssetType - The optional type of the digital asset.\n   * @param args.options - Optional transaction generation options.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Adding a typed digital asset property\n   *   const transaction = await aptos.addDigitalAssetTypedPropertyTransaction({\n   *     creator: Account.generate(), // replace with a real account\n   *     propertyKey: \"typedKey\",\n   *     propertyType: \"STRING\",\n   *     propertyValue: \"hello\",\n   *     digitalAssetAddress: \"0x123\", // replace with a real digital asset address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async addDigitalAssetTypedPropertyTransaction(args: {\n    creator: Account;\n    propertyKey: string;\n    propertyType: PropertyType;\n    propertyValue: PropertyValue;\n    digitalAssetAddress: AccountAddressInput;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    return addDigitalAssetTypedPropertyTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Update a typed digital asset property on-chain.\n   * This function allows you to modify the properties of a digital asset, enabling dynamic updates to its attributes.\n   *\n   * @param args - The arguments for updating the digital asset property.\n   * @param args.creator - The account that mints the digital asset.\n   * @param args.propertyKey - The property key for storing on-chain properties.\n   * @param args.propertyType - The type of property value.\n   * @param args.propertyValue - The property value to be stored on-chain.\n   * @param args.digitalAssetAddress - The digital asset address.\n   * @param args.digitalAssetType - (Optional) The type of the digital asset.\n   * @param args.options - (Optional) Additional options for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Update a typed digital asset property\n   *   const transaction = await aptos.updateDigitalAssetTypedPropertyTransaction({\n   *     creator: Account.generate(), // replace with a real account\n   *     propertyKey: \"typedKey\",\n   *     propertyType: \"U8\",\n   *     propertyValue: 2,\n   *     digitalAssetAddress: \"0x123\", // replace with a real digital asset address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async updateDigitalAssetTypedPropertyTransaction(args: {\n    creator: Account;\n    propertyKey: string;\n    propertyType: PropertyType;\n    propertyValue: PropertyValue;\n    digitalAssetAddress: AccountAddressInput;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    return updateDigitalAssetTypedPropertyTransaction({ aptosConfig: this.config, ...args });\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/event}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * event namespace and without having a dependency cycle error.\n * @group Implementation\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { AccountAddress, AccountAddressInput } from \"../core\";\nimport { AnyNumber, GetEventsResponse, PaginationArgs, MoveStructId, OrderByArg, WhereArg } from \"../types\";\nimport { GetEventsQuery } from \"../types/generated/operations\";\nimport { GetEvents } from \"../types/generated/queries\";\nimport { EventsBoolExp, InputMaybe } from \"../types/generated/types\";\nimport { queryIndexer } from \"./general\";\n\nconst MAX_EVENT_TYPE_LENGTH = 300;\nconst checkEventTypeLength = (eventType?: InputMaybe<string>) => {\n  if (eventType && eventType.length > MAX_EVENT_TYPE_LENGTH) {\n    throw new Error(`Event type length exceeds the maximum length of ${MAX_EVENT_TYPE_LENGTH}`);\n  }\n};\n\n/**\n * Retrieves events associated with a specific module event type.\n * This function allows you to filter events based on the event type and pagination options.\n *\n * @param args - The arguments for retrieving module events.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.eventType - The MoveStructId representing the type of event to retrieve.\n * @param [args.options] - Optional pagination and ordering parameters for the event retrieval.\n * @group Implementation\n */\nexport async function getModuleEventsByEventType(args: {\n  aptosConfig: AptosConfig;\n  eventType: MoveStructId;\n  options?: PaginationArgs & OrderByArg<GetEventsResponse[0]>;\n}): Promise<GetEventsResponse> {\n  const { aptosConfig, eventType, options } = args;\n\n  const whereCondition: EventsBoolExp = {\n    _or: [\n      // EventHandle events\n      { account_address: { _eq: eventType.split(\"::\")[0] } },\n      // Module events\n      {\n        account_address: { _eq: \"0x0000000000000000000000000000000000000000000000000000000000000000\" },\n        sequence_number: { _eq: 0 },\n        creation_number: { _eq: 0 },\n      },\n    ],\n    indexed_type: { _eq: eventType },\n  };\n\n  return getEvents({ aptosConfig, options: { ...options, where: whereCondition } });\n}\n\n/**\n * Retrieve events associated with a specific account and creation number.\n *\n * @param args - The parameters for retrieving account events.\n * @param args.aptosConfig - The configuration settings for the Aptos client.\n * @param args.accountAddress - The address of the account for which events are being retrieved.\n * @param args.creationNumber - The creation number to filter events.\n * @param args.options - Optional pagination and ordering parameters for the event retrieval.\n * @group Implementation\n */\nexport async function getAccountEventsByCreationNumber(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  creationNumber: AnyNumber;\n  options?: PaginationArgs & OrderByArg<GetEventsResponse[0]>;\n}): Promise<GetEventsResponse> {\n  const { accountAddress, aptosConfig, creationNumber, options } = args;\n  const address = AccountAddress.from(accountAddress);\n\n  const whereCondition: EventsBoolExp = {\n    account_address: { _eq: address.toStringLong() },\n    creation_number: { _eq: creationNumber },\n  };\n\n  return getEvents({ aptosConfig, options: { ...options, where: whereCondition } });\n}\n\n/**\n * Retrieves events associated with a specific account and event type.\n *\n * @param args - The parameters for retrieving account events.\n * @param args.aptosConfig - The configuration for connecting to the Aptos blockchain.\n * @param args.accountAddress - The address of the account for which to retrieve events.\n * @param args.eventType - The type of event to filter by.\n * @param args.options - Optional pagination and ordering parameters for the event retrieval.\n * @group Implementation\n */\nexport async function getAccountEventsByEventType(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  eventType: MoveStructId;\n  options?: PaginationArgs & OrderByArg<GetEventsResponse[0]>;\n}): Promise<GetEventsResponse> {\n  const { accountAddress, aptosConfig, eventType, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: EventsBoolExp = {\n    account_address: { _eq: address },\n    indexed_type: { _eq: eventType },\n  };\n\n  return getEvents({ aptosConfig, options: { ...options, where: whereCondition } });\n}\n\n/**\n * Retrieves a list of events based on specified filtering and pagination options.\n *\n * @param args - The arguments for retrieving events.\n * @param args.aptosConfig - The configuration for connecting to the Aptos network.\n * @param [args.options] - Optional parameters for pagination and filtering.\n * @param [args.options.offset] - The number of records to skip before starting to collect the result set.\n * @param [args.options.limit] - The maximum number of records to return.\n * @param [args.options.orderBy] - Defines the order in which to return the events.\n * @param [args.options.where] - Conditions to filter the events.\n * @param [args.options.where.indexed_type] - Filters events by the indexed type.\n * @group Implementation\n */\nexport async function getEvents(args: {\n  aptosConfig: AptosConfig;\n  options?: PaginationArgs & OrderByArg<GetEventsResponse[0]> & WhereArg<EventsBoolExp>;\n}): Promise<GetEventsResponse> {\n  const { aptosConfig, options } = args;\n\n  /**\n   * Checks the length of event types based on the provided filtering options.\n   *\n   * @param options - The options for querying event types.\n   * @param options.where - The conditions to filter the event types.\n   * @param options.where.indexed_type - The indexed type to filter by.\n   * @param options.where.indexed_type._eq - The specific value to match for the indexed type.\n   * @param options.offset - The number of items to skip before starting to collect the result set.\n   * @param options.limit - The maximum number of items to return.\n   * @param options.orderBy - The criteria to sort the results.\n   * @group Implementation\n   */\n  // eslint-disable-next-line no-underscore-dangle\n  checkEventTypeLength(options?.where?.indexed_type?._eq);\n\n  const graphqlQuery = {\n    query: GetEvents,\n    variables: {\n      where_condition: options?.where,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetEventsQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getEvents\",\n  });\n\n  return data.events;\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  getAccountEventsByCreationNumber,\n  getAccountEventsByEventType,\n  getModuleEventsByEventType,\n  getEvents,\n} from \"../internal/event\";\nimport { AnyNumber, GetEventsResponse, MoveStructId, OrderByArg, PaginationArgs, WhereArg } from \"../types\";\nimport { EventsBoolExp } from \"../types/generated/types\";\nimport { AccountAddressInput } from \"../core\";\nimport { ProcessorType } from \"../utils/const\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { waitForIndexerOnVersion } from \"./utils\";\n\n/**\n * A class to query all `Event` Aptos related queries.\n * @group Event\n */\nexport class Event {\n  /**\n   * Initializes a new instance of the Aptos client with the provided configuration.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   * @param config.network - The network to connect to (e.g., Testnet, Mainnet).\n   * @param config.nodeUrl - The URL of the Aptos node to connect to.\n   * @param config.faucetUrl - The URL of the faucet to use for funding accounts.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a new Aptos client with Testnet configuration\n   *     const config = new AptosConfig({ network: Network.TESTNET }); // Specify your own network if needed\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Event\n   */\n  constructor(readonly config: AptosConfig) {}\n\n  /**\n   * Retrieve module events based on a specified event type.\n   * This function allows you to query for events that are associated with a particular module event type in the Aptos blockchain.\n   *\n   * @param args - The arguments for retrieving module events.\n   * @param args.eventType - The event type to filter the results.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options - Optional pagination and ordering parameters for the event results.\n   *\n   * @returns Promise<GetEventsResponse> - A promise that resolves to the retrieved events.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve module events for a specific event type\n   *   const events = await aptos.getModuleEventsByEventType({\n   *     eventType: \"0x1::transaction_fee::FeeStatement\", // specify the event type\n   *     minimumLedgerVersion: 1, // optional: specify minimum ledger version if needed\n   *   });\n   *\n   *   console.log(events); // log the retrieved events\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Event\n   */\n  async getModuleEventsByEventType(args: {\n    eventType: MoveStructId;\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & OrderByArg<GetEventsResponse[0]>;\n  }): Promise<GetEventsResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.EVENTS_PROCESSOR,\n    });\n    return getModuleEventsByEventType({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieve events associated with a specific account address and creation number.\n   *\n   * @param args - The parameters for retrieving account events.\n   * @param args.accountAddress - The account address to query events for.\n   * @param args.creationNumber - The event creation number to filter the events.\n   * @param args.minimumLedgerVersion - Optional minimum ledger version to sync up to before querying.\n   *\n   * @returns Promise<GetEventsResponse>\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get events for the account at creation number 0\n   *   const events = await aptos.getAccountEventsByCreationNumber({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     creationNumber: 0,\n   *   });\n   *\n   *   console.log(events);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Event\n   */\n  async getAccountEventsByCreationNumber(args: {\n    accountAddress: AccountAddressInput;\n    creationNumber: AnyNumber;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<GetEventsResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.EVENTS_PROCESSOR,\n    });\n    return getAccountEventsByCreationNumber({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieve events associated with a specific account address and event type.\n   *\n   * @param args.accountAddress - The account address to query events for.\n   * @param args.eventType - The type of event to filter by.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options - Optional pagination and ordering parameters for the event query.\n   *\n   * @returns Promise<GetEventsResponse>\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get events for a specific account and event type\n   *   const events = await aptos.getAccountEventsByEventType({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     eventType: \"0x1::transaction_fee::FeeStatement\", // replace with a real event type\n   *     minimumLedgerVersion: 1, // optional, specify if needed\n   *   });\n   *\n   *   console.log(events);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Event\n   */\n  async getAccountEventsByEventType(args: {\n    accountAddress: AccountAddressInput;\n    eventType: MoveStructId;\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & OrderByArg<GetEventsResponse[0]>;\n  }): Promise<GetEventsResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.EVENTS_PROCESSOR,\n    });\n    return getAccountEventsByEventType({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieve all events from the Aptos blockchain.\n   * An optional `where` clause can be provided to filter the results based on specific criteria.\n   *\n   * @param args Optional parameters for the query.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to before querying.\n   * @param args.options Optional pagination and filtering options.\n   * @param args.options.where Optional condition to filter events.\n   * @param args.options.offset Optional pagination offset.\n   * @param args.options.limit Optional maximum number of events to return.\n   * @param args.options.orderBy Optional ordering of the results.\n   *\n   * @returns GetEventsQuery response type containing the events.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve all events\n   *   const events = await aptos.getEvents();\n   *\n   *   // Retrieve events with filtering by account address\n   *   const whereCondition = {\n   *     account_address: { _eq: \"0x123\" }, // replace with a real account address\n   *   };\n   *   const filteredEvents = await aptos.getEvents({\n   *     options: { where: whereCondition },\n   *   });\n   *\n   *   console.log(events);\n   *   console.log(filteredEvents);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Event\n   */\n  async getEvents(args?: {\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & OrderByArg<GetEventsResponse[0]> & WhereArg<EventsBoolExp>;\n  }): Promise<GetEventsResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args?.minimumLedgerVersion,\n      processorType: ProcessorType.EVENTS_PROCESSOR,\n    });\n    return getEvents({ aptosConfig: this.config, ...args });\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/faucet}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * faucet namespace and without having a dependency cycle error.\n * @group Implementation\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { postAptosFaucet } from \"../client\";\nimport { AccountAddress, AccountAddressInput } from \"../core\";\nimport { TransactionResponseType, UserTransactionResponse, WaitForTransactionOptions } from \"../types\";\nimport { DEFAULT_TXN_TIMEOUT_SEC } from \"../utils/const\";\nimport { waitForTransaction } from \"./transaction\";\n\n/**\n * Funds an account with a specified amount of tokens from the Aptos faucet.\n * This function is useful for quickly providing a new or existing account with tokens to facilitate transactions.\n *\n * Note that only devnet has a publicly accessible faucet. For testnet, you must use\n * the minting page at https://aptos.dev/network/faucet.\n *\n * @param args - The arguments for funding the account.\n * @param args.aptosConfig - The configuration settings for connecting to the Aptos network.\n * @param args.accountAddress - The address of the account to be funded.\n * @param args.amount - The amount of tokens to fund the account with.\n * @param args.options - Optional parameters for the transaction.\n * @param args.options.timeoutSecs - The maximum time to wait for the transaction to complete, in seconds.\n * @param args.options.checkSuccess - A flag indicating whether to check if the transaction was successful.\n *\n * @throws Error if the transaction does not return a user transaction type.\n * @group Implementation\n */\nexport async function fundAccount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  amount: number;\n  options?: WaitForTransactionOptions;\n}): Promise<UserTransactionResponse> {\n  const { aptosConfig, accountAddress, amount, options } = args;\n  const timeout = options?.timeoutSecs || DEFAULT_TXN_TIMEOUT_SEC;\n  const { data } = await postAptosFaucet<any, { txn_hashes: Array<string> }>({\n    aptosConfig,\n    path: \"fund\",\n    body: {\n      address: AccountAddress.from(accountAddress).toString(),\n      amount,\n    },\n    originMethod: \"fundAccount\",\n  });\n\n  const txnHash = data.txn_hashes[0];\n\n  const res = await waitForTransaction({\n    aptosConfig,\n    transactionHash: txnHash,\n    options: {\n      timeoutSecs: timeout,\n      checkSuccess: options?.checkSuccess,\n    },\n  });\n\n  // Response is always User transaction for a user submitted transaction\n  if (res.type === TransactionResponseType.User) {\n    return res;\n  }\n\n  throw new Error(`Unexpected transaction received for fund account: ${res.type}`);\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fundAccount } from \"../internal/faucet\";\nimport { UserTransactionResponse, WaitForTransactionOptions } from \"../types\";\nimport { AccountAddressInput } from \"../core\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { waitForIndexer } from \"../internal/transaction\";\nimport { ProcessorType } from \"../utils\";\n\n/**\n * A class to query all `Faucet` related queries on Aptos.\n * @group Faucet\n */\nexport class Faucet {\n  /**\n   * Initializes a new instance of the Aptos client with the specified configuration.\n   *\n   * Note that only devnet has a publicly accessible faucet. For testnet, you must use\n   * the minting page at https://aptos.dev/network/faucet.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a configuration for the Aptos client\n   *     const config = new AptosConfig({ network: Network.DEVNET }); // specify your own network if needed\n   *\n   *     // Initialize the Aptos client with the configuration\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Faucet\n   */\n  constructor(readonly config: AptosConfig) {}\n\n  /**\n   * This function creates an account if it does not exist and mints the specified amount of coins into that account.\n   *\n   * Note that only devnet has a publicly accessible faucet. For testnet, you must use\n   * the minting page at https://aptos.dev/network/faucet.\n   *\n   * @param args - The arguments for funding the account.\n   * @param args.accountAddress - The address of the account to fund.\n   * @param args.amount - The amount of tokens to fund the account with.\n   * @param args.options - Configuration options for waiting for the transaction.\n   * @returns Transaction hash of the transaction that funded the account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.DEVNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fund an account with a specified amount of tokens\n   *   const transaction = await aptos.fundAccount({\n   *     accountAddress: \"0x1\", // replace with your account address\n   *     amount: 100,\n   *   });\n   *\n   *   console.log(\"Transaction hash:\", transaction.hash);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Faucet\n   */\n  async fundAccount(args: {\n    accountAddress: AccountAddressInput;\n    amount: number;\n    options?: WaitForTransactionOptions;\n  }): Promise<UserTransactionResponse> {\n    const fundTxn = await fundAccount({ aptosConfig: this.config, ...args });\n\n    // If the user explicitly says to NOT wait by setting waitForIndexer to false, then we skip this.\n    // But, by default we want to wait for the indexer.\n    if (args.options?.waitForIndexer === undefined || args.options?.waitForIndexer) {\n      await waitForIndexer({\n        aptosConfig: this.config,\n        minimumLedgerVersion: BigInt(fundTxn.version),\n        processorType: ProcessorType.FUNGIBLE_ASSET_PROCESSOR,\n      });\n    }\n\n    return fundTxn;\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/fungible_asset}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * fungible_asset namespace and without having a dependency cycle error.\n * @group Implementation\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport {\n  AnyNumber,\n  GetCurrentFungibleAssetBalancesResponse,\n  GetFungibleAssetActivitiesResponse,\n  GetFungibleAssetMetadataResponse,\n  PaginationArgs,\n  WhereArg,\n} from \"../types\";\nimport { queryIndexer } from \"./general\";\nimport {\n  GetCurrentFungibleAssetBalances,\n  GetFungibleAssetActivities,\n  GetFungibleAssetMetadata,\n} from \"../types/generated/queries\";\nimport {\n  GetCurrentFungibleAssetBalancesQuery,\n  GetFungibleAssetActivitiesQuery,\n  GetFungibleAssetMetadataQuery,\n} from \"../types/generated/operations\";\nimport {\n  CurrentFungibleAssetBalancesBoolExp,\n  FungibleAssetActivitiesBoolExp,\n  FungibleAssetMetadataBoolExp,\n} from \"../types/generated/types\";\nimport { AccountAddressInput } from \"../core\";\nimport { Account } from \"../account\";\nimport {\n  EntryFunctionABI,\n  InputGenerateTransactionOptions,\n  parseTypeTag,\n  TypeTagAddress,\n  TypeTagU64,\n} from \"../transactions\";\nimport { generateTransaction } from \"./transactionSubmission\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\n\n/**\n * Retrieves metadata for fungible assets based on specified criteria.\n * This function allows you to filter and paginate through fungible asset metadata.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration for Aptos.\n * @param [args.options] - Optional parameters for pagination and filtering.\n * @param [args.options.limit] - The maximum number of results to return.\n * @param [args.options.offset] - The number of results to skip before starting to collect the result set.\n * @param [args.options.where] - Conditions to filter the results.\n * @group Implementation\n */\nexport async function getFungibleAssetMetadata(args: {\n  aptosConfig: AptosConfig;\n  options?: PaginationArgs & WhereArg<FungibleAssetMetadataBoolExp>;\n}): Promise<GetFungibleAssetMetadataResponse> {\n  const { aptosConfig, options } = args;\n\n  const graphqlQuery = {\n    query: GetFungibleAssetMetadata,\n    variables: {\n      where_condition: options?.where,\n      limit: options?.limit,\n      offset: options?.offset,\n    },\n  };\n\n  const data = await queryIndexer<GetFungibleAssetMetadataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getFungibleAssetMetadata\",\n  });\n\n  return data.fungible_asset_metadata;\n}\n\n/**\n * Retrieves the activities associated with fungible assets.\n * This function allows you to filter and paginate through the activities based on specified conditions.\n *\n * @param args - The arguments for retrieving fungible asset activities.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param [args.options] - Optional parameters for pagination and filtering.\n * @param [args.options.limit] - The maximum number of activities to retrieve.\n * @param [args.options.offset] - The number of activities to skip before starting to collect the result set.\n * @param [args.options.where] - Conditions to filter the activities.\n * @returns A promise that resolves to an array of fungible asset activities.\n * @group Implementation\n */\nexport async function getFungibleAssetActivities(args: {\n  aptosConfig: AptosConfig;\n  options?: PaginationArgs & WhereArg<FungibleAssetActivitiesBoolExp>;\n}): Promise<GetFungibleAssetActivitiesResponse> {\n  const { aptosConfig, options } = args;\n\n  const graphqlQuery = {\n    query: GetFungibleAssetActivities,\n    variables: {\n      where_condition: options?.where,\n      limit: options?.limit,\n      offset: options?.offset,\n    },\n  };\n\n  const data = await queryIndexer<GetFungibleAssetActivitiesQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getFungibleAssetActivities\",\n  });\n\n  return data.fungible_asset_activities;\n}\n\n/**\n * Retrieves the current balances of fungible assets for a specified configuration.\n *\n * @param args - The arguments for retrieving fungible asset balances.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.options - Optional parameters for pagination and filtering.\n * @param args.options.limit - The maximum number of results to return.\n * @param args.options.offset - The number of results to skip before starting to collect the results.\n * @param args.options.where - Conditions to filter the results based on specific criteria.\n * @returns The current balances of fungible assets.\n * @group Implementation\n */\nexport async function getCurrentFungibleAssetBalances(args: {\n  aptosConfig: AptosConfig;\n  options?: PaginationArgs & WhereArg<CurrentFungibleAssetBalancesBoolExp>;\n}): Promise<GetCurrentFungibleAssetBalancesResponse> {\n  const { aptosConfig, options } = args;\n\n  const graphqlQuery = {\n    query: GetCurrentFungibleAssetBalances,\n    variables: {\n      where_condition: options?.where,\n      limit: options?.limit,\n      offset: options?.offset,\n    },\n  };\n\n  const data = await queryIndexer<GetCurrentFungibleAssetBalancesQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getCurrentFungibleAssetBalances\",\n  });\n\n  return data.current_fungible_asset_balances;\n}\n\nconst faTransferAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [] }],\n  parameters: [parseTypeTag(\"0x1::object::Object\"), new TypeTagAddress(), new TypeTagU64()],\n};\n\n/**\n * Transfers a specified amount of a fungible asset from the sender to the recipient.\n * This function helps facilitate the transfer of digital assets between accounts on the Aptos blockchain.\n *\n * @param args - The parameters for the transfer operation.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.sender - The account initiating the transfer.\n * @param args.fungibleAssetMetadataAddress - The address of the fungible asset's metadata.\n * @param args.recipient - The address of the account receiving the asset.\n * @param args.amount - The amount of the fungible asset to transfer.\n * @param args.options - Optional settings for generating the transaction.\n * @group Implementation\n */\nexport async function transferFungibleAsset(args: {\n  aptosConfig: AptosConfig;\n  sender: Account;\n  fungibleAssetMetadataAddress: AccountAddressInput;\n  recipient: AccountAddressInput;\n  amount: AnyNumber;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, sender, fungibleAssetMetadataAddress, recipient, amount, options } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress,\n    data: {\n      function: \"0x1::primary_fungible_store::transfer\",\n      typeArguments: [\"0x1::fungible_asset::Metadata\"],\n      functionArguments: [fungibleAssetMetadataAddress, recipient, amount],\n      abi: faTransferAbi,\n    },\n    options,\n  });\n}\n\n/**\n * Transfers a specified amount of a fungible asset from any (primary or secondary) fungible store to any (primary or secondary) fungible store.\n * This function helps facilitate the transfer of digital assets between fungible stores on the Aptos blockchain.\n *\n * @param args - The parameters for the transfer operation.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.sender - The account initiating the transfer.\n * @param args.fromStore - The address of the fungible store initiating the transfer.\n * @param args.toStore - The address of the fungible store receiving the asset.\n * @param args.amount - The amount of the fungible asset to transfer. Must be a positive number.\n * @param args.options - Optional settings for generating the transaction.\n * @returns A SimpleTransaction that can be submitted to the blockchain.\n * @throws Error if the transaction generation fails or if the input parameters are invalid.\n * @group Implementation\n */\nexport async function transferFungibleAssetBetweenStores(args: {\n  aptosConfig: AptosConfig;\n  sender: Account;\n  fromStore: AccountAddressInput;\n  toStore: AccountAddressInput;\n  amount: AnyNumber;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, sender, fromStore, toStore, amount, options } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress,\n    data: {\n      function: \"0x1::dispatchable_fungible_asset::transfer\",\n      typeArguments: [\"0x1::fungible_asset::FungibleStore\"],\n      functionArguments: [fromStore, toStore, amount],\n      abi: faTransferAbi,\n    },\n    options,\n  });\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  AnyNumber,\n  GetCurrentFungibleAssetBalancesResponse,\n  GetFungibleAssetActivitiesResponse,\n  GetFungibleAssetMetadataResponse,\n  PaginationArgs,\n  WhereArg,\n} from \"../types\";\nimport {\n  getCurrentFungibleAssetBalances,\n  getFungibleAssetActivities,\n  getFungibleAssetMetadata,\n  transferFungibleAsset,\n  transferFungibleAssetBetweenStores,\n} from \"../internal/fungibleAsset\";\nimport {\n  CurrentFungibleAssetBalancesBoolExp,\n  FungibleAssetActivitiesBoolExp,\n  FungibleAssetMetadataBoolExp,\n} from \"../types/generated/types\";\nimport { ProcessorType } from \"../utils/const\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { waitForIndexerOnVersion } from \"./utils\";\nimport { Account } from \"../account\";\nimport { AccountAddress, AccountAddressInput } from \"../core\";\nimport { InputGenerateTransactionOptions } from \"../transactions\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\n\n/**\n * A class for querying and managing fungible asset-related operations on the Aptos blockchain.\n * @group FungibleAsset\n */\nexport class FungibleAsset {\n  /**\n   * Initializes a new instance of the Aptos class with the provided configuration.\n   * This allows you to interact with the Aptos blockchain using the specified network settings.\n   *\n   * @param config - The configuration settings for connecting to the Aptos network.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a configuration for the Aptos client\n   *     const config = new AptosConfig({ network: Network.TESTNET }); // Specify your own network if needed\n   *\n   *     // Initialize the Aptos client with the configuration\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group FungibleAsset\n   */\n  constructor(readonly config: AptosConfig) {}\n\n  /**\n   * Queries all fungible asset metadata.\n   *\n   * @param args Optional parameters for the query.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to before querying.\n   * @param args.options Optional configuration for pagination and filtering.\n   *\n   * @returns A list of fungible asset metadata.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching fungible asset metadata\n   *   const fungibleAssets = await aptos.getFungibleAssetMetadata();\n   *   console.log(fungibleAssets);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group FungibleAsset\n   */\n  async getFungibleAssetMetadata(args?: {\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & WhereArg<FungibleAssetMetadataBoolExp>;\n  }): Promise<GetFungibleAssetMetadataResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args?.minimumLedgerVersion,\n      processorType: ProcessorType.FUNGIBLE_ASSET_PROCESSOR,\n    });\n    return getFungibleAssetMetadata({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries the fungible asset metadata for a specific asset type.\n   * This function helps retrieve detailed information about a fungible asset based on its type.\n   *\n   * @param args - The parameters for the query.\n   * @param args.assetType - The asset type of the fungible asset, e.g., \"0x1::aptos_coin::AptosCoin\" for Aptos Coin.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   *\n   * @returns A fungible asset metadata item.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve fungible asset metadata by asset type\n   *   const fungibleAsset = await aptos.getFungibleAssetMetadataByAssetType({\n   *     assetType: \"0x1::aptos_coin::AptosCoin\" // replace with your asset type\n   *   });\n   *\n   *   console.log(fungibleAsset);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group FungibleAsset\n   */\n  async getFungibleAssetMetadataByAssetType(args: {\n    assetType: string;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<GetFungibleAssetMetadataResponse[0]> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args?.minimumLedgerVersion,\n      processorType: ProcessorType.FUNGIBLE_ASSET_PROCESSOR,\n    });\n    const data = await getFungibleAssetMetadata({\n      aptosConfig: this.config,\n      options: {\n        where: {\n          asset_type: { _eq: args.assetType },\n        },\n      },\n    });\n\n    return data[0];\n  }\n\n  /**\n   * Retrieves fungible asset metadata based on the creator address.\n   *\n   * This function allows you to query metadata for a specific fungible asset created by a given address.\n   *\n   * @param args - The parameters for the query.\n   * @param args.creatorAddress - The creator address of the fungible asset.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   *\n   * @returns A fungible asset metadata item.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve fungible asset metadata by creator address\n   *   const fungibleAsset = await aptos.getFungibleAssetMetadataByCreatorAddress({\n   *     creatorAddress: \"0x123\", // replace with a real creator address\n   *   });\n   *\n   *   console.log(fungibleAsset);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group FungibleAsset\n   */\n  async getFungibleAssetMetadataByCreatorAddress(args: {\n    creatorAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<GetFungibleAssetMetadataResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args?.minimumLedgerVersion,\n      processorType: ProcessorType.FUNGIBLE_ASSET_PROCESSOR,\n    });\n    const data = await getFungibleAssetMetadata({\n      aptosConfig: this.config,\n      options: {\n        where: {\n          creator_address: { _eq: AccountAddress.from(args.creatorAddress).toStringLong() },\n        },\n      },\n    });\n\n    return data;\n  }\n\n  /**\n   * Queries all fungible asset activities and returns a list of their metadata.\n   *\n   * @param args Optional parameters for the query.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to, before querying.\n   * @param args.options Optional configuration for pagination and filtering.\n   * @returns A list of fungible asset metadata.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching fungible asset activities\n   *   const fungibleAssetActivities = await aptos.getFungibleAssetActivities();\n   *   console.log(fungibleAssetActivities);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group FungibleAsset\n   */\n  async getFungibleAssetActivities(args?: {\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & WhereArg<FungibleAssetActivitiesBoolExp>;\n  }): Promise<GetFungibleAssetActivitiesResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args?.minimumLedgerVersion,\n      processorType: ProcessorType.FUNGIBLE_ASSET_PROCESSOR,\n    });\n    return getFungibleAssetActivities({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries all fungible asset balances.\n   *\n   * @param args Optional parameters for the query.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to, before querying.\n   * @param args.options Optional configuration for pagination and filtering.\n   *\n   * @returns A list of fungible asset metadata.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching current fungible asset balances\n   *   const fungibleAssetBalances = await aptos.getCurrentFungibleAssetBalances();\n   *\n   *   console.log(fungibleAssetBalances);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group FungibleAsset\n   */\n  async getCurrentFungibleAssetBalances(args?: {\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & WhereArg<CurrentFungibleAssetBalancesBoolExp>;\n  }): Promise<GetCurrentFungibleAssetBalancesResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args?.minimumLedgerVersion,\n      processorType: ProcessorType.FUNGIBLE_ASSET_PROCESSOR,\n    });\n    return getCurrentFungibleAssetBalances({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Transfer a specified amount of fungible asset from the sender's primary store to the recipient's primary store.\n   * This method allows you to transfer any fungible asset, including fungible tokens.\n   *\n   * @param args - The arguments for the transfer operation.\n   * @param args.sender - The sender account.\n   * @param args.fungibleAssetMetadataAddress - The fungible asset account address. For example, if you're transferring USDT,\n   * this would be the USDT address.\n   * @param args.recipient - The recipient account address.\n   * @param args.amount - The number of assets to transfer.\n   * @param args.options - Optional parameters for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Transfer fungible asset from sender to recipient\n   *   const transaction = await aptos.transferFungibleAsset({\n   *     sender: Account.generate(), // replace with a real sender account\n   *     fungibleAssetMetadataAddress: \"0x123\", // replace with a real fungible asset address\n   *     recipient: \"0x456\", // replace with a real recipient account\n   *     amount: 5\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group FungibleAsset\n   */\n  async transferFungibleAsset(args: {\n    sender: Account;\n    fungibleAssetMetadataAddress: AccountAddressInput;\n    recipient: AccountAddressInput;\n    amount: AnyNumber;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return transferFungibleAsset({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Transfer a specified amount of fungible asset from the sender's any (primary or secondary) fungible store to any (primary or secondary) fungible store.\n   * This method allows you to transfer any fungible asset, including fungible tokens.\n   *\n   * @param args - The arguments for the transfer operation.\n   * @param args.sender - The sender account initiating the transfer.\n   * @param args.fromStore - The fungible store address initiating the transfer.\n   * @param args.toStore - The fungible store address receiving the asset.\n   * @param args.amount - The number of assets to transfer. Must be a positive number.\n   * @param args.options - Optional parameters for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @throws Error if:\n   * - The sender account is invalid\n   * - The store addresses are invalid\n   * - The amount is negative or zero\n   * - The transaction fails to generate\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Account } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function transferAssets() {\n   *   // Transfer 100 units of the asset from senderStore to recipientStore\n   *   const transaction = await aptos.transferFungibleAssetBetweenStores({\n   *     sender: Account.generate(), // replace with a real sender account\n   *     fromStore: \"0x123\", // replace with a real fungible store address\n   *     toStore: \"0x456\", // replace with a real fungible store address\n   *     amount: 100\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   *\n   * transferAssets().catch(console.error);\n   * ```\n   * @group FungibleAsset\n   */\n  async transferFungibleAssetBetweenStores(args: {\n    sender: Account;\n    fromStore: AccountAddressInput;\n    toStore: AccountAddressInput;\n    amount: AnyNumber;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return transferFungibleAssetBetweenStores({ aptosConfig: this.config, ...args });\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AptosConfig } from \"./aptosConfig\";\nimport {\n  getChainTopUserTransactions,\n  getIndexerLastSuccessVersion,\n  getLedgerInfo,\n  getProcessorStatus,\n  queryIndexer,\n} from \"../internal/general\";\nimport { getBlockByHeight, getBlockByVersion } from \"../internal/transaction\";\nimport { view, viewJson } from \"../internal/view\";\nimport {\n  AnyNumber,\n  Block,\n  GetChainTopUserTransactionsResponse,\n  GetProcessorStatusResponse,\n  GraphqlQuery,\n  LedgerInfo,\n  LedgerVersionArg,\n  MoveValue,\n} from \"../types\";\nimport { ProcessorType } from \"../utils/const\";\nimport { InputViewFunctionData, InputViewFunctionJsonData } from \"../transactions\";\n\n/**\n * A class to query various Aptos-related information and perform operations on the Aptos blockchain.\n * @group General\n */\nexport class General {\n  readonly config: AptosConfig;\n\n  /**\n   * Initializes a new instance of the Aptos client with the specified configuration.\n   * This allows users to interact with the Aptos blockchain using the provided settings.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   * @param config.network - The network to connect to (e.g., TESTNET, MAINNET).\n   * @param config.nodeUrl - The URL of the Aptos node to connect to.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a configuration for the Aptos client\n   *     const config = new AptosConfig({\n   *         network: Network.TESTNET, // specify the network\n   *         nodeUrl: \"https://testnet.aptos.dev\" // specify the node URL\n   *     });\n   *\n   *     // Initialize the Aptos client with the configuration\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group General\n   */\n  constructor(config: AptosConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Queries for the Aptos ledger information.\n   *\n   * @returns The Aptos Ledger Info, which includes details such as chain ID, epoch, and ledger version.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching the ledger information\n   *   const ledgerInfo = await aptos.getLedgerInfo();\n   *\n   *   console.log(ledgerInfo);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group General\n   */\n  async getLedgerInfo(): Promise<LedgerInfo> {\n    return getLedgerInfo({ aptosConfig: this.config });\n  }\n\n  /**\n   * Retrieves the chain ID of the Aptos blockchain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching the chain ID\n   *   const chainId = await aptos.getChainId();\n   *   console.log(\"Chain ID:\", chainId);\n   * }\n   * runExample().catch(console.error);\n   *\n   * @returns The chain ID of the Aptos blockchain.\n   * ```\n   * @group General\n   */\n  async getChainId(): Promise<number> {\n    const result = await this.getLedgerInfo();\n    return result.chain_id;\n  }\n\n  /**\n   * Retrieves block information by the specified ledger version.\n   *\n   * @param args - The arguments for retrieving the block.\n   * @param args.ledgerVersion - The ledger version to lookup block information for.\n   * @param args.options - Optional parameters for the request.\n   * @param args.options.withTransactions - If set to true, include all transactions in the block.\n   *\n   * @returns Block information with optional transactions.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve block information for a specific ledger version\n   *   const block = await aptos.getBlockByVersion({ ledgerVersion: 5 });\n   *   console.log(block);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group General\n   */\n  async getBlockByVersion(args: {\n    ledgerVersion: AnyNumber;\n    options?: { withTransactions?: boolean };\n  }): Promise<Block> {\n    return getBlockByVersion({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Retrieve a block by its height, allowing for the inclusion of transactions if specified.\n   *\n   * @param args - The parameters for the block retrieval.\n   * @param args.blockHeight - The block height to look up, starting at 0.\n   * @param args.options - Optional settings for the retrieval.\n   * @param args.options.withTransactions - If set to true, includes all transactions in the block.\n   *\n   * @returns The block with optional transactions included.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve the block at height 5, including transactions\n   *   const block = await aptos.getBlockByHeight({ blockHeight: 5, options: { withTransactions: true } });\n   *   console.log(block);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group General\n   */\n  async getBlockByHeight(args: { blockHeight: AnyNumber; options?: { withTransactions?: boolean } }): Promise<Block> {\n    return getBlockByHeight({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries for a Move view function\n   * @param args.payload Payload for the view function\n   * @param args.options.ledgerVersion The ledger version to query, if not provided it will get the latest version\n   *\n   * @example\n   * const data = await aptos.view({\n   *  payload: {\n   *   function: \"0x1::coin::balance\",\n   *   typeArguments: [\"0x1::aptos_coin::AptosCoin\"],\n   *   functionArguments: [accountAddress],\n   *  }\n   * })\n   *\n   * @returns an array of Move values\n   * @group General\n   */\n  async view<T extends Array<MoveValue>>(args: {\n    payload: InputViewFunctionData;\n    options?: LedgerVersionArg;\n  }): Promise<T> {\n    return view<T>({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries for a Move view function with JSON, this provides compatability with the old `aptos` package\n   * @param args.payload Payload for the view function\n   * @param args.options.ledgerVersion The ledger version to query, if not provided it will get the latest version\n   *\n   * @example\n   * const data = await aptos.view({\n   *  payload: {\n   *   function: \"0x1::coin::balance\",\n   *   typeArguments: [\"0x1::aptos_coin::AptosCoin\"],\n   *   functionArguments: [accountAddress.toString()],\n   *  }\n   * })\n   *\n   * @returns an array of Move values\n   * @group General\n   */\n  async viewJson<T extends Array<MoveValue>>(args: {\n    payload: InputViewFunctionJsonData;\n    options?: LedgerVersionArg;\n  }): Promise<T> {\n    return viewJson<T>({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries the top user transactions based on the specified limit.\n   *\n   * @param args - The arguments for querying top user transactions.\n   * @param args.limit - The number of transactions to return.\n   * @returns GetChainTopUserTransactionsResponse\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetch the top user transactions with a limit of 5\n   *   const topUserTransactions = await aptos.getChainTopUserTransactions({ limit: 5 });\n   *\n   *   console.log(topUserTransactions);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group General\n   */\n  async getChainTopUserTransactions(args: { limit: number }): Promise<GetChainTopUserTransactionsResponse> {\n    return getChainTopUserTransactions({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Retrieves data from the Aptos Indexer using a GraphQL query.\n   * This function allows you to execute complex queries to fetch specific data from the Aptos blockchain.\n   *\n   * @param args.query.query - A GraphQL query string.\n   * @param args.query.variables - The variables for the query (optional).\n   *\n   * @return The provided T type.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Querying the Aptos Indexer for ledger information\n   *   const topUserTransactions = await aptos.queryIndexer({\n   *     query: { query: `query MyQuery {\n   *       ledger_infos {\n   *         chain_id\n   *       }\n   *     }`}\n   *   });\n   *\n   *   console.log(topUserTransactions);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group General\n   */\n  async queryIndexer<T extends {}>(args: { query: GraphqlQuery }): Promise<T> {\n    return queryIndexer<T>({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries for the last successful indexer version, providing insight into the ledger version the indexer is updated to, which\n   * may lag behind the full nodes.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the last successful indexer version\n   *   const version = await aptos.getIndexerLastSuccessVersion();\n   *   console.log(`Last successful indexer version: ${version}`);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group General\n   */\n  async getIndexerLastSuccessVersion(): Promise<bigint> {\n    return getIndexerLastSuccessVersion({ aptosConfig: this.config });\n  }\n\n  /**\n   * Query the processor status for a specific processor type.\n   *\n   * @param processorType The processor type to query.\n   * @returns The status of the specified processor type.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the processor status for the account transactions processor\n   *   const status = await aptos.getProcessorStatus(\"account_transactions_processor\");\n   *   console.log(status);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group General\n   */\n  async getProcessorStatus(processorType: ProcessorType): Promise<GetProcessorStatusResponse[0]> {\n    return getProcessorStatus({ aptosConfig: this.config, processorType });\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/name}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * name namespace and without having a dependency cycle error.\n * @group Implementation\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { Account } from \"../account\";\nimport { AccountAddress, AccountAddressInput } from \"../core\";\nimport { InputGenerateTransactionOptions } from \"../transactions/types\";\nimport { GetANSNameResponse, MoveAddressType, OrderByArg, PaginationArgs, WhereArg } from \"../types\";\nimport { GetNamesQuery } from \"../types/generated/operations\";\nimport { GetNames } from \"../types/generated/queries\";\nimport { CurrentAptosNamesBoolExp } from \"../types/generated/types\";\nimport { Network } from \"../utils/apiEndpoints\";\nimport { queryIndexer } from \"./general\";\nimport { view } from \"./view\";\nimport { generateTransaction } from \"./transactionSubmission\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\n\nexport const VALIDATION_RULES_DESCRIPTION = [\n  \"A name must be between 3 and 63 characters long,\",\n  \"and can only contain lowercase a-z, 0-9, and hyphens.\",\n  \"A name may not start or end with a hyphen.\",\n].join(\" \");\n\n/**\n * Validate if a given fragment is a valid ANS segment.\n * This function checks the length and character constraints of the fragment to ensure it meets the ANS standards.\n *\n * @param fragment - A fragment of a name, either the domain or subdomain.\n * @returns A boolean indicating if the fragment is a valid fragment.\n * @group Implementation\n */\nexport function isValidANSSegment(fragment: string): boolean {\n  if (!fragment) return false;\n  if (fragment.length < 3) return false;\n  if (fragment.length > 63) return false;\n  // only lowercase a-z and 0-9 are allowed, along with -. a domain may not start or end with a hyphen\n  if (!/^[a-z\\d][a-z\\d-]{1,61}[a-z\\d]$/.test(fragment)) return false;\n  return true;\n}\n\n/**\n * Checks if an ANS name is valid or not.\n *\n * @param name - A string of the domain name, which can include or exclude the .apt suffix.\n * @group Implementation\n */\nexport function isValidANSName(name: string): { domainName: string; subdomainName?: string } {\n  const [first, second, ...rest] = name.replace(/\\.apt$/, \"\").split(\".\");\n\n  if (rest.length > 0) {\n    throw new Error(`${name} is invalid. A name can only have two parts, a domain and a subdomain separated by a \".\"`);\n  }\n\n  if (!isValidANSSegment(first)) {\n    throw new Error(`${first} is not valid. ${VALIDATION_RULES_DESCRIPTION}`);\n  }\n\n  if (second && !isValidANSSegment(second)) {\n    throw new Error(`${second} is not valid. ${VALIDATION_RULES_DESCRIPTION}`);\n  }\n\n  return {\n    domainName: second || first,\n    subdomainName: second ? first : undefined,\n  };\n}\n\n/**\n * Policy for determining how subdomains expire in relation to their parent domain.\n * @group Implementation\n */\nexport enum SubdomainExpirationPolicy {\n  Independent = 0,\n  FollowsDomain = 1,\n}\n\n/**\n * Determine if a given ANS name is considered active based on its expiration dates.\n * Domains are active if their expiration date is in the future, while subdomains may\n * follow their parent's expiration policy (1) or expire independently (0).\n * If the subdomain is expiring independently, it can expire before their parent, but not after.\n *\n * @param name - An ANS name returned from one of the functions of the SDK.\n * @returns A boolean indicating whether the contract considers the name active or not.\n * @group Implementation\n */\nexport function isActiveANSName(name: GetANSNameResponse[0]): boolean {\n  if (!name) return false;\n\n  const isTLDExpired = new Date(name.domain_expiration_timestamp).getTime() < Date.now();\n  const isExpired = new Date(name.expiration_timestamp).getTime() < Date.now();\n\n  // If we are a subdomain, if our parent is expired we are always expired\n  if (name.subdomain && isTLDExpired) return false;\n\n  // If we are a subdomain and our expiration policy is to follow the domain, we\n  // are active (since we know our parent is not expired by this point)\n  if (name.subdomain && name.subdomain_expiration_policy === SubdomainExpirationPolicy.FollowsDomain) return true;\n\n  // At this point, we are either a TLD or a subdomain with an independent\n  // expiration policy, we are active as long as we the expiration timestamp\n  return !isExpired;\n}\n\nexport const LOCAL_ANS_ACCOUNT_PK =\n  process.env.ANS_TEST_ACCOUNT_PRIVATE_KEY ??\n  \"ed25519-priv-0x37368b46ce665362562c6d1d4ec01a08c8644c488690df5a17e13ba163e20221\";\nexport const LOCAL_ANS_ACCOUNT_ADDRESS =\n  process.env.ANS_TEST_ACCOUNT_ADDRESS ?? \"0x585fc9f0f0c54183b039ffc770ca282ebd87307916c215a3e692f2f8e4305e82\";\n\nconst NetworkToAnsContract: Record<Network, string | null> = {\n  [Network.TESTNET]: \"0x5f8fd2347449685cf41d4db97926ec3a096eaf381332be4f1318ad4d16a8497c\",\n  [Network.MAINNET]: \"0x867ed1f6bf916171b1de3ee92849b8978b7d1b9e0a8cc982a3d19d535dfd9c0c\",\n  [Network.LOCAL]: LOCAL_ANS_ACCOUNT_ADDRESS,\n  [Network.CUSTOM]: null,\n  [Network.DEVNET]: null,\n};\n\n/**\n * Retrieves the address of the ANS contract based on the specified Aptos network configuration.\n *\n * @param aptosConfig - The configuration object for the Aptos network.\n * @param aptosConfig.network - The network for which to retrieve the ANS contract address.\n *\n * @throws Throws an error if the ANS contract is not deployed to the specified network.\n * @group Implementation\n */\nfunction getRouterAddress(aptosConfig: AptosConfig): string {\n  const address = NetworkToAnsContract[aptosConfig.network];\n  if (!address) throw new Error(`The ANS contract is not deployed to ${aptosConfig.network}`);\n  return address;\n}\n\nconst unwrapOption = <T>(option: any): T | undefined => {\n  if (!!option && typeof option === \"object\" && \"vec\" in option && Array.isArray(option.vec)) {\n    return option.vec[0];\n  }\n\n  return undefined;\n};\n\n/**\n * Retrieve the owner address of a specified domain or subdomain.\n *\n * @param args - The arguments for retrieving the owner address.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.name - The name of the domain or subdomain to query.\n * @returns The account address of the owner, or undefined if not found.\n * @group Implementation\n */\nexport async function getOwnerAddress(args: {\n  aptosConfig: AptosConfig;\n  name: string;\n}): Promise<AccountAddress | undefined> {\n  const { aptosConfig, name } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n  const { domainName, subdomainName } = isValidANSName(name);\n\n  const res = await view({\n    aptosConfig,\n    payload: {\n      function: `${routerAddress}::router::get_owner_addr`,\n      functionArguments: [domainName, subdomainName],\n    },\n  });\n\n  const owner = unwrapOption<MoveAddressType>(res[0]);\n\n  return owner ? AccountAddress.from(owner) : undefined;\n}\n\n/**\n * Parameters for registering a name in the Aptos network.\n *\n * @param aptosConfig - Configuration settings for the Aptos network.\n * @param sender - The account initiating the name registration.\n * @param name - The name to be registered.\n * @param expiration - The expiration policy for the name registration.\n * @group Implementation\n */\nexport interface RegisterNameParameters {\n  aptosConfig: AptosConfig;\n  sender: Account;\n  name: string;\n  expiration:\n    | { policy: \"domain\"; years?: 1 }\n    | { policy: \"subdomain:follow-domain\" }\n    | { policy: \"subdomain:independent\"; expirationDate: number };\n  transferable?: boolean;\n  toAddress?: AccountAddressInput;\n  targetAddress?: AccountAddressInput;\n  options?: InputGenerateTransactionOptions;\n}\n\n/**\n * Registers a domain or subdomain with the specified parameters. This function ensures that the provided names and expiration\n * policies are valid before proceeding with the registration process.\n *\n * @param args - The parameters required for registering a name.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.expiration - The expiration details for the registration.\n * @param args.name - The name to be registered, which can be a domain or subdomain.\n * @param args.sender - The account details of the sender initiating the registration.\n * @param args.targetAddress - The target address for the registration.\n * @param args.toAddress - The address to which the registration is associated.\n * @param args.options - Additional options for the registration process.\n * @param args.transferable - Indicates whether the registered name is transferable.\n *\n * @throws Error if the provided expiration policy is invalid for subdomains.\n * @throws Error if the domain does not exist.\n * @throws Error if the subdomain expiration time exceeds the domain expiration time.\n *\n * @returns A transaction object representing the registration process.\n * @group Implementation\n */\nexport async function registerName(args: RegisterNameParameters): Promise<SimpleTransaction> {\n  const { aptosConfig, expiration, name, sender, targetAddress, toAddress, options, transferable } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n  const { domainName, subdomainName } = isValidANSName(name);\n\n  const hasSubdomainPolicy =\n    expiration.policy === \"subdomain:independent\" || expiration.policy === \"subdomain:follow-domain\";\n\n  if (subdomainName && !hasSubdomainPolicy) {\n    throw new Error(\n      \"Subdomains must have an expiration policy of either 'subdomain:independent' or 'subdomain:follow-domain'\",\n    );\n  }\n\n  if (hasSubdomainPolicy && !subdomainName) {\n    throw new Error(`Policy is set to ${expiration.policy} but no subdomain was provided`);\n  }\n\n  if (expiration.policy === \"domain\") {\n    const years = expiration.years ?? 1;\n    if (years !== 1) {\n      throw new Error(\"For now, names can only be registered for 1 year at a time\");\n    }\n\n    const secondsInYear = 31536000;\n    const registrationDuration = years * secondsInYear;\n\n    const transaction = await generateTransaction({\n      aptosConfig,\n      sender: sender.accountAddress.toString(),\n      data: {\n        function: `${routerAddress}::router::register_domain`,\n        functionArguments: [domainName, registrationDuration, targetAddress, toAddress],\n      },\n      options,\n    });\n\n    return transaction;\n  }\n\n  // We are a subdomain\n  if (!subdomainName) {\n    throw new Error(`${expiration.policy} requires a subdomain to be provided.`);\n  }\n\n  const tldExpiration = await getExpiration({ aptosConfig, name: domainName });\n  if (!tldExpiration) {\n    throw new Error(\"The domain does not exist\");\n  }\n\n  const expirationDateInMillisecondsSinceEpoch =\n    expiration.policy === \"subdomain:independent\" ? expiration.expirationDate : tldExpiration;\n\n  if (expirationDateInMillisecondsSinceEpoch > tldExpiration) {\n    throw new Error(\"The subdomain expiration time cannot be greater than the domain expiration time\");\n  }\n\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress.toString(),\n    data: {\n      function: `${routerAddress}::router::register_subdomain`,\n      functionArguments: [\n        domainName,\n        subdomainName,\n        Math.round(expirationDateInMillisecondsSinceEpoch / 1000),\n        expiration.policy === \"subdomain:follow-domain\" ? 1 : 0,\n        !!transferable,\n        targetAddress,\n        toAddress,\n      ],\n    },\n    options,\n  });\n\n  return transaction;\n}\n\n/**\n * Retrieves the expiration time of a specified domain or subdomain in epoch milliseconds.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.name - The name of the domain or subdomain to check.\n * @returns The expiration time in epoch milliseconds, or undefined if an error occurs.\n * @group Implementation\n */\nexport async function getExpiration(args: { aptosConfig: AptosConfig; name: string }): Promise<number | undefined> {\n  const { aptosConfig, name } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n  const { domainName, subdomainName } = isValidANSName(name);\n\n  try {\n    const res = await view({\n      aptosConfig,\n      payload: {\n        function: `${routerAddress}::router::get_expiration`,\n        functionArguments: [domainName, subdomainName],\n      },\n    });\n\n    // Normalize expiration time from epoch seconds to epoch milliseconds\n    return Number(res[0]) * 1000;\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\n * Retrieves the primary name associated with a given account address.\n * This function helps in obtaining the complete domain name by combining the subdomain and domain names.\n *\n * @param args - The arguments for retrieving the primary name.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.address - The account address for which to retrieve the primary name.\n * @returns The primary name as a string, or undefined if no domain name exists.\n * @group Implementation\n */\nexport async function getPrimaryName(args: {\n  aptosConfig: AptosConfig;\n  address: AccountAddressInput;\n}): Promise<string | undefined> {\n  const { aptosConfig, address } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n\n  const res = await view({\n    aptosConfig,\n    payload: {\n      function: `${routerAddress}::router::get_primary_name`,\n      functionArguments: [AccountAddress.from(address).toString()],\n    },\n  });\n\n  const domainName = unwrapOption<MoveAddressType>(res[1]);\n  const subdomainName = unwrapOption<MoveAddressType>(res[0]);\n\n  if (!domainName) return undefined;\n\n  return [subdomainName, domainName].filter(Boolean).join(\".\");\n}\n\n/**\n * Sets the primary name for the specified account, allowing for the association of a domain or subdomain with the account.\n * If no name is provided, it clears the existing primary name.\n *\n * @param args - The arguments for setting the primary name.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.sender - The account that is sending the transaction.\n * @param args.name - The name to set as the primary name. If omitted, the function will clear the primary name.\n * @param args.options - Optional transaction generation options.\n * @returns A transaction object representing the operation.\n * @group Implementation\n */\nexport async function setPrimaryName(args: {\n  aptosConfig: AptosConfig;\n  sender: Account;\n  name?: string;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, sender, name, options } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n\n  if (!name) {\n    const transaction = await generateTransaction({\n      aptosConfig,\n      sender: sender.accountAddress.toString(),\n      data: {\n        function: `${routerAddress}::router::clear_primary_name`,\n        functionArguments: [],\n      },\n      options,\n    });\n\n    return transaction;\n  }\n\n  const { domainName, subdomainName } = isValidANSName(name);\n\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress.toString(),\n    data: {\n      function: `${routerAddress}::router::set_primary_name`,\n      functionArguments: [domainName, subdomainName],\n    },\n    options,\n  });\n\n  return transaction;\n}\n\n/**\n * Retrieves the target address associated with a given domain name and subdomain name.\n *\n * @param args - The arguments for retrieving the target address.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.name - The name of the domain, which may include a subdomain.\n * @returns The target address as an AccountAddress, or undefined if not found.\n * @group Implementation\n */\nexport async function getTargetAddress(args: {\n  aptosConfig: AptosConfig;\n  name: string;\n}): Promise<AccountAddress | undefined> {\n  const { aptosConfig, name } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n  const { domainName, subdomainName } = isValidANSName(name);\n\n  const res = await view({\n    aptosConfig,\n    payload: {\n      function: `${routerAddress}::router::get_target_addr`,\n      functionArguments: [domainName, subdomainName],\n    },\n  });\n\n  const target = unwrapOption<MoveAddressType>(res[0]);\n  return target ? AccountAddress.from(target) : undefined;\n}\n\n/**\n * Sets the target address for a specified domain and subdomain in the Aptos network.\n * This function helps to associate a given address with a domain name, allowing for easier access and management of resources.\n *\n * @param args - The arguments for setting the target address.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.sender - The account that is sending the transaction.\n * @param args.name - The name of the domain or subdomain to be set.\n * @param args.address - The address to be associated with the domain or subdomain.\n * @param args.options - Optional parameters for generating the transaction.\n *\n * @returns A transaction object representing the set target address operation.\n * @group Implementation\n */\nexport async function setTargetAddress(args: {\n  aptosConfig: AptosConfig;\n  sender: Account;\n  name: string;\n  address: AccountAddressInput;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, sender, name, address, options } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n  const { domainName, subdomainName } = isValidANSName(name);\n\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress.toString(),\n    data: {\n      function: `${routerAddress}::router::set_target_addr`,\n      functionArguments: [domainName, subdomainName, address],\n    },\n    options,\n  });\n\n  return transaction;\n}\n\n/**\n * Retrieves the active Aptos name associated with the specified domain and subdomain.\n *\n * @param args - The parameters for the function.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.name - The name to look up, which includes the domain and optional subdomain.\n * @returns The active Aptos name if it exists; otherwise, returns undefined.\n * @group Implementation\n */\nexport async function getName(args: {\n  aptosConfig: AptosConfig;\n  name: string;\n}): Promise<GetANSNameResponse[0] | undefined> {\n  const { aptosConfig, name } = args;\n  const { domainName, subdomainName = \"\" } = isValidANSName(name);\n\n  const where: CurrentAptosNamesBoolExp = {\n    domain: { _eq: domainName },\n    subdomain: { _eq: subdomainName },\n  };\n\n  const data = await queryIndexer<GetNamesQuery>({\n    aptosConfig,\n    query: {\n      query: GetNames,\n      variables: {\n        where_condition: where,\n        limit: 1,\n      },\n    },\n    originMethod: \"getName\",\n  });\n\n  // Convert the expiration_timestamp from an ISO string to milliseconds since epoch\n  let res = data.current_aptos_names[0];\n  if (res) {\n    res = sanitizeANSName(res);\n  }\n\n  return isActiveANSName(res) ? res : undefined;\n}\n\n/**\n * Options for querying names, including pagination, ordering, and filtering criteria.\n *\n * @param options - Pagination and filtering options for the query.\n * @group Implementation\n */\ninterface QueryNamesOptions {\n  options?: PaginationArgs & OrderByArg<GetANSNameResponse[0]> & WhereArg<CurrentAptosNamesBoolExp>;\n}\n\n/**\n * Arguments for retrieving account names based on the specified account address.\n *\n * @param accountAddress - The address of the account for which names are to be retrieved.\n * @group Implementation\n */\nexport interface GetAccountNamesArgs extends QueryNamesOptions {\n  accountAddress: AccountAddressInput;\n}\n\n/**\n * Retrieves the current Aptos names associated with a specific account address.\n *\n * @param args - The arguments for retrieving account names.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.options - Optional parameters for querying account names.\n * @param args.options.limit - The maximum number of names to retrieve.\n * @param args.options.offset - The number of names to skip before starting to collect the result set.\n * @param args.options.orderBy - The field by which to order the results.\n * @param args.options.where - Additional conditions to filter the results.\n * @param args.accountAddress - The address of the account for which to retrieve names.\n *\n * @returns An array of sanitized Aptos names associated with the specified account address.\n * @group Implementation\n */\nexport async function getAccountNames(\n  args: { aptosConfig: AptosConfig } & GetAccountNamesArgs,\n): Promise<GetANSNameResponse> {\n  const { aptosConfig, options, accountAddress } = args;\n\n  const expirationDate = await getANSExpirationDate({ aptosConfig });\n\n  const data = await queryIndexer<GetNamesQuery>({\n    aptosConfig,\n    originMethod: \"getAccountNames\",\n    query: {\n      query: GetNames,\n      variables: {\n        limit: options?.limit,\n        offset: options?.offset,\n        order_by: options?.orderBy,\n        where_condition: {\n          ...(args.options?.where ?? {}),\n          owner_address: { _eq: accountAddress.toString() },\n          expiration_timestamp: { _gte: expirationDate },\n        },\n      },\n    },\n  });\n\n  return data.current_aptos_names.map(sanitizeANSName);\n}\n\n/**\n * Arguments for retrieving the domains associated with a specific account.\n *\n * @param accountAddress - The address of the account for which to fetch domains.\n * @group Implementation\n */\nexport interface GetAccountDomainsArgs extends QueryNamesOptions {\n  accountAddress: AccountAddressInput;\n}\n\n/**\n * Retrieves the list of top-level domains owned by a specified account.\n *\n * @param args - The arguments for retrieving account domains.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.options - Optional parameters for the query.\n * @param args.options.limit - The maximum number of results to return.\n * @param args.options.offset - The number of results to skip before starting to collect the result set.\n * @param args.options.orderBy - The field by which to order the results.\n * @param args.options.where - Additional conditions to filter the results.\n * @param args.options.where.owner_address - The address of the account whose domains are being queried.\n * @param args.options.where.expiration_timestamp - The minimum expiration timestamp for the domains.\n * @param args.options.where.subdomain - The specific subdomain to filter by.\n *\n * @returns An array of sanitized domain names owned by the specified account.\n * @group Implementation\n */\nexport async function getAccountDomains(\n  args: { aptosConfig: AptosConfig } & GetAccountDomainsArgs,\n): Promise<GetANSNameResponse> {\n  const { aptosConfig, options, accountAddress } = args;\n\n  const expirationDate = await getANSExpirationDate({ aptosConfig });\n\n  const data = await queryIndexer<GetNamesQuery>({\n    aptosConfig,\n    originMethod: \"getAccountDomains\",\n    query: {\n      query: GetNames,\n      variables: {\n        limit: options?.limit,\n        offset: options?.offset,\n        order_by: options?.orderBy,\n        where_condition: {\n          ...(args.options?.where ?? {}),\n          owner_address: { _eq: accountAddress.toString() },\n          expiration_timestamp: { _gte: expirationDate },\n          subdomain: { _eq: \"\" },\n        },\n      },\n    },\n  });\n\n  return data.current_aptos_names.map(sanitizeANSName);\n}\n\n/**\n * Arguments for retrieving subdomains associated with a specific account.\n *\n * @param accountAddress - The address of the account for which to fetch subdomains.\n * @group Implementation\n */\nexport interface GetAccountSubdomainsArgs extends QueryNamesOptions {\n  accountAddress: AccountAddressInput;\n}\n\n/**\n * Retrieves a list of subdomains owned by a specified account address.\n * This function helps you identify all subdomains associated with a given account.\n *\n * @param args - The arguments for retrieving account subdomains.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.options - Optional parameters for the query.\n * @param args.options.limit - The maximum number of results to return.\n * @param args.options.offset - The number of results to skip before starting to collect the result set.\n * @param args.options.orderBy - The field by which to order the results.\n * @param args.options.where - Additional conditions to filter the results.\n * @param args.options.where.owner_address - The address of the account to filter by.\n * @param args.options.where.expiration_timestamp - The expiration timestamp to filter by.\n * @param args.options.where.subdomain - The subdomain condition to filter by.\n * @param args.accountAddress - The address of the account whose subdomains are being queried.\n * @group Implementation\n */\nexport async function getAccountSubdomains(\n  args: { aptosConfig: AptosConfig } & GetAccountSubdomainsArgs,\n): Promise<GetANSNameResponse> {\n  const { aptosConfig, options, accountAddress } = args;\n\n  const expirationDate = await getANSExpirationDate({ aptosConfig });\n\n  const data = await queryIndexer<GetNamesQuery>({\n    aptosConfig,\n    originMethod: \"getAccountSubdomains\",\n    query: {\n      query: GetNames,\n      variables: {\n        limit: options?.limit,\n        offset: options?.offset,\n        order_by: options?.orderBy,\n        where_condition: {\n          ...(args.options?.where ?? {}),\n          owner_address: { _eq: accountAddress.toString() },\n          expiration_timestamp: { _gte: expirationDate },\n          subdomain: { _neq: \"\" },\n        },\n      },\n    },\n  });\n\n  return data.current_aptos_names.map(sanitizeANSName);\n}\n\n/**\n * Arguments for retrieving subdomains associated with a specific domain.\n *\n * @param domain - The domain for which to fetch subdomains.\n * @group Implementation\n */\nexport interface GetDomainSubdomainsArgs extends QueryNamesOptions {\n  domain: string;\n}\n\n/**\n * Retrieve the active subdomains associated with a specified domain.\n *\n * @param args - The arguments for retrieving subdomains.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.options - Optional parameters for the query.\n * @param args.options.limit - The maximum number of results to return.\n * @param args.options.offset - The number of results to skip before starting to collect the results.\n * @param args.options.orderBy - The field by which to order the results.\n * @param args.options.where - Additional conditions to filter the results.\n * @param args.domain - The domain for which to retrieve subdomains.\n *\n * @returns An array of active subdomain names.\n * @group Implementation\n */\nexport async function getDomainSubdomains(\n  args: { aptosConfig: AptosConfig } & GetDomainSubdomainsArgs,\n): Promise<GetANSNameResponse> {\n  const { aptosConfig, options, domain } = args;\n\n  const data = await queryIndexer<GetNamesQuery>({\n    aptosConfig,\n    originMethod: \"getDomainSubdomains\",\n    query: {\n      query: GetNames,\n      variables: {\n        limit: options?.limit,\n        offset: options?.offset,\n        order_by: options?.orderBy,\n        where_condition: {\n          ...(args.options?.where ?? {}),\n          domain: { _eq: domain },\n          subdomain: { _neq: \"\" },\n        },\n      },\n    },\n  });\n\n  return data.current_aptos_names.map(sanitizeANSName).filter(isActiveANSName);\n}\n\n/**\n * This function returns the expiration date in which a name is fully expired as\n * defined by the contract.  The grace period allows for names to be past\n * expiration for a certain amount of time before they are released to the\n * public. The names will not function as normal, but the owner can renew\n * without others taking ownership of the name. At the time of writing, the\n * contract specified 30 days.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - An AptosConfig object containing the configuration settings.\n * @returns The expiration date in ISO 8601 format.\n * @group Implementation\n */\nasync function getANSExpirationDate(args: { aptosConfig: AptosConfig }): Promise<string> {\n  const { aptosConfig } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n\n  const [gracePeriodInSeconds] = await view<[number]>({\n    aptosConfig,\n    payload: {\n      function: `${routerAddress}::config::reregistration_grace_sec`,\n      functionArguments: [],\n    },\n  });\n\n  const gracePeriodInDays = gracePeriodInSeconds / 60 / 60 / 24;\n  const now = () => new Date();\n  return new Date(now().setDate(now().getDate() - gracePeriodInDays)).toISOString();\n}\n\n/**\n * Renews a domain for a specified duration. This function allows you to extend the registration of a domain for one year.\n *\n * @param args - The parameters required to renew the domain.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.sender - The account that is sending the renewal transaction.\n * @param args.name - The name of the domain to renew.\n * @param args.years - The number of years to renew the domain for. Currently, only 1 year renewals are supported. (optional, default is 1)\n * @param args.options - Additional options for generating the transaction. (optional)\n * @throws Error if the name contains a subdomain or if the years parameter is not equal to 1.\n * @group Implementation\n */\nexport async function renewDomain(args: {\n  aptosConfig: AptosConfig;\n  sender: Account;\n  name: string;\n  years?: 1;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, sender, name, years = 1, options } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n  const renewalDuration = years * 31536000;\n  const { domainName, subdomainName } = isValidANSName(name);\n\n  if (subdomainName) {\n    throw new Error(\"Subdomains cannot be renewed\");\n  }\n\n  if (years !== 1) {\n    throw new Error(\"Currently, only 1 year renewals are supported\");\n  }\n\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress.toString(),\n    data: {\n      function: `${routerAddress}::router::renew_domain`,\n      functionArguments: [domainName, renewalDuration],\n    },\n    options,\n  });\n\n  return transaction;\n}\n\n/**\n * The indexer returns ISO strings for expiration, however the contract works in\n * epoch milliseconds. This function converts the ISO string to epoch\n * milliseconds. In the future, if other properties need sanitization, this can\n * be extended.\n *\n * @param name - The ANS name response to sanitize.\n * @param name.expiration_timestamp - The expiration timestamp in ISO string format.\n * @group Implementation\n */\nfunction sanitizeANSName(name: GetANSNameResponse[0]): GetANSNameResponse[0] {\n  return {\n    ...name,\n    expiration_timestamp: new Date(name.expiration_timestamp).getTime(),\n  };\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Account } from \"../account\";\nimport { AccountAddress, AccountAddressInput } from \"../core\";\nimport {\n  RegisterNameParameters,\n  getExpiration,\n  getOwnerAddress,\n  registerName,\n  getPrimaryName,\n  setPrimaryName,\n  getTargetAddress,\n  setTargetAddress,\n  renewDomain,\n  getName,\n  getAccountDomains,\n  GetAccountDomainsArgs,\n  GetAccountSubdomainsArgs,\n  getAccountSubdomains,\n  getAccountNames,\n  GetAccountNamesArgs,\n  getDomainSubdomains,\n  GetDomainSubdomainsArgs,\n} from \"../internal/ans\";\nimport { GetANSNameResponse } from \"../types\";\nimport { InputGenerateTransactionOptions } from \"../transactions/types\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\n\n/**\n * A class to handle all `ANS` operations.\n * @group ANS\n */\nexport class ANS {\n  /**\n   * Initializes a new instance of the Aptos class with the provided configuration.\n   * This allows you to interact with the Aptos blockchain using the specified network settings.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   * @param config.network - The network to connect to (e.g., mainnet, testnet).\n   * @param config.nodeUrl - The URL of the Aptos node to connect to.\n   * @param config.faucetUrl - The URL of the faucet to use for funding accounts.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a configuration for connecting to the Aptos testnet\n   *     const config = new AptosConfig({ network: Network.TESTNET });\n   *\n   *     // Initialize the Aptos client with the configuration\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  constructor(readonly config: AptosConfig) {}\n\n  /**\n   * Retrieve the owner address of a specified domain name or subdomain name from the contract.\n   *\n   * @param args - The arguments for retrieving the owner address.\n   * @param args.name - A string representing the name of the domain or subdomain to retrieve the owner address for.\n   *\n   * @returns AccountAddress if the name is owned, undefined otherwise.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve the owner address of \"test.aptos\"\n   *   const owner = await aptos.getOwnerAddress({ name: \"test.aptos\" });\n   *   console.log(owner); // Logs the owner address or undefined if not owned\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async getOwnerAddress(args: { name: string }): Promise<AccountAddress | undefined> {\n    return getOwnerAddress({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieve the expiration time of a domain name or subdomain name from the contract.\n   *\n   * @param args - The arguments for retrieving the expiration.\n   * @param args.name - A string of the name to retrieve.\n   *\n   * @returns number as a unix timestamp in milliseconds.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the expiration time for the domain \"test.aptos\"\n   *   const exp = await aptos.getExpiration({ name: \"test.aptos\" });\n   *\n   *   // Log the expiration date\n   *   console.log(new Date(exp)); // Outputs the expiration date\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async getExpiration(args: { name: string }): Promise<number | undefined> {\n    return getExpiration({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieve the target address of a domain or subdomain name, which indicates the address the name points to for use on-chain.\n   * Note that the target address can point to addresses that do not own the name.\n   *\n   * @param args - The arguments for retrieving the target address.\n   * @param args.name - A string representing the name, which can be a primary name, a subdomain, or a combination (e.g.,\n   * \"primary\", \"primary.apt\", \"secondary.primary\", \"secondary.primary.apt\").\n   *\n   * @returns AccountAddress if the name has a target, undefined otherwise.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve the target address for the specified domain name\n   *   const targetAddr = await aptos.getTargetAddress({ name: \"test.aptos\" });\n   *\n   *   console.log(targetAddr); // Logs the target address, e.g., 0x123...\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async getTargetAddress(args: { name: string }): Promise<AccountAddress | undefined> {\n    return getTargetAddress({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Sets the target address of a domain or subdomain name, pointing it to a specified address for use on-chain.\n   * The target address can be different from the owner of the name.\n   *\n   * @param args - The arguments for setting the target address.\n   * @param args.sender - The account initiating the transaction.\n   * @param args.name - A string representing the domain or subdomain name (e.g., \"test.aptos\").\n   * @param args.address - The AccountAddressInput of the address to set the domain or subdomain to.\n   * @param args.options - Optional settings for generating the transaction.\n   *\n   * @returns SimpleTransaction\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Setting the target address for a domain name\n   *   const sender = Account.generate(); // replace with a real account\n   *   const address = \"0x1\"; // replace with a real account address\n   *\n   *   await aptos.setTargetAddress({\n   *     sender: sender,\n   *     name: \"test.aptos\",\n   *     address: address,\n   *   });\n   *\n   *   const targetAddress = await aptos.getTargetAddress({ name: \"test.aptos\" });\n   *   console.log(targetAddress); // Should log the address set for \"test.aptos\"\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async setTargetAddress(args: {\n    sender: Account;\n    name: string;\n    address: AccountAddressInput;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return setTargetAddress({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieve the primary name for an account. An account can have multiple names, but only one primary name, which may not exist.\n   *\n   * @param args - The arguments for retrieving the primary name.\n   * @param args.address - An AccountAddressInput (address) of the account.\n   *\n   * @returns A string if the account has a primary name, undefined otherwise.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve the primary name for the specified account address\n   *   const name = await aptos.getPrimaryName({ address: \"0x1\" }); // replace with a real account address\n   *   console.log(name);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async getPrimaryName(args: { address: AccountAddressInput }): Promise<string | undefined> {\n    return getPrimaryName({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Sets the primary name for the sender account, allowing them to designate a single primary name among potentially multiple\n   * names. An account may not have a primary name.\n   *\n   * @param args - The arguments for setting the primary name.\n   * @param args.sender - The sender account.\n   * @param args.name - A string representing the name to set as primary (e.g., \"test.aptos\").\n   * @param args.options - Optional transaction options.\n   *\n   * @returns SimpleTransaction\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Set the primary name for the sender account\n   *   const sender = Account.generate(); // replace with a real account\n   *   await aptos.setPrimaryName({ sender, name: \"test.aptos\" });\n   *\n   *   const primaryName = await aptos.getPrimaryName({ address: sender.accountAddress });\n   *   console.log(\"Primary Name:\", primaryName); // Should log: \"Primary Name: test.aptos\"\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async setPrimaryName(args: {\n    sender: Account;\n    name?: string;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return setPrimaryName({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Registers a new name.\n   *\n   * This function allows you to register a domain or subdomain name with specific expiration policies and options.\n   *\n   * @param args.sender - The sender account.\n   * @param args.name - A string of the name to register. This can be inclusive or exclusive of the .apt suffix. Examples include:\n   * \"test\", \"test.apt\", \"test.aptos.apt\", etc.\n   * @param args.expiration  - An object with the expiration policy of the name.\n   * @param args.expiration.policy - 'domain' | 'subdomain:follow-domain' | 'subdomain:independent'.\n   * - domain: Years is required and the name will expire after the given number of years.\n   * - subdomain:follow-domain: The name will expire at the same time as the domain name.\n   * - subdomain:independent: The name will expire at the given date.\n   * @param args.expiration.expirationDate - An epoch number in milliseconds of the date when the subdomain will expire. Only\n   * applicable when the policy is set to 'subdomain:independent'.\n   * @param args.transferable  - Determines if the subdomain being minted is soul-bound. Applicable only to subdomains.\n   * @param args.targetAddress optional - The address the domain name will resolve to. If not provided, the sender's address will\n   * be used.\n   * @param args.toAddress optional - The address to send the domain name to. If not provided, the transaction will be sent to the\n   * router.\n   *\n   * @returns SimpleTransaction\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Registering a subdomain name assuming def.apt is already registered and belongs to the sender alice.\n   *   const txn = await aptos.registerName({\n   *     sender: \"0x1\", // replace with a real sender account\n   *     name: \"test.aptos.apt\",\n   *     expiration: {\n   *       policy: \"subdomain:independent\",\n   *       expirationDate: Date.now() + 30 * 24 * 60 * 60 * 1000, // expires in 30 days\n   *     },\n   *   });\n   *\n   *   console.log(\"Transaction:\", txn);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async registerName(args: Omit<RegisterNameParameters, \"aptosConfig\">): Promise<SimpleTransaction> {\n    return registerName({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Renews a domain name for one year.\n   * If a domain name was minted with V1 of the contract, it will automatically be upgraded to V2 via this transaction.\n   *\n   * @param args - The arguments for renewing the domain.\n   * @param args.sender - The sender account, which must be the domain owner.\n   * @param args.name - A string representing the domain to renew. Subdomains cannot be renewed.\n   * @param args.years - The number of years to renew the name. Currently, only one year is permitted.\n   * @param args.options - Optional transaction options.\n   *\n   * @returns SimpleTransaction\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Renew the domain \"test\" for one year\n   *   const transaction = await aptos.renewDomain({\n   *     sender: Account.generate(), // replace with a real account\n   *     name: \"test\"\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async renewDomain(args: {\n    sender: Account;\n    name: string;\n    years?: 1;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return renewDomain({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Fetches a single name from the indexer based on the provided name argument.\n   *\n   * @param args - The arguments for retrieving the name.\n   * @param args.name - A string of the name to retrieve, e.g. \"test.aptos.apt\" or \"test.apt\" or \"test\".\n   *                    Can be inclusive or exclusive of the .apt suffix and can be a subdomain.\n   *\n   * @returns A promise of an ANSName or undefined if the name is not active.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *     // Fetching a name from the indexer\n   *     const name = await aptos.getName({ name: \"test.aptos\" }); // replace with a real name\n   *     console.log(name);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async getName(args: { name: string }): Promise<GetANSNameResponse[0] | undefined> {\n    return getName({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Fetches all names for an account, including both top-level domains and subdomains.\n   *\n   * @param args - The arguments for fetching account names.\n   * @param args.accountAddress - An AccountAddressInput of the address to retrieve names for.\n   * @param args.options - Optional parameters for fetching names.\n   * @param args.options.offset - Optional, the offset to start from when fetching names.\n   * @param args.options.limit - Optional, a number of the names to fetch per request.\n   * @param args.options.orderBy - The order to sort the names by.\n   * @param args.options.where - Additional filters to apply to the query.\n   *\n   * @returns A promise of an array of ANSName.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetch account names for a specific address\n   *   const accountNames = await aptos.getAccountNames({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       limit: 10, // specify how many names to fetch\n   *       orderBy: \"name\", // specify the order by which to sort the names\n   *     },\n   *   });\n   *\n   *   console.log(accountNames);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async getAccountNames(args: GetAccountNamesArgs): Promise<GetANSNameResponse> {\n    return getAccountNames({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Fetches all top-level domain names for a specified account.\n   *\n   * @param args - The arguments for retrieving account domains.\n   * @param args.accountAddress - An AccountAddressInput of the address to retrieve domain names for.\n   * @param args.options.offset - Optional, the offset to start from when fetching names.\n   * @param args.options.limit - Optional, a number of the names to fetch per request.\n   * @param args.options.orderBy - The order to sort the names by.\n   * @param args.options.where - Additional filters to apply to the query.\n   *\n   * @returns A promise of an array of ANSName.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching all top-level domain names for a specific account\n   *   const domains = await aptos.getAccountDomains({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       limit: 10, // specify the number of names to fetch\n   *       offset: 0, // specify the offset for pagination\n   *       orderBy: \"created_at\", // specify the order by which to sort the names\n   *       where: {\n   *         // additional filters can be specified here\n   *       },\n   *     },\n   *   });\n   *\n   *   console.log(domains);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async getAccountDomains(args: GetAccountDomainsArgs): Promise<GetANSNameResponse> {\n    return getAccountDomains({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Fetches all subdomain names for a specified account.\n   *\n   * @param args - The arguments for retrieving subdomains.\n   * @param args.accountAddress - The address to retrieve subdomain names for.\n   * @param args.options - Optional parameters for fetching subdomains.\n   * @param args.options.offset - The offset to start from when fetching names.\n   * @param args.options.limit - The number of names to fetch per request.\n   * @param args.options.orderBy - The order to sort the names by.\n   * @param args.options.where - Additional filters to apply to the query.\n   *\n   * @returns A promise of an array of ANSName.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *     // Fetching subdomain names for a specific account\n   *     const subdomains = await aptos.getAccountSubdomains({\n   *         accountAddress: \"0x1\", // replace with a real account address\n   *         options: {\n   *             limit: 10, // specify the number of subdomains to fetch\n   *             offset: 0, // specify the offset for pagination\n   *             orderBy: \"name\", // specify the order by which to sort the names\n   *         },\n   *     });\n   *\n   *     console.log(subdomains);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async getAccountSubdomains(args: GetAccountSubdomainsArgs): Promise<GetANSNameResponse> {\n    return getAccountSubdomains({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Fetches all subdomain names for a given domain, excluding the domain itself.\n   *\n   * @param args - The arguments for fetching subdomains.\n   * @param args.domain - A string of the domain name, e.g., \"test.apt\" or \"test\" (without the suffix of .apt).\n   * @param args.options - Optional parameters for fetching subdomains.\n   * @param args.options.offset - Optional, the offset to start from when fetching names.\n   * @param args.options.limit - Optional, the number of names to fetch per request.\n   * @param args.options.orderBy - The order to sort the names by.\n   * @param args.options.where - Additional filters to apply to the query.\n   *\n   * @returns A promise that resolves to an array of ANSName.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching subdomains for a specific domain\n   *   const subdomains = await aptos.getDomainSubdomains({\n   *     domain: \"test\", // replace with your domain\n   *     options: {\n   *       limit: 10, // specify the number of subdomains to fetch\n   *       offset: 0, // specify the starting point for fetching\n   *       orderBy: \"name\", // specify the order by which to sort the results\n   *     },\n   *   });\n   *\n   *   console.log(subdomains);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async getDomainSubdomains(args: GetDomainSubdomainsArgs): Promise<GetANSNameResponse> {\n    return getDomainSubdomains({ aptosConfig: this.config, ...args });\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/staking}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * staking namespace and without having a dependency cycle error.\n * @group Implementation\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { AccountAddress, AccountAddressInput } from \"../core\";\nimport { GetDelegatedStakingActivitiesResponse, GetNumberOfDelegatorsResponse, OrderByArg } from \"../types\";\nimport { GetDelegatedStakingActivitiesQuery, GetNumberOfDelegatorsQuery } from \"../types/generated/operations\";\nimport { GetDelegatedStakingActivities, GetNumberOfDelegators } from \"../types/generated/queries\";\nimport { queryIndexer } from \"./general\";\n\n/**\n * Retrieves the number of active delegators for a specified pool address.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.poolAddress - The address of the pool for which to retrieve the number of delegators.\n * @returns The number of active delegators for the specified pool address.\n * @group Implementation\n */\nexport async function getNumberOfDelegators(args: {\n  aptosConfig: AptosConfig;\n  poolAddress: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, poolAddress } = args;\n  const address = AccountAddress.from(poolAddress).toStringLong();\n  const query = {\n    query: GetNumberOfDelegators,\n    variables: { where_condition: { pool_address: { _eq: address } } },\n  };\n  const data = await queryIndexer<GetNumberOfDelegatorsQuery>({ aptosConfig, query });\n\n  // commonjs (aka cjs) doesn't handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return data.num_active_delegator_per_pool[0] ? data.num_active_delegator_per_pool[0].num_active_delegator : 0;\n}\n\n/**\n * Retrieves the number of active delegators for all pools.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param [args.options] - Optional parameters for ordering the results.\n * @param args.options.orderBy - Specifies the order in which to return the results.\n * @returns The number of active delegators per pool.\n * @group Implementation\n */\nexport async function getNumberOfDelegatorsForAllPools(args: {\n  aptosConfig: AptosConfig;\n  options?: OrderByArg<GetNumberOfDelegatorsResponse[0]>;\n}): Promise<GetNumberOfDelegatorsResponse> {\n  const { aptosConfig, options } = args;\n  const query = {\n    query: GetNumberOfDelegators,\n    variables: { order_by: options?.orderBy },\n  };\n  const data = await queryIndexer<GetNumberOfDelegatorsQuery>({\n    aptosConfig,\n    query,\n  });\n  return data.num_active_delegator_per_pool;\n}\n\n/**\n * Retrieves the delegated staking activities for a specified delegator and pool.\n *\n * @param args - The parameters for the query.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.delegatorAddress - The address of the delegator whose activities are being queried.\n * @param args.poolAddress - The address of the pool associated with the delegated staking activities.\n * @returns The delegated staking activities for the specified delegator and pool.\n * @group Implementation\n */\nexport async function getDelegatedStakingActivities(args: {\n  aptosConfig: AptosConfig;\n  delegatorAddress: AccountAddressInput;\n  poolAddress: AccountAddressInput;\n}): Promise<GetDelegatedStakingActivitiesResponse> {\n  const { aptosConfig, delegatorAddress, poolAddress } = args;\n  const query = {\n    query: GetDelegatedStakingActivities,\n    variables: {\n      delegatorAddress: AccountAddress.from(delegatorAddress).toStringLong(),\n      poolAddress: AccountAddress.from(poolAddress).toStringLong(),\n    },\n  };\n  const data = await queryIndexer<GetDelegatedStakingActivitiesQuery>({ aptosConfig, query });\n  return data.delegated_staking_activities;\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  getDelegatedStakingActivities,\n  getNumberOfDelegators,\n  getNumberOfDelegatorsForAllPools,\n} from \"../internal/staking\";\nimport { AnyNumber, GetDelegatedStakingActivitiesResponse, GetNumberOfDelegatorsResponse, OrderByArg } from \"../types\";\nimport { AccountAddressInput } from \"../core\";\nimport { ProcessorType } from \"../utils/const\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { waitForIndexerOnVersion } from \"./utils\";\n\n/**\n * A class to query all `Staking` related queries on Aptos.\n * @group Staking\n */\nexport class Staking {\n  /**\n   * Creates an instance of the Aptos client with the specified configuration.\n   * This allows you to interact with the Aptos blockchain using the provided settings.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   * @param config.network - The network to connect to (e.g., TESTNET, MAINNET).\n   * @param config.nodeUrl - The URL of the Aptos node to connect to.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a configuration for the Aptos client\n   *     const config = new AptosConfig({ network: Network.TESTNET }); // Specify your network\n   *\n   *     // Initialize the Aptos client with the configuration\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Staking\n   */\n  constructor(readonly config: AptosConfig) {}\n\n  /**\n   * Queries the current number of delegators in a specified pool. Throws an error if the pool is not found.\n   *\n   * @param args - The parameters for the query.\n   * @param args.poolAddress - The address of the pool to query.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @returns The number of delegators for the given pool.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the number of delegators for a specific pool\n   *   const delegators = await aptos.getNumberOfDelegators({ poolAddress: \"0x1\" }); // replace with a real pool address\n   *   console.log(`Number of delegators: ${delegators}`);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Staking\n   */\n  async getNumberOfDelegators(args: {\n    poolAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<number> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args?.minimumLedgerVersion,\n      processorType: ProcessorType.STAKE_PROCESSOR,\n    });\n    return getNumberOfDelegators({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieves the current number of delegators across all pools.\n   *\n   * @param args Optional parameters for the query.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to before querying.\n   * @param args.options Optional ordering options for the response.\n   * @returns GetNumberOfDelegatorsForAllPoolsResponse response type containing the number of delegators per pool.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve the number of delegators for all pools\n   *   const delegators = await aptos.getNumberOfDelegatorsForAllPools();\n   *   console.log(delegators);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Staking\n   */\n  async getNumberOfDelegatorsForAllPools(args?: {\n    minimumLedgerVersion?: AnyNumber;\n    options?: OrderByArg<GetNumberOfDelegatorsResponse[0]>;\n  }): Promise<GetNumberOfDelegatorsResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args?.minimumLedgerVersion,\n      processorType: ProcessorType.STAKE_PROCESSOR,\n    });\n    return getNumberOfDelegatorsForAllPools({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries delegated staking activities for a specific delegator and pool.\n   *\n   * @param args - The arguments for querying delegated staking activities.\n   * @param args.delegatorAddress - The address of the delegator.\n   * @param args.poolAddress - The address of the staking pool.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @returns The response containing delegated staking activities.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get delegated staking activities for a specific delegator and pool\n   *   const activities = await aptos.getDelegatedStakingActivities({\n   *     delegatorAddress: \"0x1\", // replace with a real delegator address\n   *     poolAddress: \"0x2\", // replace with a real pool address\n   *     minimumLedgerVersion: 1, // specify your own if needed\n   *   });\n   *\n   *   console.log(activities);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Staking\n   */\n  async getDelegatedStakingActivities(args: {\n    delegatorAddress: AccountAddressInput;\n    poolAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<GetDelegatedStakingActivitiesResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args?.minimumLedgerVersion,\n      processorType: ProcessorType.STAKE_PROCESSOR,\n    });\n    return getDelegatedStakingActivities({ aptosConfig: this.config, ...args });\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountAddress, AccountAddressInput } from \"../../core\";\nimport { generateTransaction } from \"../../internal/transactionSubmission\";\nimport {\n  InputGenerateTransactionPayloadData,\n  InputGenerateTransactionOptions,\n  AptosScriptComposer,\n  TransactionPayloadScript,\n  generateRawTransaction,\n} from \"../../transactions\";\nimport { MultiAgentTransaction } from \"../../transactions/instances/multiAgentTransaction\";\nimport { SimpleTransaction } from \"../../transactions/instances/simpleTransaction\";\nimport { AptosConfig } from \"../aptosConfig\";\nimport { Deserializer } from \"../../bcs\";\n\n/**\n * A class to handle all `Build` transaction operations.\n * @group Implementation\n */\nexport class Build {\n  readonly config: AptosConfig;\n\n  /**\n   * Initializes a new instance of the Aptos client with the specified configuration.\n   * This allows you to interact with the Aptos blockchain using the provided settings.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   * @param config.network - The network to connect to (e.g., TESTNET, MAINNET).\n   * @param config.nodeUrl - The URL of the Aptos node to connect to.\n   * @param config.account - The account details for authentication.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a configuration for the Aptos client\n   *     const config = new AptosConfig({\n   *         network: Network.TESTNET, // specify the network\n   *         nodeUrl: \"https://testnet.aptos.dev\", // specify the node URL\n   *     });\n   *\n   *     // Initialize the Aptos client\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Implementation\n   */\n  constructor(config: AptosConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Build a simple transaction.\n   *\n   * This function allows you to create a transaction with specified sender and data.\n   *\n   * @param args.sender - The sender account address.\n   * @param args.data - The transaction data.\n   * @param args.options - Optional transaction configurations.\n   * @param args.withFeePayer - Whether there is a fee payer for the transaction.\n   *\n   * @returns SimpleTransaction\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Build a simple transaction\n   *   const transaction = await aptos.transaction.simple({\n   *     sender: \"0x1\", // replace with a real sender account address\n   *     data: {\n   *       function: \"0x1::aptos_account::transfer\",\n   *       functionArguments: [\"0x2\", 100], // replace with a real destination account address\n   *     },\n   *     options: {\n   *       gasUnitPrice: 100, // specify your own gas unit price if needed\n   *       maxGasAmount: 1000, // specify your own max gas amount if needed\n   *     },\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Implementation\n   */\n  async simple(args: {\n    sender: AccountAddressInput;\n    data: InputGenerateTransactionPayloadData;\n    options?: InputGenerateTransactionOptions;\n    withFeePayer?: boolean;\n  }): Promise<SimpleTransaction> {\n    return generateTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Build a transaction from a series of Move calls.\n   *\n   * This function allows you to create a transaction with a list of Move calls.\n   *\n   * Right now we only tested this logic with single signer and we will add support\n   * for mutli agent transactions if needed.\n   *\n   * @param args.sender - The sender account address.\n   * @param args.builder - The closure to construct the list of calls.\n   * @param args.options - Optional transaction configurations.\n   * @param args.withFeePayer - Whether there is a fee payer for the transaction.\n   *\n   * @returns SimpleTransaction\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Build a transaction from a chained series of Move calls.\n   *   const transaction = await aptos.transaction.build.scriptComposer({\n   *     sender: \"0x1\", // replace with a real sender account address\n   *     builder: builder: async (builder) => {\n   *       const coin = await builder.addBatchedCalls({\n   *          function: \"0x1::coin::withdraw\",\n   *          functionArguments: [CallArgument.new_signer(0), 1],\n   *          typeArguments: [\"0x1::aptos_coin::AptosCoin\"],\n   *        });\n   *\n   *        // Pass the returned value from the first function call to the second call\n   *        const fungibleAsset = await builder.addBatchedCalls({\n   *          function: \"0x1::coin::coin_to_fungible_asset\",\n   *          functionArguments: [coin[0]],\n   *          typeArguments: [\"0x1::aptos_coin::AptosCoin\"],\n   *        });\n   *\n   *        await builder.addBatchedCalls({\n   *          function: \"0x1::primary_fungible_store::deposit\",\n   *          functionArguments: [singleSignerED25519SenderAccount.accountAddress, fungibleAsset[0]],\n   *          typeArguments: [],\n   *        });\n   *        return builder;\n   *     },\n   *     options: {\n   *       gasUnitPrice: 100, // specify your own gas unit price if needed\n   *       maxGasAmount: 1000, // specify your own max gas amount if needed\n   *     },\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  async scriptComposer(args: {\n    sender: AccountAddressInput;\n    builder: (builder: AptosScriptComposer) => Promise<AptosScriptComposer>;\n    options?: InputGenerateTransactionOptions;\n    withFeePayer?: boolean;\n  }): Promise<SimpleTransaction> {\n    const composer = new AptosScriptComposer(this.config);\n    await composer.init();\n    const builder = await args.builder(composer);\n    const bytes = builder.build();\n    const rawTxn = await generateRawTransaction({\n      aptosConfig: this.config,\n      payload: TransactionPayloadScript.load(new Deserializer(bytes)),\n      ...args,\n    });\n    return new SimpleTransaction(rawTxn, args.withFeePayer === true ? AccountAddress.ZERO : undefined);\n  }\n\n  /**\n   * Build a multi-agent transaction that allows multiple signers to authorize a transaction.\n   *\n   * @param args - The parameters for creating the multi-agent transaction.\n   * @param args.sender - The sender account address.\n   * @param args.data - The transaction data.\n   * @param args.secondarySignerAddresses - An array of the secondary signers' account addresses.\n   * @param args.options - Optional transaction configurations.\n   * @param args.withFeePayer - Whether there is a fee payer for the transaction.\n   *\n   * @returns MultiAgentTransaction\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Build a multi-agent transaction\n   *   const transaction = await aptos.multiAgent({\n   *     sender: \"0x1\", // replace with a real sender account address\n   *     data: {\n   *       // Transaction data structure\n   *       function: \"0x1::aptos_account::transfer\",\n   *       functionArguments: [\"0x2\", 100], // replace with a real destination account address and amount\n   *     },\n   *     secondarySignerAddresses: [\"0x3\", \"0x4\"], // replace with real secondary signer addresses\n   *     options: {\n   *       // Optional transaction configurations\n   *       maxGasAmount: \"1000\",\n   *       gasUnitPrice: \"1\",\n   *     },\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Implementation\n   */\n  async multiAgent(args: {\n    sender: AccountAddressInput;\n    data: InputGenerateTransactionPayloadData;\n    secondarySignerAddresses: AccountAddressInput[];\n    options?: InputGenerateTransactionOptions;\n    withFeePayer?: boolean;\n  }): Promise<MultiAgentTransaction> {\n    return generateTransaction({ aptosConfig: this.config, ...args });\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { PublicKey } from \"../../core\";\nimport { simulateTransaction } from \"../../internal/transactionSubmission\";\nimport { AnyRawTransaction, InputSimulateTransactionOptions } from \"../../transactions\";\nimport { UserTransactionResponse } from \"../../types\";\nimport { AptosConfig } from \"../aptosConfig\";\nimport { ValidateFeePayerDataOnSimulation } from \"./helpers\";\n\n/**\n * A class to handle all `Simulate` transaction operations.\n * @group Implementation\n */\nexport class Simulate {\n  readonly config: AptosConfig;\n\n  /**\n   * Initializes a new instance of the Aptos client with the specified configuration.\n   * This allows you to interact with the Aptos blockchain using the provided settings.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   * @param config.network - The network to connect to (e.g., TESTNET, MAINNET).\n   * @param config.nodeUrl - The URL of the Aptos node to connect to.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a configuration for the Aptos client\n   *     const config = new AptosConfig({ network: Network.TESTNET }); // Specify your desired network\n   *\n   *     // Initialize the Aptos client with the configuration\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Implementation\n   */\n  constructor(config: AptosConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Simulates a transaction based on the provided parameters and returns the result.\n   * This function helps you understand the outcome of a transaction before executing it on the blockchain.\n   *\n   * @param args - The parameters for simulating the transaction.\n   * @param args.signerPublicKey - The public key of the signer for the transaction (optional).\n   * @param args.transaction - The raw transaction data to simulate.\n   * @param args.feePayerPublicKey - The public key of the fee payer (optional).\n   * @param args.options - Additional options for simulating the transaction (optional).\n   *\n   * @example\n   * ```typescript\n   * import {\n   *     Account,\n   *     Aptos,\n   *     AptosConfig,\n   *     Network,\n   * } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function example() {\n   *     let sender = Account.generate();\n   *     let receiver = Account.generate();\n   *\n   *     // 0. Set up the client and test accounts\n   *     const config = new AptosConfig({ network: Network.DEVNET });\n   *     const aptos = new Aptos(config);\n   *\n   *     await aptos.fundAccount({\n   *         accountAddress: sender.accountAddress,\n   *         amount: 100_000_000,\n   *     });\n   *\n   *     // 1. Build the transaction to preview the impact of it\n   *     const transaction = await aptos.transaction.build.simple({\n   *         sender: sender.accountAddress,\n   *         data: {\n   *             // All transactions on Aptos are implemented via smart contracts.\n   *             function: \"0x1::aptos_account::transfer\",\n   *             functionArguments: [receiver.accountAddress, 100],\n   *         },\n   *     });\n   *\n   *     // 2. Simulate to see what would happen if we execute this transaction\n   *     const [userTransactionResponse] = await aptos.transaction.simulate.simple({\n   *         signerPublicKey: sender.publicKey,\n   *         transaction,\n   *     });\n   *     console.log(userTransactionResponse);\n   *\n   *     // If the fee looks ok, continue to signing!\n   *     // ...\n   * }\n   *\n   * example();\n   * ```\n   * @group Implementation\n   */\n  @ValidateFeePayerDataOnSimulation\n  async simple(args: {\n    signerPublicKey?: PublicKey;\n    transaction: AnyRawTransaction;\n    feePayerPublicKey?: PublicKey;\n    options?: InputSimulateTransactionOptions;\n  }): Promise<Array<UserTransactionResponse>> {\n    return simulateTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Simulates a multi-agent transaction by generating a signed transaction and posting it to the Aptos full node.\n   * This function helps in understanding the outcome of a transaction involving multiple signers before it is executed.\n   *\n   * @param args - The parameters for simulating the transaction.\n   * @param args.signerPublicKey - The public key of the primary signer (optional).\n   * @param args.transaction - The raw transaction to be simulated.\n   * @param args.secondarySignersPublicKeys - An array of public keys for secondary signers (optional).\n   *        Each element of the array can be optional, allowing the corresponding key check to be skipped.\n   * @param args.feePayerPublicKey - The public key of the fee payer (optional).\n   * @param args.options - Options for simulating the transaction (optional).\n   *\n   * @example\n   * ```typescript\n   * import {\n   *     Account,\n   *     Aptos,\n   *     AptosConfig,\n   *     Network,\n   * } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function example() {\n   *     let sender1 = Account.generate();\n   *     let sender2 = Account.generate();\n   *     let receiver = Account.generate();\n   *\n   *     // 0. Set up the client and test accounts\n   *     const config = new AptosConfig({ network: Network.DEVNET });\n   *     const aptos = new Aptos(config);\n   *\n   *     await aptos.fundAccount({\n   *         accountAddress: sender.accountAddress,\n   *         amount: 100_000_000,\n   *     });\n   *\n   *     // 1. Build\n   *     console.log(\"\\n=== 1. Building the transaction ===\\n\");\n   *     const transaction = await aptos.transaction.build.multiAgent({\n   *     sender: sender1.accountAddress,\n   *     secondarySignerAddresses: [sender2.accountAddress],\n   *     data: {\n   *        // REPLACE WITH YOUR MULTI-AGENT FUNCTION HERE\n   *        function:\n   *          \"<REPLACE WITH YOUR MULTI AGENT MOVE ENTRY FUNCTION> (Syntax {address}::{module}::{function})\",\n   *          functionArguments: [],\n   *        },\n   *      });\n   *      console.log(\"Transaction:\", transaction);\n   *\n   *      // 2. Simulate (Optional)\n   *      console.log(\"\\n === 2. Simulating Response (Optional) === \\n\");\n   *      const [userTransactionResponse] = await aptos.transaction.simulate.multiAgent(\n   *        {\n   *          signerPublicKey: sender1.publicKey,\n   *          secondarySignersPublicKeys: [sender2.publicKey],\n   *          transaction,\n   *        },\n   *      );\n   *      console.log(userTransactionResponse);\n   *\n   *      // If the fee looks ok, continue to signing!\n   *      // ...\n   * }\n   *\n   * example();\n   * ```\n   * @group Implementation\n   */\n  @ValidateFeePayerDataOnSimulation\n  async multiAgent(args: {\n    signerPublicKey?: PublicKey;\n    transaction: AnyRawTransaction;\n    secondarySignersPublicKeys?: Array<PublicKey | undefined>;\n    feePayerPublicKey?: PublicKey;\n    options?: InputSimulateTransactionOptions;\n  }): Promise<Array<UserTransactionResponse>> {\n    return simulateTransaction({ aptosConfig: this.config, ...args });\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { submitTransaction } from \"../../internal/transactionSubmission\";\nimport { AccountAuthenticator, AnyRawTransaction } from \"../../transactions\";\nimport { PendingTransactionResponse } from \"../../types\";\nimport { AptosConfig } from \"../aptosConfig\";\nimport { ValidateFeePayerDataOnSubmission } from \"./helpers\";\n\n/**\n * A class to handle all `Submit` transaction operations.\n * @group Implementation\n */\nexport class Submit {\n  readonly config: AptosConfig;\n\n  /**\n   * Initializes a new instance of the Aptos client with the specified configuration.\n   * This allows you to interact with the Aptos blockchain using the provided settings.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   * @param config.network - The network to connect to (e.g., TESTNET, MAINNET).\n   * @param config.nodeUrl - The URL of the Aptos node to connect to.\n   * @param config.faucetUrl - The URL of the faucet for obtaining test tokens.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a configuration for the Aptos client\n   *     const config = new AptosConfig({\n   *         network: Network.TESTNET, // Use the TESTNET for testing\n   *         nodeUrl: \"https://testnet.aptos.dev\", // Specify the node URL\n   *         faucetUrl: \"https://faucet.testnet.aptos.dev\" // Specify the faucet URL\n   *     });\n   *\n   *     // Initialize the Aptos client with the configuration\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Implementation\n   */\n  constructor(config: AptosConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Submits a transaction to the Aptos blockchain using the provided transaction details and authenticators.\n   * This function allows you to execute transactions securely by specifying the sender and optional fee payer authenticators.\n   *\n   * @param args - The arguments for submitting the transaction.\n   * @param args.transaction - The raw transaction data to be submitted.\n   * @param args.senderAuthenticator - The authenticator for the sender's account.\n   * @param [args.feePayerAuthenticator] - The optional authenticator for the fee payer's account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Account } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const sender = Account.generate(); // Generate a new sender account\n   *   const transaction = await aptos.transaction.build.simple({\n   *     sender: sender.accountAddress,\n   *     data: {\n   *       function: \"0x1::aptos_account::transfer\",\n   *       functionArguments: [Account.generate().accountAddress, 100], // Replace with a real destination account\n   *     },\n   *   });\n   *\n   *   // Submit the transaction\n   *   const response = await aptos.simple({\n   *     transaction,\n   *     senderAuthenticator: sender.getAuthenticator(), // Use the sender's authenticator\n   *   });\n   *\n   *   console.log(\"Transaction submitted:\", response);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Implementation\n   */\n  @ValidateFeePayerDataOnSubmission\n  async simple(args: {\n    transaction: AnyRawTransaction;\n    senderAuthenticator: AccountAuthenticator;\n    feePayerAuthenticator?: AccountAuthenticator;\n  }): Promise<PendingTransactionResponse> {\n    return submitTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Submits a multi-agent transaction to the Aptos network, allowing multiple signers to authorize the transaction.\n   * This function is useful for scenarios where a transaction requires approval from multiple accounts.\n   *\n   * @param args - The parameters for the multi-agent transaction.\n   * @param args.transaction - The raw transaction to be submitted.\n   * @param args.senderAuthenticator - The authenticator for the sender account.\n   * @param args.additionalSignersAuthenticators - An array of authenticators for additional signers.\n   * @param [args.feePayerAuthenticator] - An optional authenticator for the fee payer account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Account } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const sender = Account.generate(); // Generate a new sender account\n   *   const additionalSigner1 = Account.generate(); // Generate an additional signer account\n   *   const additionalSigner2 = Account.generate(); // Generate another additional signer account\n   *\n   *   const transaction = await aptos.transaction.build.simple({\n   *     sender: sender.accountAddress,\n   *     data: {\n   *       function: \"0x1::aptos_account::transfer\",\n   *       functionArguments: [additionalSigner1.accountAddress, 100],\n   *     },\n   *   });\n   *\n   *   const response = await aptos.multiAgent({\n   *     transaction,\n   *     senderAuthenticator: sender.getAuthenticator(), // Use the sender's authenticator\n   *     additionalSignersAuthenticators: [\n   *       additionalSigner1.getAuthenticator(), // Use the first additional signer's authenticator\n   *       additionalSigner2.getAuthenticator(), // Use the second additional signer's authenticator\n   *     ],\n   *   });\n   *\n   *   console.log(response); // Log the response from the transaction submission\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Implementation\n   */\n  @ValidateFeePayerDataOnSubmission\n  async multiAgent(args: {\n    transaction: AnyRawTransaction;\n    senderAuthenticator: AccountAuthenticator;\n    additionalSignersAuthenticators: Array<AccountAuthenticator>;\n    feePayerAuthenticator?: AccountAuthenticator;\n  }): Promise<PendingTransactionResponse> {\n    return submitTransaction({ aptosConfig: this.config, ...args });\n  }\n}\n","import EventEmitter from \"eventemitter3\";\nimport { TransactionWorkerEvents, TransactionWorker, TransactionWorkerEventsEnum } from \"../../transactions/management\";\nimport { InputGenerateTransactionPayloadData, InputGenerateTransactionOptions } from \"../../transactions\";\nimport { AptosConfig } from \"../aptosConfig\";\nimport { Account } from \"../../account\";\n\nexport class TransactionManagement extends EventEmitter<TransactionWorkerEvents> {\n  account!: Account;\n\n  transactionWorker!: TransactionWorker;\n\n  readonly config: AptosConfig;\n\n  /**\n   * Initializes a new instance of the Aptos client with the provided configuration settings.\n   * This allows you to interact with the Aptos blockchain using the specified network and options.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   * @param config.network - The network to connect to (e.g., TESTNET, MAINNET).\n   * @param config.nodeUrl - The URL of the Aptos node to connect to.\n   * @param config.account - Optional account settings for authentication.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a configuration for the Aptos client\n   *     const config = new AptosConfig({\n   *         network: Network.TESTNET, // specify the network to use\n   *         nodeUrl: \"https://testnet.aptos.dev\" // replace with your node URL\n   *     });\n   *\n   *     // Initialize the Aptos client with the configuration\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized successfully.\");\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Implementation\n   */\n  constructor(config: AptosConfig) {\n    super();\n    this.config = config;\n  }\n\n  /**\n   * Initializes the transaction worker using the provided sender account and begins listening for events.\n   * This function is essential for setting up the transaction processing environment.\n   *\n   * @param args - The arguments for starting the transaction worker.\n   * @param args.sender - The sender account to sign and submit the transaction.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Account } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *     const sender = Account.generate(); // Generate a new account for sending transactions\n   *\n   *     // Start the transaction worker with the sender account\n   *     aptos.start({ sender });\n   *\n   *     console.log(\"Transaction worker started with sender:\", sender.accountAddress);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Implementation\n   */\n  private start(args: { sender: Account }): void {\n    const { sender } = args;\n    this.account = sender;\n    this.transactionWorker = new TransactionWorker(this.config, sender);\n\n    this.transactionWorker.start();\n    this.registerToEvents();\n  }\n\n  /**\n   * Pushes transaction data to the transaction worker for processing.\n   *\n   * @param args.data An array of transaction payloads to be processed.\n   * @param args.options Optional. Transaction generation configurations (excluding accountSequenceNumber).\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Prepare transaction payloads\n   *   const payloads = [\n   *      {}, // Build your first transaction payload\n   *      {}, // Build your second transaction payload\n   *   ];\n   *\n   *   // Push transaction data to the worker\n   *   aptos.push({\n   *     data: payloads,\n   *     {}, // Specify options as needed\n   *   });\n   *\n   *   console.log(\"Transaction data pushed successfully.\");\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Implementation\n   */\n  private push(args: {\n    data: InputGenerateTransactionPayloadData[];\n    options?: Omit<InputGenerateTransactionOptions, \"accountSequenceNumber\">;\n  }): void {\n    const { data, options } = args;\n\n    for (const d of data) {\n      this.transactionWorker.push(d, options);\n    }\n  }\n\n  /**\n   * Starts listening to transaction worker events, allowing the application to respond to transaction status changes.\n   * This function enables the application to handle events such as transaction sent, execution success, or failure.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Register to listen for transaction events\n   *   aptos.registerToEvents();\n   *\n   *   // You can send a transaction here to see the events in action\n   *   const sender = Account.generate(); // replace with a real account\n   *   const destination = Account.generate(); // replace with a real account\n   *\n   *   const transaction = await aptos.transaction.build.simple({\n   *     sender: sender.accountAddress,\n   *     data: {\n   *       function: \"0x1::aptos_account::transfer\",\n   *       functionArguments: [destination.accountAddress, 100],\n   *     },\n   *   });\n   *\n   *   await aptos.transaction.send(transaction);\n   *\n   *   console.log(\"Transaction sent and events registered.\");\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Implementation\n   */\n  private registerToEvents() {\n    // TODO - Should we ask events to listen to this as an input?\n    this.transactionWorker.on(TransactionWorkerEventsEnum.TransactionSent, async (data) => {\n      this.emit(TransactionWorkerEventsEnum.TransactionSent, data);\n    });\n    this.transactionWorker.on(TransactionWorkerEventsEnum.TransactionSendFailed, async (data) => {\n      this.emit(TransactionWorkerEventsEnum.TransactionSendFailed, data);\n    });\n    this.transactionWorker.on(TransactionWorkerEventsEnum.TransactionExecuted, async (data) => {\n      this.emit(TransactionWorkerEventsEnum.TransactionExecuted, data);\n    });\n    this.transactionWorker.on(TransactionWorkerEventsEnum.TransactionExecutionFailed, async (data) => {\n      this.emit(TransactionWorkerEventsEnum.TransactionExecutionFailed, data);\n    });\n    this.transactionWorker.on(TransactionWorkerEventsEnum.ExecutionFinish, async (data) => {\n      this.emit(TransactionWorkerEventsEnum.ExecutionFinish, data);\n    });\n  }\n\n  /**\n   * Send batch transactions for a single account.\n   *\n   * This function uses a transaction worker that receives payloads to be processed\n   * and submitted to chain.\n   * Note that this process is best for submitting multiple transactions that\n   * don't rely on each other, i.e. batch funds, batch token mints, etc.\n   *\n   * If any worker failure, the functions throws an error.\n   *\n   * @param args.sender The sender account to sign and submit the transaction\n   * @param args.data An array of transaction payloads\n   * @param args.options optional. Transaction generation configurations (excluding accountSequenceNumber)\n   *\n   * @return void. Throws if any error\n   * @group Implementation\n   */\n  forSingleAccount(args: {\n    sender: Account;\n    data: InputGenerateTransactionPayloadData[];\n    options?: Omit<InputGenerateTransactionOptions, \"accountSequenceNumber\">;\n  }): void {\n    try {\n      const { sender, data, options } = args;\n      this.start({ sender });\n\n      this.push({ data, options });\n    } catch (error: any) {\n      throw new Error(`failed to submit transactions with error: ${error}`);\n    }\n  }\n}\n","/**\n * A wrapper that handles and manages an account sequence number.\n *\n * Submit up to `maximumInFlight` transactions per account in parallel with a timeout of `sleepTime`\n * If local assumes `maximumInFlight` are in flight, determine the actual committed state from the network\n * If there are less than `maximumInFlight` due to some being committed, adjust the window\n * If `maximumInFlight` are in flight, wait `sleepTime` seconds before re-evaluating\n * If ever waiting more than `maxWaitTime` restart the sequence number to the current on-chain state\n *\n * Assumptions:\n * Accounts are expected to be managed by a single AccountSequenceNumber and not used otherwise.\n * They are initialized to the current on-chain state, so if there are already transactions in\n * flight, they may take some time to reset.\n * Accounts are automatically initialized if not explicitly\n *\n * Notes:\n * This is co-routine safe, that is many async tasks can be reading from this concurrently.\n * The state of an account cannot be used across multiple AccountSequenceNumber services.\n * The synchronize method will create a barrier that prevents additional nextSequenceNumber\n * calls until it is complete.\n * This only manages the distribution of sequence numbers it does not help handle transaction\n * failures.\n * If a transaction fails, you should call synchronize and wait for timeouts.\n * @group Implementation\n * @category Transactions\n */\n\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport { Account } from \"../../account\";\nimport { getInfo } from \"../../internal/account\";\nimport { nowInSeconds, sleep } from \"../../utils/helpers\";\n\n/**\n * Represents an account's sequence number management for transaction handling on the Aptos blockchain.\n * This class provides methods to retrieve the next available sequence number, synchronize with the on-chain sequence number,\n * and manage local sequence numbers while ensuring thread safety.\n *\n * @param aptosConfig - The configuration settings for Aptos.\n * @param account - The account associated with the sequence number.\n * @param maxWaitTime - The maximum time to wait for a transaction to commit.\n * @param maximumInFlight - The maximum number of transactions that can be in flight at once.\n * @param sleepTime - The time to wait before retrying to get the sequence number.\n * @group Implementation\n * @category Transactions\n */\nexport class AccountSequenceNumber {\n  readonly aptosConfig: AptosConfig;\n\n  readonly account: Account;\n\n  // sequence number on chain\n  // TODO: Change to Uncommitted\n  lastUncommintedNumber: bigint | null = null;\n\n  // local sequence number\n  currentNumber: bigint | null = null;\n\n  /**\n   * We want to guarantee that we preserve ordering of workers to requests.\n   *\n   * `lock` is used to try to prevent multiple coroutines from accessing a shared resource at the same time,\n   * which can result in race conditions and data inconsistency.\n   * This code actually doesn't do it though, since we aren't giving out a slot, it is still somewhat a race condition.\n   *\n   * The ideal solution is likely that each thread grabs the next number from an incremental integer.\n   * When they complete, they increment that number and that entity is able to enter the `lock`.\n   * That would guarantee ordering.\n   * @group Implementation\n   * @category Transactions\n   */\n  lock = false;\n\n  maxWaitTime: number;\n\n  maximumInFlight: number;\n\n  sleepTime: number;\n\n  /**\n   * Creates an instance of the class with the specified configuration and account details.\n   * This constructor initializes the necessary parameters for managing Aptos transactions.\n   *\n   * @param aptosConfig - The configuration settings for Aptos.\n   * @param account - The account associated with the Aptos transactions.\n   * @param maxWaitTime - The maximum time to wait for a transaction to be processed, in milliseconds.\n   * @param maximumInFlight - The maximum number of transactions that can be in flight at the same time.\n   * @param sleepTime - The time to sleep between transaction checks, in milliseconds.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(\n    aptosConfig: AptosConfig,\n    account: Account,\n    maxWaitTime: number,\n    maximumInFlight: number,\n    sleepTime: number,\n  ) {\n    this.aptosConfig = aptosConfig;\n    this.account = account;\n    this.maxWaitTime = maxWaitTime;\n    this.maximumInFlight = maximumInFlight;\n    this.sleepTime = sleepTime;\n  }\n\n  /**\n   * Returns the next available sequence number for this account.\n   * This function ensures that the sequence number is updated and synchronized, handling potential delays in transaction commits.\n   *\n   * @returns {BigInt} The next available sequence number.\n   * @group Implementation\n   * @category Transactions\n   */\n  async nextSequenceNumber(): Promise<bigint | null> {\n    /* eslint-disable no-await-in-loop */\n    while (this.lock) {\n      await sleep(this.sleepTime);\n    }\n\n    this.lock = true;\n    let nextNumber = BigInt(0);\n    try {\n      if (this.lastUncommintedNumber === null || this.currentNumber === null) {\n        await this.initialize();\n      }\n\n      if (this.currentNumber! - this.lastUncommintedNumber! >= this.maximumInFlight) {\n        await this.update();\n\n        const startTime = nowInSeconds();\n        while (this.currentNumber! - this.lastUncommintedNumber! >= this.maximumInFlight) {\n          await sleep(this.sleepTime);\n          if (nowInSeconds() - startTime > this.maxWaitTime) {\n            /* eslint-disable no-console */\n            console.warn(\n              `Waited over 30 seconds for a transaction to commit, re-syncing ${this.account.accountAddress.toString()}`,\n            );\n            await this.initialize();\n          } else {\n            await this.update();\n          }\n        }\n      }\n      nextNumber = this.currentNumber!;\n      this.currentNumber! += BigInt(1);\n    } catch (e) {\n      console.error(\"error in getting next sequence number for this account\", e);\n    } finally {\n      this.lock = false;\n    }\n    return nextNumber;\n  }\n\n  /**\n   * Initializes this account with the sequence number on chain.\n   *\n   * @returns {Promise<void>} A promise that resolves when the account has been initialized.\n   *\n   * @throws {Error} Throws an error if the account information cannot be retrieved.\n   * @group Implementation\n   * @category Transactions\n   */\n  async initialize(): Promise<void> {\n    const { sequence_number: sequenceNumber } = await getInfo({\n      aptosConfig: this.aptosConfig,\n      accountAddress: this.account.accountAddress,\n    });\n    this.currentNumber = BigInt(sequenceNumber);\n    this.lastUncommintedNumber = BigInt(sequenceNumber);\n  }\n\n  /**\n   * Updates this account's sequence number with the one on-chain.\n   *\n   * @returns The on-chain sequence number for this account.\n   * @group Implementation\n   * @category Transactions\n   */\n  async update(): Promise<bigint> {\n    const { sequence_number: sequenceNumber } = await getInfo({\n      aptosConfig: this.aptosConfig,\n      accountAddress: this.account.accountAddress,\n    });\n    this.lastUncommintedNumber = BigInt(sequenceNumber);\n    return this.lastUncommintedNumber;\n  }\n\n  /**\n   * Synchronizes the local sequence number with the sequence number on-chain for the specified account.\n   * This function polls the network until all submitted transactions have either been committed or until the maximum wait time has elapsed.\n   *\n   * @throws {Error} Throws an error if there is an issue synchronizing the account sequence number with the one on-chain.\n   * @group Implementation\n   * @category Transactions\n   */\n  async synchronize(): Promise<void> {\n    if (this.lastUncommintedNumber === this.currentNumber) return;\n\n    /* eslint-disable no-await-in-loop */\n    while (this.lock) {\n      await sleep(this.sleepTime);\n    }\n\n    this.lock = true;\n\n    try {\n      await this.update();\n      const startTime = nowInSeconds();\n      while (this.lastUncommintedNumber !== this.currentNumber) {\n        if (nowInSeconds() - startTime > this.maxWaitTime) {\n          /* eslint-disable no-console */\n          console.warn(\n            `Waited over 30 seconds for a transaction to commit, re-syncing ${this.account.accountAddress.toString()}`,\n          );\n          await this.initialize();\n        } else {\n          await sleep(this.sleepTime);\n          await this.update();\n        }\n      }\n    } catch (e) {\n      console.error(\"error in synchronizing this account sequence number with the one on chain\", e);\n    } finally {\n      this.lock = false;\n    }\n  }\n}\n","/* eslint-disable no-await-in-loop */\n\nimport EventEmitter from \"eventemitter3\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport { Account } from \"../../account\";\nimport { waitForTransaction } from \"../../internal/transaction\";\nimport { generateTransaction, signAndSubmitTransaction } from \"../../internal/transactionSubmission\";\nimport { PendingTransactionResponse, TransactionResponse } from \"../../types\";\nimport { InputGenerateTransactionOptions, InputGenerateTransactionPayloadData } from \"../types\";\nimport { AccountSequenceNumber } from \"./accountSequenceNumber\";\nimport { AsyncQueue, AsyncQueueCancelledError } from \"./asyncQueue\";\nimport { SimpleTransaction } from \"../instances/simpleTransaction\";\n\n/**\n * @group Implementation\n * @category Transactions\n */\nexport const promiseFulfilledStatus = \"fulfilled\";\n\n/**\n * Events emitted by the transaction worker during its operation, allowing the dapp to respond to various transaction states.\n * @group Implementation\n * @category Transactions\n */\nexport enum TransactionWorkerEventsEnum {\n  // fired after a transaction gets sent to the chain\n  TransactionSent = \"transactionSent\",\n  // fired if there is an error sending the transaction to the chain\n  TransactionSendFailed = \"transactionSendFailed\",\n  // fired when a single transaction has executed successfully\n  TransactionExecuted = \"transactionExecuted\",\n  // fired if a single transaction fails in execution\n  TransactionExecutionFailed = \"transactionExecutionFailed\",\n  // fired when the worker has finished its job / when the queue has been emptied\n  ExecutionFinish = \"executionFinish\",\n}\n\n/**\n * Defines the events emitted by the transaction worker during various stages of transaction processing. *\n * @group Implementation\n * @category Transactions\n */\nexport interface TransactionWorkerEvents {\n  transactionSent: (data: SuccessEventData) => void;\n  transactionSendFailed: (data: FailureEventData) => void;\n  transactionExecuted: (data: SuccessEventData) => void;\n  transactionExecutionFailed: (data: FailureEventData) => void;\n  executionFinish: (data: ExecutionFinishEventData) => void;\n}\n\n/**\n * The payload for when the worker has finished its job.\n * @group Implementation\n * @category Transactions\n */\nexport type ExecutionFinishEventData = {\n  message: string;\n};\n\n/**\n * The payload for a success event.\n * @group Implementation\n * @category Transactions\n */\nexport type SuccessEventData = {\n  message: string;\n  transactionHash: string;\n};\n\n/**\n * The payload for a failure event.\n * @group Implementation\n * @category Transactions\n */\nexport type FailureEventData = {\n  message: string;\n  error: string;\n};\n\n/**\n * TransactionWorker provides a simple framework for receiving payloads to be processed.\n *\n * Once one `start()` the process and pushes a new transaction, the worker acquires\n * the current account's next sequence number (by using the AccountSequenceNumber class),\n * generates a signed transaction and pushes an async submission process into the `outstandingTransactions` queue.\n * At the same time, the worker processes transactions by reading the `outstandingTransactions` queue\n * and submits the next transaction to chain, it\n * 1) waits for resolution of the submission process or get pre-execution validation error\n * and 2) waits for the resolution of the execution process or get an execution error.\n * The worker fires events for any submission and/or execution success and/or failure.\n * @group Implementation\n * @category Transactions\n */\nexport class TransactionWorker extends EventEmitter<TransactionWorkerEvents> {\n  readonly aptosConfig: AptosConfig;\n\n  readonly account: Account;\n\n  // current account sequence number\n  // TODO: Rename Sequnce -> Sequence\n  readonly accountSequnceNumber: AccountSequenceNumber;\n\n  readonly taskQueue: AsyncQueue<() => Promise<void>> = new AsyncQueue<() => Promise<void>>();\n\n  // process has started\n  started: boolean;\n\n  /**\n   * transactions payloads waiting to be generated and signed\n   *\n   * TODO support entry function payload from ABI builder\n   * @group Implementation\n   * @category Transactions\n   */\n  transactionsQueue = new AsyncQueue<\n    [InputGenerateTransactionPayloadData, InputGenerateTransactionOptions | undefined]\n  >();\n\n  /**\n   * signed transactions waiting to be submitted\n   * @group Implementation\n   * @category Transactions\n   */\n  outstandingTransactions = new AsyncQueue<[Promise<PendingTransactionResponse>, bigint]>();\n\n  /**\n   * transactions that have been submitted to chain\n   * @group Implementation\n   * @category Transactions\n   */\n  sentTransactions: Array<[string, bigint, any]> = [];\n\n  /**\n   * transactions that have been committed to chain\n   * @group Implementation\n   * @category Transactions\n   */\n  executedTransactions: Array<[string, bigint, any]> = [];\n\n  /**\n   * Initializes a new instance of the class, providing a framework for receiving payloads to be processed.\n   *\n   * @param aptosConfig - A configuration object for Aptos.\n   * @param account - The account that will be used for sending transactions.\n   * @param maxWaitTime - The maximum wait time to wait before re-syncing the sequence number to the current on-chain state,\n   * default is 30 seconds.\n   * @param maximumInFlight - The maximum number of transactions that can be submitted per account, default is 100.\n   * @param sleepTime - The time to wait in seconds before re-evaluating if the maximum number of transactions are in flight,\n   * default is 10 seconds.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(\n    aptosConfig: AptosConfig,\n    account: Account,\n    maxWaitTime: number = 30,\n    maximumInFlight: number = 100,\n    sleepTime: number = 10,\n  ) {\n    super();\n    this.aptosConfig = aptosConfig;\n    this.account = account;\n    this.started = false;\n    this.accountSequnceNumber = new AccountSequenceNumber(\n      aptosConfig,\n      account,\n      maxWaitTime,\n      maximumInFlight,\n      sleepTime,\n    );\n  }\n\n  /**\n   * Submits the next transaction for the account by generating it with the current sequence number\n   * and adding it to the outstanding transaction queue for processing.\n   * This function continues to submit transactions until there are no more to process.\n   *\n   * @throws {Error} Throws an error if the transaction submission fails.\n   * @group Implementation\n   * @category Transactions\n   */\n  async submitNextTransaction() {\n    try {\n      /* eslint-disable no-constant-condition */\n      while (true) {\n        const sequenceNumber = await this.accountSequnceNumber.nextSequenceNumber();\n        if (sequenceNumber === null) return;\n        const transaction = await this.generateNextTransaction(this.account, sequenceNumber);\n        if (!transaction) return;\n        const pendingTransaction = signAndSubmitTransaction({\n          aptosConfig: this.aptosConfig,\n          transaction,\n          signer: this.account,\n        });\n        await this.outstandingTransactions.enqueue([pendingTransaction, sequenceNumber]);\n      }\n    } catch (error: any) {\n      if (error instanceof AsyncQueueCancelledError) {\n        return;\n      }\n      throw new Error(`Submit transaction failed for ${this.account.accountAddress.toString()} with error ${error}`);\n    }\n  }\n\n  /**\n   * Reads the outstanding transaction queue and submits the transactions to the chain.\n   * This function processes each transaction, checking their status and emitting events based on whether they were successfully\n   * sent or failed.\n   *\n   * @throws {Error} Throws an error if the process execution fails.\n   * @event TransactionWorkerEventsEnum.TransactionSent - Emitted when a transaction has been successfully committed to the chain.\n   * @event TransactionWorkerEventsEnum.TransactionSendFailed - Emitted when a transaction fails to commit, along with the error\n   * reason.\n   * @event TransactionWorkerEventsEnum.ExecutionFinish - Emitted when the execution of transactions is complete.\n   * @group Implementation\n   * @category Transactions\n   */\n  async processTransactions() {\n    try {\n      /* eslint-disable no-constant-condition */\n      while (true) {\n        const awaitingTransactions = [];\n        const sequenceNumbers = [];\n        let [pendingTransaction, sequenceNumber] = await this.outstandingTransactions.dequeue();\n\n        awaitingTransactions.push(pendingTransaction);\n        sequenceNumbers.push(sequenceNumber);\n\n        while (!this.outstandingTransactions.isEmpty()) {\n          [pendingTransaction, sequenceNumber] = await this.outstandingTransactions.dequeue();\n\n          awaitingTransactions.push(pendingTransaction);\n          sequenceNumbers.push(sequenceNumber);\n        }\n        // send awaiting transactions to chain\n        const sentTransactions = await Promise.allSettled(awaitingTransactions);\n        for (let i = 0; i < sentTransactions.length && i < sequenceNumbers.length; i += 1) {\n          // check sent transaction status\n          const sentTransaction = sentTransactions[i];\n          sequenceNumber = sequenceNumbers[i];\n          if (sentTransaction.status === promiseFulfilledStatus) {\n            // transaction sent to chain\n            this.sentTransactions.push([sentTransaction.value.hash, sequenceNumber, null]);\n            // check sent transaction execution\n            this.emit(TransactionWorkerEventsEnum.TransactionSent, {\n              message: `transaction hash ${sentTransaction.value.hash} has been committed to chain`,\n              transactionHash: sentTransaction.value.hash,\n            });\n            await this.checkTransaction(sentTransaction, sequenceNumber);\n          } else {\n            // send transaction failed\n            this.sentTransactions.push([sentTransaction.status, sequenceNumber, sentTransaction.reason]);\n            this.emit(TransactionWorkerEventsEnum.TransactionSendFailed, {\n              message: `failed to commit transaction ${this.sentTransactions.length} with error ${sentTransaction.reason}`,\n              error: sentTransaction.reason,\n            });\n          }\n        }\n        this.emit(TransactionWorkerEventsEnum.ExecutionFinish, {\n          message: `execute ${sentTransactions.length} transactions finished`,\n        });\n      }\n    } catch (error: any) {\n      if (error instanceof AsyncQueueCancelledError) {\n        return;\n      }\n      throw new Error(`Process execution failed for ${this.account.accountAddress.toString()} with error ${error}`);\n    }\n  }\n\n  /**\n   * Once a transaction has been sent to the chain, this function checks for its execution status.\n   * @param sentTransaction - The transaction that was sent to the chain and is now waiting to be executed.\n   * @param sequenceNumber - The account's sequence number that was sent with the transaction.\n   * @group Implementation\n   * @category Transactions\n   */\n  async checkTransaction(sentTransaction: PromiseFulfilledResult<PendingTransactionResponse>, sequenceNumber: bigint) {\n    try {\n      const waitFor: Array<Promise<TransactionResponse>> = [];\n      waitFor.push(waitForTransaction({ aptosConfig: this.aptosConfig, transactionHash: sentTransaction.value.hash }));\n      const sentTransactions = await Promise.allSettled(waitFor);\n\n      for (let i = 0; i < sentTransactions.length; i += 1) {\n        const executedTransaction = sentTransactions[i];\n        if (executedTransaction.status === promiseFulfilledStatus) {\n          // transaction executed to chain\n          this.executedTransactions.push([executedTransaction.value.hash, sequenceNumber, null]);\n          this.emit(TransactionWorkerEventsEnum.TransactionExecuted, {\n            message: `transaction hash ${executedTransaction.value.hash} has been executed on chain`,\n            transactionHash: sentTransaction.value.hash,\n          });\n        } else {\n          // transaction execution failed\n          this.executedTransactions.push([executedTransaction.status, sequenceNumber, executedTransaction.reason]);\n          this.emit(TransactionWorkerEventsEnum.TransactionExecutionFailed, {\n            message: `failed to execute transaction ${this.executedTransactions.length} with error ${executedTransaction.reason}`,\n            error: executedTransaction.reason,\n          });\n        }\n      }\n    } catch (error: any) {\n      throw new Error(`Check transaction failed for ${this.account.accountAddress.toString()} with error ${error}`);\n    }\n  }\n\n  /**\n   * Pushes a transaction to the transactions queue for processing.\n   *\n   * @param transactionData - The transaction payload containing necessary details.\n   * @param transactionData.abi - For all entry function payloads, the ABI to skip remote ABI lookups.\n   * @param options - Optional parameters for transaction configuration.\n   * @param options.maxGasAmount - Maximum gas amount for the transaction.\n   * @param options.gasUnitPrice - Gas unit price for the transaction.\n   * @param options.expireTimestamp - Expiration timestamp on the transaction.\n   * @param options.accountSequenceNumber - The sequence number for the transaction.\n   * @group Implementation\n   * @category Transactions\n   */\n  async push(\n    transactionData: InputGenerateTransactionPayloadData,\n    options?: InputGenerateTransactionOptions,\n  ): Promise<void> {\n    this.transactionsQueue.enqueue([transactionData, options]);\n  }\n\n  /**\n   * Generates a signed transaction that can be submitted to the chain.\n   *\n   * @param account - An Aptos account used as the sender of the transaction.\n   * @param sequenceNumber - A sequence number the transaction will be generated with.\n   * @returns A signed transaction object or undefined if the transaction queue is empty.\n   * @group Implementation\n   * @category Transactions\n   */\n  async generateNextTransaction(account: Account, sequenceNumber: bigint): Promise<SimpleTransaction | undefined> {\n    if (this.transactionsQueue.isEmpty()) return undefined;\n    const [transactionData, options] = await this.transactionsQueue.dequeue();\n    return generateTransaction({\n      aptosConfig: this.aptosConfig,\n      sender: account.accountAddress,\n      data: transactionData,\n      options: { ...options, accountSequenceNumber: sequenceNumber },\n    });\n  }\n\n  /**\n   * Starts transaction submission and processing by executing tasks from the queue until it is cancelled.\n   *\n   * @throws {Error} Throws an error if unable to start transaction batching.\n   * @group Implementation\n   * @category Transactions\n   */\n  async run() {\n    try {\n      while (!this.taskQueue.isCancelled()) {\n        const task = await this.taskQueue.dequeue();\n        await task();\n      }\n    } catch (error: any) {\n      throw new Error(`Unable to start transaction batching: ${error}`);\n    }\n  }\n\n  /**\n   * Starts the transaction management process.\n   *\n   * @throws {Error} Throws an error if the worker has already started.\n   * @group Implementation\n   * @category Transactions\n   */\n  start() {\n    if (this.started) {\n      throw new Error(\"worker has already started\");\n    }\n    this.started = true;\n    this.taskQueue.enqueue(() => this.submitNextTransaction());\n    this.taskQueue.enqueue(() => this.processTransactions());\n    this.run();\n  }\n\n  /**\n   * Stops the transaction management process.\n   *\n   * @throws {Error} Throws an error if the worker has already stopped.\n   * @group Implementation\n   * @category Transactions\n   */\n  stop() {\n    if (this.taskQueue.isCancelled()) {\n      throw new Error(\"worker has already stopped\");\n    }\n    this.started = false;\n    this.taskQueue.cancel();\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AptosConfig } from \"./aptosConfig\";\nimport {\n  getGasPriceEstimation,\n  getTransactionByHash,\n  getTransactionByVersion,\n  getTransactions,\n  isTransactionPending,\n  waitForTransaction,\n} from \"../internal/transaction\";\nimport {\n  AnyNumber,\n  CommittedTransactionResponse,\n  GasEstimation,\n  HexInput,\n  PaginationArgs,\n  PendingTransactionResponse,\n  TransactionResponse,\n  WaitForTransactionOptions,\n} from \"../types\";\nimport {\n  FeePayerOrFeePayerAuthenticatorOrNeither,\n  getSigningMessage,\n  publicPackageTransaction,\n  signAndSubmitAsFeePayer,\n  signAndSubmitTransaction,\n  signAsFeePayer,\n  signTransaction,\n} from \"../internal/transactionSubmission\";\nimport {\n  AccountAuthenticator,\n  AnyRawTransaction,\n  InputGenerateTransactionOptions,\n  InputGenerateTransactionPayloadData,\n} from \"../transactions\";\nimport { AccountAddressInput, AuthenticationKey, Ed25519PrivateKey } from \"../core\";\nimport { Account } from \"../account\";\nimport { Build } from \"./transactionSubmission/build\";\nimport { Simulate } from \"./transactionSubmission/simulate\";\nimport { Submit } from \"./transactionSubmission/submit\";\nimport { TransactionManagement } from \"./transactionSubmission/management\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\nimport { rotateAuthKey } from \"../internal/account\";\n\n/**\n * Represents a transaction in the Aptos blockchain,\n * providing methods to build, simulate, submit, and manage transactions.\n * This class encapsulates functionalities for querying transaction details,\n * estimating gas prices, signing transactions, and handling transaction states.\n *\n * This class is used as part of the Aptos object, so should be called like so:\n * @example\n * ```typescript\n * import { Account, Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n *\n * const APTOS_COIN = \"0x1::aptos_coin::AptosCoin\";\n * const COIN_STORE = `0x1::coin::CoinStore<${APTOS_COIN}>`;\n * const ALICE_INITIAL_BALANCE = 100_000_000;\n * const TRANSFER_AMOUNT = 100;\n *\n * async function example() {\n *   console.log(\n *     \"This example will create two accounts (Alice and Bob), fund them, and transfer between them.\",\n *   );\n *\n *   // Set up the client\n *   const config = new AptosConfig({ network: Network.DEVNET });\n *   const aptos = new Aptos(config);\n *\n *   // Generate two account credentials\n *   // Each account has a private key, a public key, and an address\n *   const alice = Account.generate();\n *   const bob = Account.generate();\n *\n *   console.log(\"=== Addresses ===\\n\");\n *   console.log(`Alice's address is: ${alice.accountAddress}`);\n *   console.log(`Bob's address is: ${bob.accountAddress}`);\n *\n *   // Fund the accounts using a faucet\n *   console.log(\"\\n=== Funding accounts ===\\n\");\n *\n *   await aptos.fundAccount({\n *     accountAddress: alice.accountAddress,\n *     amount: ALICE_INITIAL_BALANCE,\n *   });\n *\n *   // Send a transaction from Alice's account to Bob's account\n *   const txn = await aptos.transaction.build.simple({\n *     sender: alice.accountAddress,\n *     data: {\n *       // All transactions on Aptos are implemented via smart contracts.\n *       function: \"0x1::aptos_account::transfer\",\n *       functionArguments: [bob.accountAddress, 100],\n *     },\n *   });\n *\n *   console.log(\"\\n=== Transfer transaction ===\\n\");\n *   // Both signs and submits\n *   const committedTxn = await aptos.signAndSubmitTransaction({\n *     signer: alice,\n *     transaction: txn,\n *  });\n *   // Waits for Aptos to verify and execute the transaction\n *   const executedTransaction = await aptos.waitForTransaction({\n *     transactionHash: committedTxn.hash,\n *   });\n *   console.log(\"Transaction hash:\", executedTransaction.hash);\n *\n *  console.log(\"\\n=== Balances after transfer ===\\n\");\n *  const newAliceAccountBalance = await aptos.getAccountResource({\n *    accountAddress: alice.accountAddress,\n *    resourceType: COIN_STORE,\n *  });\n *  const newAliceBalance = Number(newAliceAccountBalance.coin.value);\n *  console.log(`Alice's balance is: ${newAliceBalance}`);\n *\n *  const newBobAccountBalance = await aptos.getAccountResource({\n *    accountAddress: bob.accountAddress,\n *    resourceType: COIN_STORE,\n *  });\n *  const newBobBalance = Number(newBobAccountBalance.coin.value);\n *  console.log(`Bob's balance is: ${newBobBalance}`);\n * }\n *\n * example();\n * ```\n * @group Transaction\n */\nexport class Transaction {\n  readonly config: AptosConfig;\n\n  readonly build: Build;\n\n  readonly simulate: Simulate;\n\n  readonly submit: Submit;\n\n  readonly batch: TransactionManagement;\n\n  /**\n   * Creates an instance of the Aptos client with the specified configuration.\n   * This allows you to interact with the Aptos blockchain using the provided settings.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   * @param config.network - The network to connect to (e.g., Testnet, Mainnet).\n   * @param config.nodeUrl - The URL of the Aptos node to connect to.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a new Aptos client instance\n   *     const config = new AptosConfig({ network: Network.TESTNET }); // Specify the network\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client created successfully:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  constructor(config: AptosConfig) {\n    this.config = config;\n    this.build = new Build(this.config);\n    this.simulate = new Simulate(this.config);\n    this.submit = new Submit(this.config);\n    this.batch = new TransactionManagement(this.config);\n  }\n\n  /**\n   * Queries on-chain transactions, excluding pending transactions.\n   * Use this function to retrieve historical transactions from the blockchain.\n   *\n   * @param args Optional parameters for pagination.\n   * @param args.options Optional pagination options.\n   * @param args.options.offset The number of the transaction to start with.\n   * @param args.options.limit The number of results to return.\n   *\n   * @returns An array of on-chain transactions.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetch transactions with pagination\n   *   const transactions = await aptos.getTransactions({\n   *     options: {\n   *       offset: 0, // Start from the first transaction\n   *       limit: 10, // Limit to 10 results\n   *     },\n   *   });\n   *\n   *   console.log(transactions);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async getTransactions(args?: { options?: PaginationArgs }): Promise<TransactionResponse[]> {\n    return getTransactions({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries on-chain transaction by version. This function will not return pending transactions.\n   *\n   * @param args - The arguments for querying the transaction.\n   * @param args.ledgerVersion - Transaction version is an unsigned 64-bit number.\n   * @returns On-chain transaction. Only on-chain transactions have versions, so this\n   * function cannot be used to query pending transactions.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching a transaction by its version\n   *   const transaction = await aptos.getTransactionByVersion({ ledgerVersion: 1 }); // replace 1 with a real version\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async getTransactionByVersion(args: { ledgerVersion: AnyNumber }): Promise<TransactionResponse> {\n    return getTransactionByVersion({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries on-chain transactions by their transaction hash, returning both pending and committed transactions.\n   *\n   * @param args - The arguments for querying the transaction.\n   * @param args.transactionHash - The transaction hash should be a hex-encoded bytes string with a 0x prefix.\n   * @returns The transaction from the mempool (pending) or the on-chain (committed) transaction.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetch a transaction by its hash\n   *   const transaction = await aptos.getTransactionByHash({ transactionHash: \"0x123\" }); // replace with a real transaction hash\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async getTransactionByHash(args: { transactionHash: HexInput }): Promise<TransactionResponse> {\n    return getTransactionByHash({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Defines if the specified transaction is currently in a pending state.\n   * This function helps you determine the status of a transaction using its hash.\n   *\n   * @param args - The arguments for the function.\n   * @param args.transactionHash - A hash of the transaction in hexadecimal format.\n   * @returns `true` if the transaction is in a pending state and `false` otherwise.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Check if the transaction is pending using its hash\n   *   const isPendingTransaction = await aptos.isPendingTransaction({ transactionHash: \"0x123\" }); // replace with a real transaction hash\n   *   console.log(\"Is the transaction pending?\", isPendingTransaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async isPendingTransaction(args: { transactionHash: HexInput }): Promise<boolean> {\n    return isTransactionPending({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Waits for a transaction to move past the pending state and provides the transaction response.\n   * There are 4 cases.\n   * 1. Transaction is successfully processed and committed to the chain.\n   *    - The function will resolve with the transaction response from the API.\n   * 2. Transaction is rejected for some reason, and is therefore not committed to the blockchain.\n   *    - The function will throw an AptosApiError with an HTTP status code indicating some problem with the request.\n   * 3. Transaction is committed but execution failed, meaning no changes were\n   *    written to the blockchain state.\n   *    - If `checkSuccess` is true, the function will throw a FailedTransactionError\n   *      If `checkSuccess` is false, the function will resolve with the transaction response where the `success` field is false.\n   * 4. Transaction does not move past the pending state within `args.options.timeoutSecs` seconds.\n   *    - The function will throw a WaitForTransactionError\n   *\n   * @param args.transactionHash - The hash of a transaction previously submitted to the blockchain.\n   * @param args.options - Optional parameters for waiting behavior.\n   * @param args.options.timeoutSecs - Timeout in seconds. Defaults to 20 seconds.\n   * @param args.options.checkSuccess - A boolean which controls whether the function will error if the transaction failed.\n   * Defaults to true.\n   * @returns The transaction on-chain response.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Wait for a transaction to complete using its hash\n   *   const transactionHash = \"0x123\"; // replace with a real transaction hash\n   *   const transactionResponse = await aptos.waitForTransaction({\n   *     transactionHash,\n   *     options: {\n   *       timeoutSecs: 30, // specify your own timeout if needed\n   *       checkSuccess: true,\n   *     },\n   *   });\n   *\n   *   console.log(transactionResponse);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async waitForTransaction(args: {\n    transactionHash: HexInput;\n    options?: WaitForTransactionOptions;\n  }): Promise<CommittedTransactionResponse> {\n    return waitForTransaction({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Estimates the gas unit price required to process a transaction on the Aptos blockchain in a timely manner.\n   * This helps users to understand the cost associated with their transactions.\n   * {@link https://api.mainnet.aptoslabs.com/v1/spec#/operations/estimate_gas_price}\n   *\n   * @returns An object containing the estimated gas price.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET }); // Specify your network\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Getting the gas price estimation\n   *   const gasPriceEstimation = await aptos.getGasPriceEstimation();\n   *\n   *   console.log(\"Estimated Gas Price:\", gasPriceEstimation);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async getGasPriceEstimation(): Promise<GasEstimation> {\n    return getGasPriceEstimation({\n      aptosConfig: this.config,\n    });\n  }\n\n  /**\n   * Returns a signing message for a transaction, allowing a user to sign it using their preferred method before submission to the network.\n   *\n   * @param args - The arguments for obtaining the signing message.\n   * @param args.transaction - A raw transaction for signing elsewhere.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *     const transaction = await aptos.transaction.build.simple({\n   *         sender: \"0x1\", // replace with a real sender address\n   *         data: {\n   *             function: \"0x1::aptos_account::transfer\",\n   *             functionArguments: [\"0x2\", 100], // replace with a real destination address\n   *         },\n   *     });\n   *\n   *     const message = await aptos.getSigningMessage({ transaction });\n   *     console.log(message);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  // eslint-disable-next-line class-methods-use-this\n  getSigningMessage(args: { transaction: AnyRawTransaction }): Uint8Array {\n    return getSigningMessage(args);\n  }\n\n  /**\n   * Generates a transaction to publish a Move package to the blockchain.\n   * This function helps you create a transaction that can be simulated or submitted to the chain for publishing a package.\n   *\n   * To get the `metadataBytes` and `byteCode`, can compile using Aptos CLI with command\n   * `aptos move compile --save-metadata ...`,\n   *\n   * {@link https://aptos.dev/tutorials/your-first-dapp/#step-4-publish-a-move-module}\n   *\n   * @param args The arguments for publishing the package.\n   * @param args.account The publisher account.\n   * @param args.metadataBytes The package metadata bytes.\n   * @param args.moduleBytecode An array of the bytecode of each module in the package in compiler output order.\n   * @param args.options Optional settings for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Replace with a real account address\n   *   const account = \"0x1\";\n   *   const metadataBytes = \"0x...\"; // replace with real metadata bytes\n   *   const byteCode = \"0x...\"; // replace with real module bytecode\n   *\n   *   const transaction = await aptos.publishPackageTransaction({\n   *     account,\n   *     metadataBytes,\n   *     moduleBytecode: [byteCode],\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async publishPackageTransaction(args: {\n    account: AccountAddressInput;\n    metadataBytes: HexInput;\n    moduleBytecode: Array<HexInput>;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return publicPackageTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Rotates the authentication key for a given account.  Once an account is rotated, only the new private key\n   * or keyless signing scheme can be used to sign transactions for the account.\n   *\n   * @param args - The arguments for rotating the authentication key.\n   * @param args.fromAccount - The account from which the authentication key will be rotated.\n   * @param args.toAccount - (Optional) The target account to rotate to. Required if not using toNewPrivateKey or toAuthKey.\n   * @param args.toNewPrivateKey - (Optional) The new private key to rotate to. Required if not using toAccount or toAuthKey.\n   * @param args.toAuthKey - (Optional) The new authentication key to rotate to. Can only be used with dangerouslySkipVerification=true.\n   * @param args.dangerouslySkipVerification - (Optional) If true, skips verification steps after rotation. Required when using toAuthKey.\n   *\n   * @remarks\n   * This function supports three modes of rotation:\n   * 1. Using a target Account object (toAccount)\n   * 2. Using a new private key (toNewPrivateKey)\n   * 3. Using a raw authentication key (toAuthKey) - requires dangerouslySkipVerification=true\n   *\n   * When not using dangerouslySkipVerification, the function performs additional safety checks and account setup.\n   *\n   * If the new key is a multi key, skipping verification is dangerous because verification will publish the public key onchain and\n   * prevent users from being locked out of the account from loss of knowledge of one of the public keys.\n   *\n   * @returns PendingTransactionResponse\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Account, PrivateKey } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Rotate the authentication key for an account\n   *   const response = await aptos.rotateAuthKey({\n   *     // replace with a real account\n   *     fromAccount: Account.generate(),\n   *     // replace with a real private key\n   *     toNewPrivateKey: new PrivateKey(\"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\"),\n   *   });\n   *\n   *   console.log(response);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async rotateAuthKey(\n    args: {\n      fromAccount: Account;\n    } & (\n      | { toAccount: Account; dangerouslySkipVerification?: never }\n      | { toNewPrivateKey: Ed25519PrivateKey; dangerouslySkipVerification?: never }\n      | { toAuthKey: AuthenticationKey; dangerouslySkipVerification: true }\n    ),\n  ): Promise<PendingTransactionResponse> {\n    return rotateAuthKey({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Sign a transaction that can later be submitted to the chain.\n   * This function is essential for ensuring the authenticity of the transaction by using the provided account's signing capabilities.\n   *\n   * @param args - The arguments for signing the transaction.\n   * @param args.signer - The account that will sign the transaction.\n   * @param args.transaction - A raw transaction to sign.\n   *\n   * @returns AccountAuthenticator - The authenticator for the signed transaction.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const sender = Account.generate(); // Generate a new account for signing\n   *   const transaction = await aptos.transaction.build.simple({\n   *     sender: sender.accountAddress,\n   *     data: {\n   *       function: \"0x1::aptos_account::transfer\",\n   *       functionArguments: [ \"0x1\", 100 ], // replace with a real account address and amount\n   *     },\n   *   });\n   *\n   *   const signedTransaction = await aptos.transaction.sign({\n   *     signer: sender,\n   *     transaction,\n   *   }); // Sign the transaction\n   *\n   *   console.log(\"Signed Transaction:\", signedTransaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  // eslint-disable-next-line class-methods-use-this\n  sign(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n    return signTransaction({\n      ...args,\n    });\n  }\n\n  /**\n   * Sign a transaction as a fee payer that can later be submitted to the chain.\n   * This function ensures that the transaction is marked with the fee payer's address, allowing it to be processed correctly.\n   *\n   * @param args - The arguments for signing the transaction.\n   * @param args.signer - The fee payer signer account.\n   * @param args.transaction - A raw transaction to sign on. This transaction must include a `feePayerAddress` property.\n   *\n   * @returns AccountAuthenticator - The authenticator for the signed transaction.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const sender = Account.generate(); // Generate a new account for the fee payer\n   *   const transaction = await aptos.transaction.build.simple({\n   *     // All transactions on Aptos are implemented via smart contracts.\n   *     function: \"0x1::aptos_account::transfer\",\n   *     functionArguments: [sender.accountAddress, 100],\n   *     feePayerAddress: sender.accountAddress, // Set the fee payer address\n   *   });\n   *\n   *   const signedTransaction = await aptos.transaction.signAsFeePayer({\n   *     signer: sender,\n   *     transaction,\n   *   });\n   *\n   *   console.log(\"Signed transaction as fee payer:\", signedTransaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  // eslint-disable-next-line class-methods-use-this\n  signAsFeePayer(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n    return signAsFeePayer({\n      ...args,\n    });\n  }\n\n  // TRANSACTION SUBMISSION //\n\n  /**\n   * @deprecated Prefer to use `aptos.transaction.batch.forSingleAccount()`\n   *\n   * Batch transactions for a single account by submitting multiple transaction payloads.\n   * This function is useful for efficiently processing and submitting transactions that do not depend on each other, such as\n   * batch funding or batch token minting.\n   *\n   * @param args - The arguments for batching transactions.\n   * @param args.sender - The sender account to sign and submit the transactions.\n   * @param args.data - An array of transaction payloads to be processed.\n   * @param args.options - Optional. Transaction generation configurations (excluding accountSequenceNumber).\n   *\n   * @throws Error if any worker failure occurs during submission.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Account } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   * const sender = Account.generate(); // Generate a new account for sending transactions\n   *\n   * async function runExample() {\n   *   const transactions = [\n   *     { }, // Build your first transaction payload\n   *     { }, // Build your second transaction payload\n   *   ];\n   *\n   *   // Batch transactions for the single account\n   *   await aptos.batchTransactionsForSingleAccount({\n   *     sender,\n   *     data: transactions,\n   *   });\n   *\n   *   console.log(\"Batch transactions submitted successfully.\");\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async batchTransactionsForSingleAccount(args: {\n    sender: Account;\n    data: InputGenerateTransactionPayloadData[];\n    options?: Omit<InputGenerateTransactionOptions, \"accountSequenceNumber\">;\n  }): Promise<void> {\n    try {\n      const { sender, data, options } = args;\n      this.batch.forSingleAccount({ sender, data, options });\n    } catch (error: any) {\n      throw new Error(`failed to submit transactions with error: ${error}`);\n    }\n  }\n\n  /**\n   * Sign and submit a single signer transaction to the blockchain.\n   * This function allows you to execute a transaction after signing it with the specified account.\n   *\n   * @param args The arguments for signing and submitting the transaction.\n   * @param args.signer The signer account to sign the transaction.\n   * @param args.transaction An instance of a RawTransaction, plus optional secondary/fee payer addresses.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const sender = Account.generate(); // Generate a new account for sending the transaction\n   *   const transaction = await aptos.transaction.build.simple({\n   *     sender: sender.accountAddress,\n   *     data: {\n   *       function: \"0x1::aptos_account::transfer\",\n   *       functionArguments: [ \"0x1\", 100 ], // replace with a real account address\n   *     },\n   *   });\n   *\n   *   // Sign and submit the transaction\n   *   const pendingTransaction = await aptos.signAndSubmitTransaction({\n   *     signer: sender,\n   *     transaction,\n   *   });\n   *\n   *   console.log(pendingTransaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @return PendingTransactionResponse\n   * @group Transaction\n   */\n  async signAndSubmitTransaction(\n    args: FeePayerOrFeePayerAuthenticatorOrNeither & {\n      signer: Account;\n      transaction: AnyRawTransaction;\n    },\n  ): Promise<PendingTransactionResponse> {\n    return signAndSubmitTransaction({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Sign and submit a single signer transaction as the fee payer to chain given an authenticator by the sender of the transaction.\n   *\n   * @param args.feePayer The fee payer account to sign the transaction\n   * @param args.senderAuthenticator The AccountAuthenticator signed by the sender of the transaction\n   * @param args.transaction An instance of a RawTransaction, plus optional secondary/fee payer addresses\n   *\n   * @example\n   * const transaction = await aptos.transaction.build.simple({sender: alice.accountAddress, feePayer: true ...})\n   * const senderAuthenticator = alice.signTransactionWithAuthenticator(transaction)\n   * const pendingTransaction = await aptos.signAndSubmitAsFeePayer({\n   *  senderAuthenticator,\n   *  feePayer: bob,\n   *  transaction,\n   * })\n   *\n   * @return PendingTransactionResponse\n   * @group Transaction\n   */\n  async signAndSubmitAsFeePayer(args: {\n    feePayer: Account;\n    senderAuthenticator: AccountAuthenticator;\n    transaction: AnyRawTransaction;\n  }): Promise<PendingTransactionResponse> {\n    return signAndSubmitAsFeePayer({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/keyless}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * keyless namespace and without having a dependency cycle error.\n * @group Implementation\n */\nimport { jwtDecode, JwtPayload } from \"jwt-decode\";\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { postAptosPepperService, postAptosProvingService } from \"../client\";\nimport {\n  AccountAddressInput,\n  EphemeralSignature,\n  Groth16Zkp,\n  Hex,\n  KeylessPublicKey,\n  MoveJWK,\n  ZeroKnowledgeSig,\n  ZkProof,\n  getKeylessConfig,\n} from \"../core\";\nimport { HexInput, ZkpVariant } from \"../types\";\nimport { Account, EphemeralKeyPair, KeylessAccount, ProofFetchCallback } from \"../account\";\nimport { PepperFetchRequest, PepperFetchResponse, ProverRequest, ProverResponse } from \"../types/keyless\";\nimport { lookupOriginalAccountAddress } from \"./account\";\nimport { FederatedKeylessPublicKey } from \"../core/crypto/federatedKeyless\";\nimport { FederatedKeylessAccount } from \"../account/FederatedKeylessAccount\";\nimport { MoveVector } from \"../bcs\";\nimport { generateTransaction } from \"./transactionSubmission\";\nimport { InputGenerateTransactionOptions, SimpleTransaction } from \"../transactions\";\nimport { KeylessError, KeylessErrorType } from \"../errors\";\nimport { FIREBASE_AUTH_ISS_PATTERN } from \"../utils/const\";\n\n/**\n * Retrieves a pepper value based on the provided configuration and authentication details.\n *\n * @param args - The arguments required to fetch the pepper.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.jwt - The JSON Web Token used for authentication.\n * @param args.ephemeralKeyPair - The ephemeral key pair used for the operation.\n * @param args.uidKey - An optional unique identifier key (defaults to \"sub\").\n * @param args.derivationPath - An optional derivation path for the key.\n * @returns A Uint8Array containing the fetched pepper value.\n * @group Implementation\n */\nexport async function getPepper(args: {\n  aptosConfig: AptosConfig;\n  jwt: string;\n  ephemeralKeyPair: EphemeralKeyPair;\n  uidKey?: string;\n  derivationPath?: string;\n}): Promise<Uint8Array> {\n  const { aptosConfig, jwt, ephemeralKeyPair, uidKey = \"sub\", derivationPath } = args;\n\n  const body = {\n    jwt_b64: jwt,\n    epk: ephemeralKeyPair.getPublicKey().bcsToHex().toStringWithoutPrefix(),\n    exp_date_secs: ephemeralKeyPair.expiryDateSecs,\n    epk_blinder: Hex.fromHexInput(ephemeralKeyPair.blinder).toStringWithoutPrefix(),\n    uid_key: uidKey,\n    derivation_path: derivationPath,\n  };\n  const { data } = await postAptosPepperService<PepperFetchRequest, PepperFetchResponse>({\n    aptosConfig,\n    path: \"fetch\",\n    body,\n    originMethod: \"getPepper\",\n    overrides: { WITH_CREDENTIALS: false },\n  });\n  return Hex.fromHexInput(data.pepper).toUint8Array();\n}\n\n/**\n * Generates a zero-knowledge proof based on the provided parameters.\n * This function is essential for creating a signed proof that can be used in various cryptographic operations.\n *\n * @param args - The parameters required to generate the proof.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.jwt - The JSON Web Token used for authentication.\n * @param args.ephemeralKeyPair - The ephemeral key pair used for generating the proof.\n * @param args.pepper - An optional hex input used to enhance security (default is generated if not provided).\n * @param args.uidKey - An optional string that specifies the unique identifier key (defaults to \"sub\").\n * @throws Error if the pepper length is not valid or if the ephemeral key pair's lifespan exceeds the maximum allowed.\n * @group Implementation\n */\nexport async function getProof(args: {\n  aptosConfig: AptosConfig;\n  jwt: string;\n  ephemeralKeyPair: EphemeralKeyPair;\n  pepper?: HexInput;\n  uidKey?: string;\n  maxExpHorizonSecs?: number;\n}): Promise<ZeroKnowledgeSig> {\n  const {\n    aptosConfig,\n    jwt,\n    ephemeralKeyPair,\n    pepper = await getPepper(args),\n    uidKey = \"sub\",\n    maxExpHorizonSecs = (await getKeylessConfig({ aptosConfig })).maxExpHorizonSecs,\n  } = args;\n  if (Hex.fromHexInput(pepper).toUint8Array().length !== KeylessAccount.PEPPER_LENGTH) {\n    throw new Error(`Pepper needs to be ${KeylessAccount.PEPPER_LENGTH} bytes`);\n  }\n  const decodedJwt = jwtDecode<JwtPayload>(jwt);\n  if (typeof decodedJwt.iat !== \"number\") {\n    throw new Error(\"iat was not found\");\n  }\n  if (maxExpHorizonSecs < ephemeralKeyPair.expiryDateSecs - decodedJwt.iat) {\n    throw Error(`The EphemeralKeyPair is too long lived.  It's lifespan must be less than ${maxExpHorizonSecs}`);\n  }\n  const json = {\n    jwt_b64: jwt,\n    epk: ephemeralKeyPair.getPublicKey().bcsToHex().toStringWithoutPrefix(),\n    epk_blinder: Hex.fromHexInput(ephemeralKeyPair.blinder).toStringWithoutPrefix(),\n    exp_date_secs: ephemeralKeyPair.expiryDateSecs,\n    exp_horizon_secs: maxExpHorizonSecs,\n    pepper: Hex.fromHexInput(pepper).toStringWithoutPrefix(),\n    uid_key: uidKey,\n  };\n\n  const { data } = await postAptosProvingService<ProverRequest, ProverResponse>({\n    aptosConfig,\n    path: \"prove\",\n    body: json,\n    originMethod: \"getProof\",\n    overrides: { WITH_CREDENTIALS: false },\n  });\n\n  const proofPoints = data.proof;\n  const groth16Zkp = new Groth16Zkp({\n    a: proofPoints.a,\n    b: proofPoints.b,\n    c: proofPoints.c,\n  });\n\n  const signedProof = new ZeroKnowledgeSig({\n    proof: new ZkProof(groth16Zkp, ZkpVariant.Groth16),\n    trainingWheelsSignature: EphemeralSignature.fromHex(data.training_wheels_signature),\n    expHorizonSecs: maxExpHorizonSecs,\n  });\n  return signedProof;\n}\n\n/**\n * Derives a keyless account by fetching the necessary proof and looking up the original account address.\n * This function helps in creating a keyless account that can be used without managing private keys directly.\n *\n * @param args - The arguments required to derive the keyless account.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.jwt - The JSON Web Token used for authentication.\n * @param args.ephemeralKeyPair - The ephemeral key pair used for cryptographic operations.\n * @param args.uidKey - An optional unique identifier key for the user.\n * @param args.pepper - An optional hexadecimal input used for additional security.\n * @param args.proofFetchCallback - An optional callback function to handle the proof fetch outcome.\n * @returns A keyless account object.\n * @group Implementation\n */\nexport async function deriveKeylessAccount(args: {\n  aptosConfig: AptosConfig;\n  jwt: string;\n  ephemeralKeyPair: EphemeralKeyPair;\n  uidKey?: string;\n  pepper?: HexInput;\n  proofFetchCallback?: ProofFetchCallback;\n}): Promise<KeylessAccount>;\n\nexport async function deriveKeylessAccount(args: {\n  aptosConfig: AptosConfig;\n  jwt: string;\n  ephemeralKeyPair: EphemeralKeyPair;\n  jwkAddress: AccountAddressInput;\n  uidKey?: string;\n  pepper?: HexInput;\n  proofFetchCallback?: ProofFetchCallback;\n}): Promise<FederatedKeylessAccount>;\n\nexport async function deriveKeylessAccount(args: {\n  aptosConfig: AptosConfig;\n  jwt: string;\n  ephemeralKeyPair: EphemeralKeyPair;\n  jwkAddress?: AccountAddressInput;\n  uidKey?: string;\n  pepper?: HexInput;\n  proofFetchCallback?: ProofFetchCallback;\n}): Promise<KeylessAccount | FederatedKeylessAccount> {\n  const { aptosConfig, jwt, jwkAddress, uidKey, proofFetchCallback, pepper = await getPepper(args) } = args;\n  const { verificationKey, maxExpHorizonSecs } = await getKeylessConfig({ aptosConfig });\n\n  const proofPromise = getProof({ ...args, pepper, maxExpHorizonSecs });\n  // If a callback is provided, pass in the proof as a promise to KeylessAccount.create.  This will make the proof be fetched in the\n  // background and the callback will handle the outcome of the fetch.  This allows the developer to not have to block on the proof fetch\n  // allowing for faster rendering of UX.\n  //\n  // If no callback is provided, the just await the proof fetch and continue synchronously.\n  const proof = proofFetchCallback ? proofPromise : await proofPromise;\n\n  // Look up the original address to handle key rotations and then instantiate the account.\n  if (jwkAddress !== undefined) {\n    const publicKey = FederatedKeylessPublicKey.fromJwtAndPepper({ jwt, pepper, jwkAddress, uidKey });\n    const address = await lookupOriginalAccountAddress({\n      aptosConfig,\n      authenticationKey: publicKey.authKey().derivedAddress(),\n    });\n\n    return FederatedKeylessAccount.create({\n      ...args,\n      address,\n      proof,\n      pepper,\n      proofFetchCallback,\n      jwkAddress,\n      verificationKey,\n    });\n  }\n\n  const publicKey = KeylessPublicKey.fromJwtAndPepper({ jwt, pepper, uidKey });\n  const address = await lookupOriginalAccountAddress({\n    aptosConfig,\n    authenticationKey: publicKey.authKey().derivedAddress(),\n  });\n  return KeylessAccount.create({ ...args, address, proof, pepper, proofFetchCallback, verificationKey });\n}\n\nexport interface JWKS {\n  keys: MoveJWK[];\n}\n\nexport async function updateFederatedKeylessJwkSetTransaction(args: {\n  aptosConfig: AptosConfig;\n  sender: Account;\n  iss: string;\n  jwksUrl?: string;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, sender, iss, options } = args;\n\n  let { jwksUrl } = args;\n\n  if (jwksUrl === undefined) {\n    if (FIREBASE_AUTH_ISS_PATTERN.test(iss)) {\n      jwksUrl = \"https://www.googleapis.com/service_accounts/v1/jwk/securetoken@system.gserviceaccount.com\";\n    } else {\n      jwksUrl = iss.endsWith(\"/\") ? `${iss}.well-known/jwks.json` : `${iss}/.well-known/jwks.json`;\n    }\n  }\n\n  let response: Response;\n\n  try {\n    response = await fetch(jwksUrl);\n    if (!response.ok) {\n      throw new Error(`${response.status} ${response.statusText}`);\n    }\n  } catch (error) {\n    let errorMessage: string;\n    if (error instanceof Error) {\n      errorMessage = `${error.message}`;\n    } else {\n      errorMessage = `error unknown - ${error}`;\n    }\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.JWK_FETCH_FAILED_FEDERATED,\n      details: `Failed to fetch JWKS at ${jwksUrl}: ${errorMessage}`,\n    });\n  }\n\n  const jwks: JWKS = await response.json();\n  return generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress,\n    data: {\n      function: \"0x1::jwks::update_federated_jwk_set\",\n      functionArguments: [\n        iss,\n        MoveVector.MoveString(jwks.keys.map((key) => key.kid)),\n        MoveVector.MoveString(jwks.keys.map((key) => key.alg)),\n        MoveVector.MoveString(jwks.keys.map((key) => key.e)),\n        MoveVector.MoveString(jwks.keys.map((key) => key.n)),\n      ],\n    },\n    options,\n  });\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Account, EphemeralKeyPair, KeylessAccount, ProofFetchCallback } from \"../account\";\nimport { FederatedKeylessAccount } from \"../account/FederatedKeylessAccount\";\nimport { AccountAddressInput, ZeroKnowledgeSig } from \"../core\";\nimport {\n  deriveKeylessAccount,\n  getPepper,\n  getProof,\n  updateFederatedKeylessJwkSetTransaction,\n} from \"../internal/keyless\";\nimport { InputGenerateTransactionOptions, SimpleTransaction } from \"../transactions\";\nimport { HexInput } from \"../types\";\nimport { AptosConfig } from \"./aptosConfig\";\n\n/**\n * A class to query all `Keyless` related queries on Aptos.\n *\n * More documentation on how to integrate Keyless Accounts see the below\n * [Aptos Keyless Integration Guide](https://aptos.dev/guides/keyless-accounts/#aptos-keyless-integration-guide).\n * @group Keyless\n */\nexport class Keyless {\n  /**\n   * Initializes a new instance of the Aptos class with the provided configuration.\n   * This allows you to interact with the Aptos blockchain using the specified network settings.\n   *\n   * @param config - The configuration settings for connecting to the Aptos network.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a new configuration for the Aptos client\n   *     const config = new AptosConfig({ network: Network.TESTNET }); // Specify your desired network\n   *\n   *     // Initialize the Aptos client with the configuration\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Keyless\n   */\n  constructor(readonly config: AptosConfig) {}\n\n  /**\n   * Fetches the pepper from the Aptos pepper service API.\n   *\n   * @param args - The arguments for fetching the pepper.\n   * @param args.jwt - JWT token.\n   * @param args.ephemeralKeyPair - The EphemeralKeyPair used to generate the nonce in the JWT token.\n   * @param args.derivationPath - A derivation path used for creating multiple accounts per user via the BIP-44 standard. Defaults\n   * to \"m/44'/637'/0'/0'/0\".\n   * @returns The pepper which is a Uint8Array of length 31.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const ephemeralKeyPair = new EphemeralKeyPair(); // create a new ephemeral key pair\n   *   const jwt = \"your_jwt_token\"; // replace with a real JWT token\n   *\n   *   // Fetching the pepper using the provided JWT and ephemeral key pair\n   *   const pepper = await aptos.getPepper({\n   *     jwt,\n   *     ephemeralKeyPair,\n   *     // derivationPath: \"m/44'/637'/0'/0'/0\" // specify your own if needed\n   *   });\n   *\n   *   console.log(\"Fetched pepper:\", pepper);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Keyless\n   */\n  async getPepper(args: {\n    jwt: string;\n    ephemeralKeyPair: EphemeralKeyPair;\n    derivationPath?: string;\n  }): Promise<Uint8Array> {\n    return getPepper({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Fetches a proof from the Aptos prover service API.\n   *\n   * @param args - The arguments for fetching the proof.\n   * @param args.jwt - JWT token.\n   * @param args.ephemeralKeyPair - The EphemeralKeyPair used to generate the nonce in the JWT token.\n   * @param args.pepper - The pepper used for the account. If not provided, it will be fetched from the Aptos pepper service.\n   * @param args.uidKey - A key in the JWT token to use to set the uidVal in the IdCommitment.\n   *\n   * @returns The proof which is represented by a ZeroKnowledgeSig.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, EphemeralKeyPair, getPepper } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const jwt = \"your_jwt_token\"; // replace with a real JWT token\n   *   const ephemeralKeyPair = new EphemeralKeyPair(); // create a new ephemeral key pair\n   *\n   *   // Fetch the proof using the getProof function\n   *   const proof = await aptos.getProof({\n   *     jwt,\n   *     ephemeralKeyPair,\n   *     pepper: await getPepper({}), // fetch the pepper if not provided\n   *     uidKey: \"sub\", // specify the uid key\n   *   });\n   *\n   *   console.log(\"Fetched proof:\", proof);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Keyless\n   */\n  async getProof(args: {\n    jwt: string;\n    ephemeralKeyPair: EphemeralKeyPair;\n    pepper?: HexInput;\n    uidKey?: string;\n  }): Promise<ZeroKnowledgeSig> {\n    return getProof({ aptosConfig: this.config, ...args });\n  }\n\n  async deriveKeylessAccount(args: {\n    jwt: string;\n    ephemeralKeyPair: EphemeralKeyPair;\n    uidKey?: string;\n    pepper?: HexInput;\n    proofFetchCallback?: ProofFetchCallback;\n  }): Promise<KeylessAccount>;\n\n  async deriveKeylessAccount(args: {\n    jwt: string;\n    ephemeralKeyPair: EphemeralKeyPair;\n    jwkAddress: AccountAddressInput;\n    uidKey?: string;\n    pepper?: HexInput;\n    proofFetchCallback?: ProofFetchCallback;\n  }): Promise<FederatedKeylessAccount>;\n\n  /**\n   * Derives a Keyless Account from the provided JWT token and corresponding EphemeralKeyPair. This function computes the proof\n   * via the proving service and can fetch the pepper from the pepper service if not explicitly provided.\n   *\n   * @param args - The arguments required to derive the Keyless Account.\n   * @param args.jwt - The JWT token used for deriving the account.\n   * @param args.ephemeralKeyPair - The EphemeralKeyPair used to generate the nonce in the JWT token.\n   * @param args.jwkAddress - The address the where the JWKs used to verify signatures are found.  Setting the value derives a\n   * FederatedKeylessAccount.\n   * @param args.uidKey - An optional key in the JWT token to set the uidVal in the IdCommitment.\n   * @param args.pepper - An optional pepper value.\n   * @param args.proofFetchCallback - An optional callback function for fetching the proof in the background, allowing for a more\n   * responsive user experience.\n   *\n   * @returns A KeylessAccount that can be used to sign transactions.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, deriveKeylessAccount } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const jwt = \"your_jwt_token\"; // replace with a real JWT token\n   *   const ephemeralKeyPair = new EphemeralKeyPair(); // create a new ephemeral key pair\n   *\n   *   // Deriving the Keyless Account\n   *   const keylessAccount = await deriveKeylessAccount({\n   *     jwt,\n   *     ephemeralKeyPair,\n   *     uidKey: \"your_uid_key\", // optional\n   *     pepper: \"your_pepper\", // optional\n   *   });\n   *\n   *   console.log(\"Keyless Account derived:\", keylessAccount);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Keyless\n   */\n  async deriveKeylessAccount(args: {\n    jwt: string;\n    ephemeralKeyPair: EphemeralKeyPair;\n    jwkAddress?: AccountAddressInput;\n    uidKey?: string;\n    pepper?: HexInput;\n    proofFetchCallback?: ProofFetchCallback;\n  }): Promise<KeylessAccount | FederatedKeylessAccount> {\n    return deriveKeylessAccount({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * This installs a set of FederatedJWKs at an address for a given iss.\n   *\n   * It will fetch the JSON Web Keyset (JWK) set from the well-known endpoint and update the FederatedJWKs at the sender's address\n   * to reflect it.\n   *\n   * @param args.sender The account that will install the JWKs\n   * @param args.iss the iss claim of the federated OIDC provider.\n   * @param args.jwksUrl the URL to find the corresponding JWKs. For supported IDP providers this parameter in not necessary.\n   *\n   * @returns The pending transaction that results from submission.\n   * @group Keyless\n   */\n  async updateFederatedKeylessJwkSetTransaction(args: {\n    sender: Account;\n    iss: string;\n    jwksUrl?: string;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return updateFederatedKeylessJwkSetTransaction({ aptosConfig: this.config, ...args });\n  }\n}\n","import { AptosConfig } from \"../api/aptosConfig\";\nimport { AccountAddressInput, AccountAddress } from \"../core\";\nimport { PaginationArgs, OrderByArg, GetObjectDataQueryResponse, WhereArg } from \"../types\";\nimport { GetObjectDataQuery } from \"../types/generated/operations\";\nimport { GetObjectData } from \"../types/generated/queries\";\nimport { CurrentObjectsBoolExp } from \"../types/generated/types\";\nimport { queryIndexer } from \"./general\";\n\n/**\n * Retrieves the current objects based on specified filtering and pagination options.\n *\n * @param args - The arguments for retrieving object data.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param [args.options] - Optional parameters for pagination and filtering.\n * @param [args.options.offset] - The number of items to skip before starting to collect the result set.\n * @param [args.options.limit] - The maximum number of items to return.\n * @param [args.options.orderBy] - The criteria for ordering the results.\n * @param [args.options.where] - The conditions to filter the results.\n * @returns The current objects that match the specified criteria.\n * @group Implementation\n */\nexport async function getObjectData(args: {\n  aptosConfig: AptosConfig;\n  options?: PaginationArgs & OrderByArg<GetObjectDataQueryResponse[0]> & WhereArg<CurrentObjectsBoolExp>;\n}): Promise<GetObjectDataQueryResponse> {\n  const { aptosConfig, options } = args;\n\n  const graphqlQuery = {\n    query: GetObjectData,\n    variables: {\n      where_condition: options?.where,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n  const data = await queryIndexer<GetObjectDataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getObjectData\",\n  });\n\n  return data.current_objects;\n}\n\n/**\n * Retrieves the object data associated with a specific object address.\n * This function allows you to access detailed information about an object in the Aptos blockchain.\n *\n * @param args - The arguments for retrieving object data.\n * @param args.aptosConfig - The configuration for connecting to the Aptos blockchain.\n * @param args.objectAddress - The address of the object whose data is being retrieved.\n * @param args.options - Optional parameters for pagination and ordering of the results.\n * @group Implementation\n */\nexport async function getObjectDataByObjectAddress(args: {\n  aptosConfig: AptosConfig;\n  objectAddress: AccountAddressInput;\n  options?: PaginationArgs & OrderByArg<GetObjectDataQueryResponse[0]>;\n}): Promise<GetObjectDataQueryResponse[0]> {\n  const { aptosConfig, objectAddress, options } = args;\n  const address = AccountAddress.from(objectAddress).toStringLong();\n\n  const whereCondition: { object_address: { _eq: string } } = {\n    object_address: { _eq: address },\n  };\n  return (await getObjectData({ aptosConfig, options: { ...options, where: whereCondition } }))[0];\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AnyNumber, GetObjectDataQueryResponse, OrderByArg, PaginationArgs } from \"../types\";\nimport { AccountAddressInput } from \"../core\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { ProcessorType } from \"../utils\";\nimport { waitForIndexerOnVersion } from \"./utils\";\nimport { getObjectDataByObjectAddress } from \"../internal/object\";\n\n/**\n * A class to query all `Object` related queries on Aptos.\n * @group Object\n */\nexport class AptosObject {\n  /**\n   * Creates an instance of the Aptos client with the provided configuration.\n   * This allows interaction with the Aptos blockchain using the specified settings.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   * @param config.network - The network to connect to (e.g., mainnet, testnet).\n   * @param config.nodeUrl - The URL of the Aptos node to connect to.\n   * @param config.faucetUrl - The URL of the faucet for funding accounts (optional).\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a configuration for the Aptos client\n   *     const config = new AptosConfig({\n   *         network: Network.TESTNET, // Specify the desired network\n   *         nodeUrl: \"https://testnet.aptos.dev\", // Replace with your node URL\n   *     });\n   *\n   *     // Create an instance of the Aptos client\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client created successfully\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Object\n   */\n  constructor(readonly config: AptosConfig) {}\n\n  /**\n   * Fetches the object data based on the specified object address.\n   *\n   * @param args.objectAddress - The object address to retrieve data for.\n   * @param args.minimumLedgerVersion - Optional minimum ledger version to wait for.\n   * @param args.options - Optional configuration options for pagination and ordering.\n   *\n   * @returns The object data corresponding to the provided address.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching object data by object address\n   *   const objectData = await aptos.getObjectDataByObjectAddress({\n   *     objectAddress: \"0x1\", // replace with a real object address\n   *   });\n   *\n   *   console.log(objectData);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Object\n   */\n  async getObjectDataByObjectAddress(args: {\n    objectAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & OrderByArg<GetObjectDataQueryResponse[0]>;\n  }): Promise<GetObjectDataQueryResponse[0]> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.OBJECT_PROCESSOR,\n    });\n    return getObjectDataByObjectAddress({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n}\n","// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Account } from \"./account\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { Coin } from \"./coin\";\nimport { DigitalAsset } from \"./digitalAsset\";\nimport { Event } from \"./event\";\nimport { Faucet } from \"./faucet\";\nimport { FungibleAsset } from \"./fungibleAsset\";\nimport { General } from \"./general\";\nimport { ANS } from \"./ans\";\nimport { Staking } from \"./staking\";\nimport { Transaction } from \"./transaction\";\nimport { Table } from \"./table\";\nimport { Keyless } from \"./keyless\";\nimport { AptosObject } from \"./object\";\nimport { AccountAbstraction } from \"./account/abstraction\";\n\n/**\n * The main entry point for interacting with the Aptos APIs,\n * providing access to various functionalities organized into\n * distinct namespaces.\n *\n * To utilize the SDK, instantiate a new Aptos object to gain\n * access to the complete range of SDK features.\n *\n * @example\n * ```typescript\n * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n *\n * async function runExample() {\n *     // Create a configuration for connecting to the Aptos testnet\n *     const config = new AptosConfig({ network: Network.TESTNET });\n *\n *     // Initialize the Aptos client with the configuration\n *     const aptos = new Aptos(config);\n *\n *     console.log(\"Aptos client initialized:\", aptos);\n * }\n * runExample().catch(console.error);\n * ```\n * @group Client\n */\nexport class Aptos {\n  readonly config: AptosConfig;\n\n  readonly account: Account;\n\n  readonly ans: ANS;\n\n  readonly coin: Coin;\n\n  readonly digitalAsset: DigitalAsset;\n\n  readonly event: Event;\n\n  readonly faucet: Faucet;\n\n  readonly fungibleAsset: FungibleAsset;\n\n  readonly general: General;\n\n  readonly staking: Staking;\n\n  readonly transaction: Transaction;\n\n  readonly table: Table;\n\n  readonly keyless: Keyless;\n\n  readonly object: AptosObject;\n\n  /**\n   * Initializes a new instance of the Aptos client with the provided configuration settings.\n   * This allows you to interact with various Aptos functionalities such as accounts, transactions, and events.\n   *\n   * @param settings - Configuration settings for the Aptos client.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a new Aptos client with default settings\n   *     const config = new AptosConfig({ network: Network.TESTNET }); // Specify your own settings if needed\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Client\n   */\n  constructor(settings?: AptosConfig) {\n    this.config = new AptosConfig(settings);\n    this.account = new Account(this.config);\n    this.abstraction = new AccountAbstraction(this.config);\n    this.ans = new ANS(this.config);\n    this.coin = new Coin(this.config);\n    this.digitalAsset = new DigitalAsset(this.config);\n    this.event = new Event(this.config);\n    this.faucet = new Faucet(this.config);\n    this.fungibleAsset = new FungibleAsset(this.config);\n    this.general = new General(this.config);\n    this.staking = new Staking(this.config);\n    this.transaction = new Transaction(this.config);\n    this.table = new Table(this.config);\n    this.keyless = new Keyless(this.config);\n    this.object = new AptosObject(this.config);\n  }\n}\n\n// extends Aptos interface so all the methods and properties\n// from the other classes will be recognized by typescript.\nexport interface Aptos\n  extends Account,\n    ANS,\n    Coin,\n    DigitalAsset,\n    Event,\n    Faucet,\n    FungibleAsset,\n    General,\n    Keyless,\n    Staking,\n    Table,\n    AptosObject,\n    Omit<Transaction, \"build\" | \"simulate\" | \"submit\" | \"batch\"> {}\n\n/**\nIn TypeScript, we canât inherit or extend from more than one class,\nMixins helps us to get around that by creating a partial classes\nthat we can combine to form a single class that contains all the methods and properties from the partial classes.\n{@link https://www.typescriptlang.org/docs/handbook/mixins.html#alternative-pattern}\n\nHere, we combine any subclass and the Aptos class.\n * @group Client\n*/\nfunction applyMixin(targetClass: any, baseClass: any, baseClassProp: string) {\n  // Mixin instance methods\n  Object.getOwnPropertyNames(baseClass.prototype).forEach((propertyName) => {\n    const propertyDescriptor = Object.getOwnPropertyDescriptor(baseClass.prototype, propertyName);\n    if (!propertyDescriptor) return;\n    // eslint-disable-next-line func-names\n    propertyDescriptor.value = function (...args: any) {\n      return (this as any)[baseClassProp][propertyName](...args);\n    };\n    Object.defineProperty(targetClass.prototype, propertyName, propertyDescriptor);\n  });\n}\n\napplyMixin(Aptos, Account, \"account\");\napplyMixin(Aptos, AccountAbstraction, \"abstraction\");\napplyMixin(Aptos, ANS, \"ans\");\napplyMixin(Aptos, Coin, \"coin\");\napplyMixin(Aptos, DigitalAsset, \"digitalAsset\");\napplyMixin(Aptos, Event, \"event\");\napplyMixin(Aptos, Faucet, \"faucet\");\napplyMixin(Aptos, FungibleAsset, \"fungibleAsset\");\napplyMixin(Aptos, General, \"general\");\napplyMixin(Aptos, Staking, \"staking\");\napplyMixin(Aptos, Transaction, \"transaction\");\napplyMixin(Aptos, Table, \"table\");\napplyMixin(Aptos, Keyless, \"keyless\");\napplyMixin(Aptos, AptosObject, \"object\");\n"],"mappings":"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","names":["jwtDecode","sha3_256","bn254","bytesToNumberBE","FederatedKeylessPublicKey","_FederatedKeylessPublicKey","AccountPublicKey","jwkAddress","keylessPublicKey","AccountAddress","serializer","Serializer","AuthenticationKey","args","verifyKeylessSignatureWithJwkAndConfig","deserializer","KeylessPublicKey","publicKey","verifyKeylessSignature","encode","AnyPublicKey","_AnyPublicKey","AccountPublicKey","publicKey","Ed25519PublicKey","Secp256k1PublicKey","KeylessPublicKey","FederatedKeylessPublicKey","args","message","signature","AnySignature","AuthenticationKey","serializer","deserializer","variantIndex","_AnySignature","Signature","Ed25519Signature","Secp256k1Signature","KeylessSignature","bitCount","byte","n","AbstractMultiKey","AccountPublicKey","args","bits","firstBitInByte","bitmap","dupCheckSet","bit","idx","byteOffset","publicKey","index","pk","MultiKey","_MultiKey","publicKeys","signaturesRequired","AnyPublicKey","message","signature","signerIndices","i","singleSignature","MultiKeySignature","error","AuthenticationKey","serializer","deserializer","keys","anyPublicKey","value","_MultiKeySignature","Signature","signatures","AnySignature","nSignatures","acc","_MultiEd25519PublicKey","AbstractMultiKey","args","publicKeys","threshold","message","signature","MultiEd25519Signature","indices","i","j","index","AuthenticationKey","bytes","Ed25519PublicKey","k","serializer","deserializer","keys","begin","publicKey","MultiEd25519PublicKey","_MultiEd25519Signature","Signature","signatures","bitmap","Ed25519Signature","bits","firstBitInByte","dupCheckSet","bit","byteOffset","byte","AccountAuthenticator","Serializable","deserializer","index","AccountAuthenticatorEd25519","AccountAuthenticatorMultiEd25519","AccountAuthenticatorSingleKey","AccountAuthenticatorMultiKey","AccountAuthenticatorNoAccountAuthenticator","AccountAuthenticatorAbstraction","_AccountAuthenticatorEd25519","public_key","signature","serializer","Ed25519PublicKey","Ed25519Signature","_AccountAuthenticatorMultiEd25519","MultiEd25519PublicKey","MultiEd25519Signature","_AccountAuthenticatorSingleKey","AnyPublicKey","AnySignature","_AccountAuthenticatorMultiKey","public_keys","signatures","MultiKey","MultiKeySignature","_AccountAuthenticatorNoAccountAuthenticator","_AccountAuthenticatorAbstraction","functionInfo","signingMessageDigest","authenticator","accountIdentity","isValidFunctionInfo","Hex","moduleAddress","moduleName","functionName","getFunctionParts","AccountAddress","variant","abstractSignature","abstractPublicKey","sha3Hash","ModuleId","_ModuleId","Serializable","address","name","moduleId","parts","AccountAddress","Identifier","serializer","deserializer","TypeTag","_TypeTag","Serializable","deserializer","address","AccountAddress","moduleName","Identifier","name","typeArgs","StructTag","index","TypeTagBool","TypeTagU8","TypeTagU64","TypeTagU128","TypeTagAddress","TypeTagSigner","TypeTagVector","TypeTagStruct","TypeTagU16","TypeTagU32","TypeTagU256","TypeTagGeneric","_TypeTagBool","serializer","_deserializer","_TypeTagU8","_TypeTagU16","_TypeTagU32","_TypeTagU64","_TypeTagU128","_TypeTagU256","_TypeTagAddress","_TypeTagSigner","TypeTagReference","_TypeTagReference","value","_TypeTagGeneric","_TypeTagVector","_TypeTagStruct","typePredicate","typeArg","structName","_StructTag","module_name","type_args","aptosCoinStructTag","stringStructTag","optionStructTag","objectStructTag","deserializeFromScriptArgument","deserializer","index","U8","U64","U128","AccountAddress","MoveVector","Bool","U16","U32","U256","Serialized","TransactionPayload","Serializable","TransactionPayloadScript","TransactionPayloadEntryFunction","TransactionPayloadMultiSig","_TransactionPayloadScript","script","serializer","Script","_TransactionPayloadEntryFunction","entryFunction","EntryFunction","_TransactionPayloadMultiSig","multiSig","value","MultiSig","_EntryFunction","module_name","function_name","type_args","args","module_id","ModuleId","Identifier","item","TypeTag","length","i","fixedBytesLength","fixedBytes","EntryFunctionBytes","_Script","bytecode","scriptArgument","_MultiSig","multisig_address","transaction_payload","payloadPresent","MultiSigTransactionPayload","_MultiSigTransactionPayload","RawTransaction","_RawTransaction","Serializable","sender","sequence_number","payload","max_gas_amount","gas_unit_price","expiration_timestamp_secs","chain_id","serializer","deserializer","AccountAddress","TransactionPayload","ChainId","RawTransactionWithData","index","MultiAgentRawTransaction","FeePayerRawTransaction","_MultiAgentRawTransaction","raw_txn","secondary_signer_addresses","rawTxn","secondarySignerAddresses","_FeePayerRawTransaction","fee_payer_address","feePayerAddress","TransactionAuthenticator","Serializable","deserializer","index","TransactionAuthenticatorEd25519","TransactionAuthenticatorMultiEd25519","TransactionAuthenticatorMultiAgent","TransactionAuthenticatorFeePayer","TransactionAuthenticatorSingleSender","_TransactionAuthenticatorEd25519","public_key","signature","serializer","Ed25519PublicKey","Ed25519Signature","_TransactionAuthenticatorMultiEd25519","MultiEd25519PublicKey","MultiEd25519Signature","_TransactionAuthenticatorMultiAgent","sender","secondary_signer_addresses","secondary_signers","AccountAuthenticator","AccountAddress","_TransactionAuthenticatorFeePayer","fee_payer","address","authenticator","_TransactionAuthenticatorSingleSender","SignedTransaction","_SignedTransaction","Serializable","raw_txn","authenticator","serializer","deserializer","RawTransaction","TransactionAuthenticator","SimpleTransaction","_SimpleTransaction","Serializable","rawTransaction","feePayerAddress","serializer","deserializer","RawTransaction","feePayerPresent","AccountAddress","MultiAgentTransaction","_MultiAgentTransaction","Serializable","rawTransaction","secondarySignerAddresses","feePayerAddress","serializer","deserializer","RawTransaction","AccountAddress","feePayerPresent","deriveTransactionType","transaction","FeePayerRawTransaction","MultiAgentRawTransaction","generateSigningMessage","bytes","domainSeparator","hash","sha3Hash","prefix","body","mergedArray","generateSigningMessageForSerializable","serializable","generateSigningMessageForTransaction","rawTxn","RAW_TRANSACTION_WITH_DATA_SALT","RAW_TRANSACTION_SALT","Ed25519Account","_Ed25519Account","args","privateKey","address","AccountAddress","Ed25519PrivateKey","path","mnemonic","message","AccountAuthenticatorEd25519","transaction","generateSigningMessageForTransaction","isSingleKeySigner","obj","SingleKeyAccount","_SingleKeyAccount","args","privateKey","address","AnyPublicKey","AccountAddress","scheme","Ed25519PrivateKey","Secp256k1PrivateKey","path","mnemonic","message","AccountAuthenticatorSingleKey","transaction","AnySignature","generateSigningMessageForTransaction","account","Account","args","scheme","legacy","Ed25519Account","SingleKeyAccount","privateKey","address","Ed25519PrivateKey","mnemonic","path","publicKey","randomBytes","TWO_WEEKS_IN_SECONDS","_EphemeralKeyPair","Serializable","args","privateKey","expiryDateSecs","blinder","EphemeralPublicKey","floorToWholeHour","nowInSeconds","Hex","generateBlinder","fields","padAndPackBytesWithLen","bytesToBigIntLE","nonceHash","poseidonHash","serializer","deserializer","variantIndex","Ed25519PrivateKey","bytes","Deserializer","data","EphemeralSignature","EphemeralKeyPair","randomBytes","EventEmitter","jwtDecode","isKeylessSigner","obj","_AbstractKeylessAccount","Serializable","args","address","ephemeralKeyPair","publicKey","uidKey","uidVal","aud","pepper","proof","proofFetchCallback","jwt","verificationKeyHash","AccountAddress","EventEmitter","ZeroKnowledgeSig","status","pepperBytes","Hex","AnyPublicKey","promise","error","serializer","deserializer","EphemeralKeyPair","message","signature","AnySignature","AccountAuthenticatorSingleKey","transaction","aptosConfig","KeylessError","header","jwtDecode","verificationKey","getKeylessConfig","expiryDateSecs","ephemeralPublicKey","ephemeralSignature","KeylessSignature","base64UrlDecode","EphemeralCertificate","raw","deriveTransactionType","signMess","TransactionAndProof","fetchJWK","AbstractKeylessAccount","generateSigningMessage","KeylessAccount","_KeylessAccount","AbstractKeylessAccount","args","publicKey","KeylessPublicKey","serializer","deserializer","address","proof","ephemeralKeyPair","jwt","uidKey","pepper","verificationKeyHash","iss","aud","uidVal","getIssAudAndUidVal","bytes","Deserializer","Hex","proofFetchCallback","verificationKey","FederatedKeylessAccount","_FederatedKeylessAccount","AbstractKeylessAccount","args","publicKey","FederatedKeylessPublicKey","serializer","deserializer","address","proof","ephemeralKeyPair","jwt","uidKey","pepper","verificationKeyHash","jwkAddress","AccountAddress","iss","aud","uidVal","getIssAudAndUidVal","bytes","Deserializer","proofFetchCallback","verificationKey","MultiKeyAccount","_MultiKeyAccount","args","multiKey","address","signers","signer","Ed25519Account","SingleKeyAccount","AccountAddress","bitPositions","signersAndBitPosition","index","b","value","publicKeys","signaturesRequired","MultiKey","account","message","AccountAuthenticatorMultiKey","transaction","promises","AbstractKeylessAccount","aptosConfig","data","signatures","MultiKeySignature","MultiEd25519Account","args","signers","publicKey","address","AccountAddress","bitPositions","signer","signersAndBitPosition","index","b","value","message","AccountAuthenticatorMultiEd25519","transaction","signatures","MultiEd25519Signature","generateSigningMessageForTransaction","deserializeSchemeAndAddress","deserializer","signingScheme","SigningScheme","AccountAddress","serializeKeylessAccountCommon","account","serializer","deserializeKeylessAccountCommon","deserializer","jwt","uidKey","pepper","ephemeralKeyPair","EphemeralKeyPair","proof","ZeroKnowledgeSig","verificationKeyHash","AccountUtils","toBytes","Serializer","isSingleKeySigner","anyPublicKey","federatedKeylessAccount","multiKeyAccount","signer","toHexStringWithoutPrefix","Hex","toHexString","deserialize","address","signingScheme","deserializeSchemeAndAddress","privateKey","Ed25519PrivateKey","Ed25519Account","variantIndex","SingleKeyAccount","Secp256k1PrivateKey","keylessComponents","jwtClaims","getIssAudAndUidVal","KeylessAccount","jwkAddress","AccountAddress","audless","FederatedKeylessAccount","multiKey","MultiKey","length","signers","i","MultiKeyAccount","keylessAccountFromHex","hex","fromHex","federatedKeylessAccountFromHex","multiKeyAccountFromHex","singleKeyAccountFromHex","ed25519AccountFromHex","Deserializer","fromBytes","bytes","sha3_256","AbstractedAccount","_AbstractedAccount","Account","signer","accountAddress","authenticationFunction","isValidFunctionInfo","AbstractPublicKey","digest","AbstractSignature","serializer","Serializer","message","AccountAuthenticatorAbstraction","sha3_256","transaction","generateSigningMessageForTransaction","sha3_256","_DerivableAbstractedAccount","AbstractedAccount","signer","authenticationFunction","abstractPublicKey","daaAccountAddress","AccountAddress","functionInfo","accountIdentifier","isValidFunctionInfo","moduleAddress","moduleName","functionName","hash","sha3_256","serializer","Serializer","s2","message","AccountAuthenticatorAbstraction","DerivableAbstractedAccount","sha3Hash","isValidIdentifier","str","isValidWhitespaceCharacter","char","isGeneric","isRef","isPrimitive","consumeWhitespace","tagStr","pos","i","innerChar","TypeTagParserErrorType","TypeTagParserError","typeTagStr","invalidReason","parseTypeTag","typeStr","options","allowGenerics","saved","innerTypes","curTypes","cur","currentStr","expectedTypes","newType","parseTypeTagInner","savedPop","savedStr","savedTypes","savedExpectedTypes","parsedTypeTag","nextChar","types","trimmedStr","lowerCaseTrimmed","TypeTagSigner","TypeTagBool","TypeTagAddress","TypeTagU8","TypeTagU16","TypeTagU32","TypeTagU64","TypeTagU128","TypeTagU256","TypeTagVector","actualType","TypeTagReference","TypeTagGeneric","structParts","address","AccountAddress","TypeTagStruct","StructTag","Identifier","isBool","arg","isString","isNumber","convertNumber","isLargeNumber","isEmptyOption","isEncodedEntryFunctionArgument","isBcsBool","isBcsU8","isBcsU16","isBcsU32","isBcsU64","isBcsU128","isBcsU256","isBcsAddress","isBcsString","isBcsFixedBytes","MoveVector","MoveOption","Bool","AccountAddress","MoveString","FixedBytes","U8","U16","U32","U64","U128","U256","isScriptDataInput","throwTypeMismatch","expectedType","position","findFirstNonSignerArg","functionAbi","index","param","TEXT_ENCODER","standardizeTypeTags","typeArguments","typeArg","isString","parseTypeTag","fetchModuleAbi","moduleAddress","moduleName","aptosConfig","getModule","fetchFunctionAbi","functionName","moduleAbi","func","fetchMoveFunctionAbi","functionAbi","params","i","fetchEntryFunctionAbi","numSigners","findFirstNonSignerArg","fetchViewFunctionAbi","returnTypes","convertCallArgument","argument","position","genericTypeParams","CallArgument","convertArgument","functionAbiOrModuleAbi","arg","options","param","checkOrConvertArgument","isEncodedEntryFunctionArgument","checkType","parseArg","isBool","Bool","throwTypeMismatch","AccountAddress","num","convertNumber","U8","U16","U32","isLargeNumber","U64","U128","U256","genericIndex","MoveVector","item","MoveString","FixedBytes","isEmptyOption","innerParam","TypeTagBool","MoveOption","TypeTagAddress","TypeTagU8","TypeTagU16","TypeTagU32","TypeTagU64","TypeTagU128","TypeTagU256","s","isBcsBool","isBcsAddress","isBcsU8","isBcsU16","isBcsU32","isBcsU64","isBcsU128","isBcsU256","TypeTagStruct","isBcsString","generateTransactionPayload","args","isScriptDataInput","generateTransactionPayloadScript","moduleAddress","moduleName","functionName","getFunctionParts","functionAbi","fetchAbi","fetchEntryFunctionAbi","generateTransactionPayloadWithABI","typeArguments","standardizeTypeTags","functionArguments","arg","i","convertArgument","entryFunctionPayload","EntryFunction","multisigAddress","AccountAddress","TransactionPayloadMultiSig","MultiSig","MultiSigTransactionPayload","TransactionPayloadEntryFunction","generateViewFunctionPayload","fetchViewFunctionAbi","generateViewFunctionPayloadWithABI","TransactionPayloadScript","Script","Hex","generateRawTransaction","aptosConfig","sender","payload","options","feePayerAddress","getChainId","NetworkToChainId","getLedgerInfo","getGasUnitPrice","getGasPriceEstimation","getSequenceNumberForAny","getSequenceNumber","getInfo","chainId","gasEstimate","sequenceNumber","maxGasAmount","gasUnitPrice","expireTimestamp","RawTransaction","ChainId","buildTransaction","rawTxn","signers","signer","MultiAgentTransaction","SimpleTransaction","generateSignedTransactionForSimulation","signerPublicKey","transaction","secondarySignersPublicKeys","feePayerPublicKey","accountAuthenticator","getAuthenticatorForSimulation","transactionToSign","FeePayerRawTransaction","secondaryAccountAuthenticators","publicKey","feePayerAuthenticator","transactionAuthenticator","TransactionAuthenticatorFeePayer","SignedTransaction","MultiAgentRawTransaction","TransactionAuthenticatorMultiAgent","AccountAuthenticatorEd25519","TransactionAuthenticatorEd25519","AccountAuthenticatorSingleKey","AccountAuthenticatorMultiKey","TransactionAuthenticatorSingleSender","AccountAuthenticatorNoAccountAuthenticator","accountPublicKey","KeylessPublicKey","FederatedKeylessPublicKey","Secp256k1PublicKey","AnyPublicKey","invalidSignature","Ed25519Signature","Ed25519PublicKey","AnySignature","KeylessSignature","MultiKey","MultiKeySignature","pubKey","_","generateSignedTransaction","additionalSignersAuthenticators","senderAuthenticator","normalizeBundle","AccountAuthenticator","txnAuthenticator","AccountAuthenticatorMultiEd25519","TransactionAuthenticatorMultiEd25519","hashValues","input","hash","sha3Hash","item","TRANSACTION_PREFIX","generateUserTransactionHash","signedTransaction","key","abi","fetch","memoizeAsync","ScriptComposerWasm","AptosScriptComposer","_AptosScriptComposer","aptosConfig","module","TransactionComposer","initSync","ScriptComposerWasm","input","moduleAddress","moduleName","functionName","getFunctionParts","nodeUrl","typeArgument","typeArguments","standardizeTypeTags","moduleAbi","fetchModuleAbi","functionAbi","func","functionArguments","arg","i","CallArgument","convertArgument","generateTransaction","args","payload","buildTransactionPayload","buildRawTransaction","aptosConfig","data","generateTransactionPayloadData","generateTransactionPayload","sender","options","feePayerAddress","isFeePayerTransactionInput","AccountAddress","isMultiAgentTransactionInput","secondarySignerAddresses","buildTransaction","getSigningMessage","transaction","generateSigningMessageForTransaction","signTransaction","signer","signAsFeePayer","simulateTransaction","signerPublicKey","secondarySignersPublicKeys","feePayerPublicKey","signedTransaction","generateSignedTransactionForSimulation","postAptosFullNode","submitTransaction","generateSignedTransaction","e","signedTxn","SignedTransaction","Deserializer","KeylessPublicKey","FederatedKeylessPublicKey","AbstractKeylessAccount","signAndSubmitTransaction","feePayer","isKeylessSigner","feePayerAuthenticator","senderAuthenticator","signAndSubmitAsFeePayer","packagePublishAbi","TypeTagVector","publicPackageTransaction","account","metadataBytes","moduleBytecode","totalByteCode","bytecode","MoveVector","getInfo","args","getModules","aptosConfig","accountAddress","options","paginateWithObfuscatedCursor","AccountAddress","getModulesPage","response","cursor","getPageWithObfuscatedCursor","getModule","getTransactions","paginateWithCursor","getResources","getResourcesPage","getResource","resourceType","data","getAptosFullNode","lookupOriginalAccountAddress","authenticationKey","resource","handle","authKeyAddress","originalAddress","getTableItem","err","AptosApiError","getAccountTokensCount","whereCondition","queryIndexer","GetAccountTokensCount","getAccountOwnedTokens","graphqlQuery","GetAccountOwnedTokens","getAccountOwnedTokensFromCollectionAddress","collectionAddress","ownerAddress","collAddress","GetAccountOwnedTokensFromCollection","getAccountCollectionsWithOwnedTokens","GetAccountCollectionsWithOwnedTokens","getAccountTransactionsCount","address","GetAccountTransactionsCount","getAccountCoinAmount","coinType","faMetadataAddress","coinAssetType","faAddress","APTOS_COIN","createObjectAddress","addr","where","getAccountCoinsData","GetAccountCoinsData","getAccountCoinsCount","GetAccountCoinsCount","getAccountOwnedObjects","GetObjectData","deriveAccountFromPrivateKey","privateKey","publicKey","AnyPublicKey","Secp256k1PrivateKey","AuthenticationKey","Account","Ed25519PrivateKey","legacyAuthKey","isAccountExist","singleSenderTransactionAuthenticatorAuthKey","authKey","error","rotateAuthKeyAbi","TypeTagU8","TypeTagVector","rotateAuthKey","fromAccount","dangerouslySkipVerification","rotateAuthKeyWithChallenge","Ed25519Account","MultiEd25519Account","pendingTxn","rotateAuthKeyUnverified","rotateAuthKeyTxnResponse","waitForTransaction","verificationTxn","generateTransaction","signAndSubmitTransaction","accountInfo","newAccount","challengeHex","RotationProofChallenge","proofSignedByCurrentKey","proofSignedByNewKey","rawTxn","U8","MoveVector","rotateAuthKeyUnverifiedAbi","toAuthKey","view","args","aptosConfig","payload","options","viewFunctionPayload","generateViewFunctionPayload","serializer","Serializer","bytes","data","postAptosFullNode","viewJson","addAuthenticationFunctionTransaction","args","aptosConfig","sender","authenticationFunction","options","moduleAddress","moduleName","functionName","getFunctionParts","generateTransaction","TypeTagAddress","TypeTagStruct","stringStructTag","removeAuthenticationFunctionTransaction","removeDispatchableAuthenticatorTransaction","AccountAbstraction","config","args","functionInfos","moduleAddress","moduleName","functionName","getFunctionParts","functionInfo","AccountAddress","accountAddress","authenticationFunction","options","addAuthenticationFunctionTransaction","removeAuthenticationFunctionTransaction","removeDispatchableAuthenticatorTransaction","functionInfoOption","view","TypeTagAddress","Account","config","AccountAbstraction","args","getInfo","getModules","getModulesPage","getModule","getTransactions","getResources","getResourcesPage","getResource","lookupOriginalAccountAddress","waitForIndexerOnVersion","getAccountTokensCount","getAccountOwnedTokens","getAccountOwnedTokensFromCollectionAddress","getAccountCollectionsWithOwnedTokens","getAccountTransactionsCount","getAccountCoinsData","getAccountCoinsCount","APTOS_COIN","APTOS_FA","accountAddress","coinType","faMetadataAddress","minimumLedgerVersion","coinAssetType","memoizeAsync","pairedCoinTypeStruct","view","isEncodedStruct","parseEncodedStruct","faAddress","AccountAddress","createObjectAddress","addr","balanceStr","getAccountOwnedObjects","deriveAccountFromPrivateKey","coinTransferAbi","TypeTagAddress","TypeTagU64","transferCoinTransaction","args","aptosConfig","sender","recipient","amount","coinType","options","generateTransaction","APTOS_COIN","Coin","config","args","transferCoinTransaction","PropertyTypeMap","defaultDigitalAssetType","getDigitalAssetData","args","aptosConfig","digitalAssetAddress","whereCondition","AccountAddress","queryIndexer","GetTokenData","getCurrentDigitalAssetOwnership","GetCurrentTokenOwnership","getOwnedDigitalAssets","ownerAddress","options","graphqlQuery","getDigitalAssetActivity","GetTokenActivity","createCollectionAbi","TypeTagStruct","stringStructTag","TypeTagU64","TypeTagBool","createCollectionTransaction","creator","generateTransaction","MoveString","U64","MAX_U64_BIG_INT","Bool","getCollectionData","GetCollectionData","getCollectionDataByCreatorAddressAndCollectionName","creatorAddress","collectionName","address","getCollectionDataByCreatorAddress","getCollectionDataByCollectionId","collectionId","getCollectionId","mintDigitalAssetAbi","TypeTagVector","mintDigitalAssetTransaction","collection","description","name","uri","propertyKeys","propertyTypes","propertyValues","convertedPropertyType","type","MoveVector","getPropertyValueRaw","transferDigitalAssetAbi","objectStructTag","TypeTagGeneric","TypeTagAddress","transferDigitalAssetTransaction","sender","recipient","digitalAssetType","mintSoulBoundAbi","mintSoulBoundTransaction","account","burnDigitalAssetAbi","burnDigitalAssetTransaction","freezeDigitalAssetAbi","freezeDigitalAssetTransferTransaction","unfreezeDigitalAssetAbi","unfreezeDigitalAssetTransferTransaction","setDigitalAssetDescriptionAbi","setDigitalAssetDescriptionTransaction","setDigitalAssetNameAbi","setDigitalAssetNameTransaction","setDigitalAssetURIAbi","setDigitalAssetURITransaction","addDigitalAssetPropertyAbi","addDigitalAssetPropertyTransaction","propertyKey","propertyType","propertyValue","getSinglePropertyValueRaw","removeDigitalAssetPropertyAbi","removeDigitalAssetPropertyTransaction","updateDigitalAssetPropertyAbi","updateDigitalAssetPropertyTransaction","addDigitalAssetTypedPropertyAbi","addDigitalAssetTypedPropertyTransaction","updateDigitalAssetTypedPropertyAbi","updateDigitalAssetTypedPropertyTransaction","results","typ","index","typeTag","parseTypeTag","checkOrConvertArgument","DigitalAsset","config","args","waitForIndexerOnVersion","creatorAddress","collectionName","options","address","AccountAddress","whereCondition","getCollectionData","getCollectionDataByCreatorAddressAndCollectionName","getCollectionDataByCreatorAddress","getCollectionDataByCollectionId","getCollectionId","getDigitalAssetData","getCurrentDigitalAssetOwnership","getOwnedDigitalAssets","getDigitalAssetActivity","createCollectionTransaction","mintDigitalAssetTransaction","transferDigitalAssetTransaction","mintSoulBoundTransaction","burnDigitalAssetTransaction","freezeDigitalAssetTransferTransaction","unfreezeDigitalAssetTransferTransaction","setDigitalAssetDescriptionTransaction","setDigitalAssetNameTransaction","setDigitalAssetURITransaction","addDigitalAssetPropertyTransaction","removeDigitalAssetPropertyTransaction","updateDigitalAssetPropertyTransaction","addDigitalAssetTypedPropertyTransaction","updateDigitalAssetTypedPropertyTransaction","MAX_EVENT_TYPE_LENGTH","checkEventTypeLength","eventType","getModuleEventsByEventType","args","aptosConfig","options","whereCondition","getEvents","getAccountEventsByCreationNumber","accountAddress","creationNumber","AccountAddress","getAccountEventsByEventType","graphqlQuery","GetEvents","queryIndexer","Event","config","args","waitForIndexerOnVersion","getModuleEventsByEventType","getAccountEventsByCreationNumber","getAccountEventsByEventType","getEvents","fundAccount","args","aptosConfig","accountAddress","amount","options","timeout","data","postAptosFaucet","AccountAddress","txnHash","res","waitForTransaction","Faucet","config","args","fundTxn","fundAccount","waitForIndexer","getFungibleAssetMetadata","args","aptosConfig","options","graphqlQuery","GetFungibleAssetMetadata","queryIndexer","getFungibleAssetActivities","GetFungibleAssetActivities","getCurrentFungibleAssetBalances","GetCurrentFungibleAssetBalances","faTransferAbi","parseTypeTag","TypeTagAddress","TypeTagU64","transferFungibleAsset","sender","fungibleAssetMetadataAddress","recipient","amount","generateTransaction","transferFungibleAssetBetweenStores","fromStore","toStore","FungibleAsset","config","args","waitForIndexerOnVersion","getFungibleAssetMetadata","AccountAddress","getFungibleAssetActivities","getCurrentFungibleAssetBalances","transferFungibleAsset","transferFungibleAssetBetweenStores","General","config","getLedgerInfo","args","getBlockByVersion","getBlockByHeight","view","viewJson","getChainTopUserTransactions","queryIndexer","getIndexerLastSuccessVersion","processorType","getProcessorStatus","VALIDATION_RULES_DESCRIPTION","isValidANSSegment","fragment","isValidANSName","name","first","second","rest","SubdomainExpirationPolicy","isActiveANSName","isTLDExpired","isExpired","LOCAL_ANS_ACCOUNT_PK","LOCAL_ANS_ACCOUNT_ADDRESS","NetworkToAnsContract","getRouterAddress","aptosConfig","address","unwrapOption","option","getOwnerAddress","args","routerAddress","domainName","subdomainName","res","view","owner","AccountAddress","registerName","expiration","sender","targetAddress","toAddress","options","transferable","hasSubdomainPolicy","years","registrationDuration","generateTransaction","tldExpiration","getExpiration","expirationDateInMillisecondsSinceEpoch","getPrimaryName","setPrimaryName","getTargetAddress","target","setTargetAddress","getName","queryIndexer","GetNames","sanitizeANSName","getAccountNames","accountAddress","expirationDate","getANSExpirationDate","getAccountDomains","getAccountSubdomains","getDomainSubdomains","domain","gracePeriodInSeconds","gracePeriodInDays","now","renewDomain","renewalDuration","ANS","config","args","getOwnerAddress","getExpiration","getTargetAddress","setTargetAddress","getPrimaryName","setPrimaryName","registerName","renewDomain","getName","getAccountNames","getAccountDomains","getAccountSubdomains","getDomainSubdomains","getNumberOfDelegators","args","aptosConfig","poolAddress","address","AccountAddress","data","queryIndexer","GetNumberOfDelegators","getNumberOfDelegatorsForAllPools","options","query","getDelegatedStakingActivities","delegatorAddress","GetDelegatedStakingActivities","Staking","config","args","waitForIndexerOnVersion","getNumberOfDelegators","getNumberOfDelegatorsForAllPools","getDelegatedStakingActivities","Build","config","args","generateTransaction","composer","AptosScriptComposer","bytes","rawTxn","generateRawTransaction","TransactionPayloadScript","Deserializer","SimpleTransaction","AccountAddress","Simulate","config","args","simulateTransaction","__decorateClass","ValidateFeePayerDataOnSimulation","Submit","config","args","submitTransaction","__decorateClass","ValidateFeePayerDataOnSubmission","EventEmitter","AccountSequenceNumber","aptosConfig","account","maxWaitTime","maximumInFlight","sleepTime","sleep","nextNumber","startTime","nowInSeconds","e","sequenceNumber","getInfo","EventEmitter","promiseFulfilledStatus","TransactionWorkerEventsEnum","TransactionWorker","EventEmitter","aptosConfig","account","maxWaitTime","maximumInFlight","sleepTime","AsyncQueue","AccountSequenceNumber","sequenceNumber","transaction","pendingTransaction","signAndSubmitTransaction","error","AsyncQueueCancelledError","awaitingTransactions","sequenceNumbers","sentTransactions","i","sentTransaction","waitFor","waitForTransaction","executedTransaction","transactionData","options","generateTransaction","TransactionManagement","EventEmitter","config","args","sender","TransactionWorker","data","options","d","error","Transaction","config","Build","Simulate","Submit","TransactionManagement","args","getTransactions","getTransactionByVersion","getTransactionByHash","isTransactionPending","waitForTransaction","getGasPriceEstimation","getSigningMessage","publicPackageTransaction","rotateAuthKey","signTransaction","signAsFeePayer","sender","data","options","error","signAndSubmitTransaction","signAndSubmitAsFeePayer","jwtDecode","getPepper","args","aptosConfig","jwt","ephemeralKeyPair","uidKey","derivationPath","body","Hex","data","postAptosPepperService","getProof","pepper","maxExpHorizonSecs","getKeylessConfig","KeylessAccount","decodedJwt","jwtDecode","json","postAptosProvingService","proofPoints","groth16Zkp","Groth16Zkp","ZeroKnowledgeSig","ZkProof","EphemeralSignature","deriveKeylessAccount","jwkAddress","proofFetchCallback","verificationKey","proofPromise","proof","publicKey","FederatedKeylessPublicKey","address","lookupOriginalAccountAddress","FederatedKeylessAccount","KeylessPublicKey","updateFederatedKeylessJwkSetTransaction","sender","iss","options","jwksUrl","FIREBASE_AUTH_ISS_PATTERN","response","error","errorMessage","KeylessError","jwks","generateTransaction","MoveVector","key","Keyless","config","args","getPepper","getProof","deriveKeylessAccount","updateFederatedKeylessJwkSetTransaction","getObjectData","args","aptosConfig","options","graphqlQuery","GetObjectData","queryIndexer","getObjectDataByObjectAddress","objectAddress","whereCondition","AccountAddress","AptosObject","config","args","waitForIndexerOnVersion","getObjectDataByObjectAddress","Aptos","settings","AptosConfig","Account","AccountAbstraction","ANS","Coin","DigitalAsset","Event","Faucet","FungibleAsset","General","Staking","Transaction","Table","Keyless","AptosObject","applyMixin","targetClass","baseClass","baseClassProp","propertyName","propertyDescriptor","args","EPK_HORIZON_SECS","MAX_AUD_VAL_BYTES","MAX_UID_KEY_BYTES","MAX_UID_VAL_BYTES","MAX_ISS_VAL_BYTES","MAX_EXTRA_FIELD_BYTES","MAX_JWT_HEADER_B64_BYTES","MAX_COMMITED_EPK_BYTES","_KeylessPublicKey","AccountPublicKey","iss","idCommitment","idcBytes","Hex","serializer","Serializer","AuthenticationKey","args","verifyKeylessSignatureWithJwkAndConfig","error","KeylessError","verifyKeylessSignature","deserializer","addressSeed","publicKey","computeIdCommitment","jwt","pepper","uidKey","jwtPayload","jwtDecode","uidVal","KeylessPublicKey","aptosConfig","message","signature","jwk","keylessConfig","getKeylessConfig","options","KeylessSignature","fetchJWK","verificationKey","maxExpHorizonSecs","trainingWheelsPubkey","ZeroKnowledgeSig","zkSig","Groth16Zkp","groth16Proof","nowInSeconds","publicInputsHash","getPublicInputsHash","proofAndStatement","Groth16ProofAndStatement","innerKeylessPublicKey","proof","fields","padAndPackBytesWithLen","bytesToBigIntLE","hashStrToField","encode","poseidonHash","kid","keylessPubKey","allJWKs","jwkAddr","FederatedKeylessPublicKey","getKeylessJWKs","jwksForIssuer","key","aud","bigIntToBytesLE","_KeylessSignature","Signature","jwtHeader","ephemeralCertificate","expiryDateSecs","ephemeralPublicKey","ephemeralSignature","parseJwtHeader","EphemeralCertificate","EphemeralPublicKey","EphemeralSignature","ZkProof","Ed25519PublicKey","Ed25519Signature","_EphemeralCertificate","variant","_G1Bytes","Serializable","data","bytes","point","yFlag","Fp","bn254","x","bytesToBn254FpBE","y","negY","yToUse","G1Bytes","result","bytesToNumberBE","_G2Bytes","x0","x1","Fp2","G2Bytes","_Groth16Zkp","Proof","a","b","c","_Groth16ProofAndStatement","generateSigningMessage","_ZkProof","_ZeroKnowledgeSig","expHorizonSecs","trainingWheelsSignature","extraField","overrideAudVal","Deserializer","KeylessConfiguration","_KeylessConfiguration","maxExtraFieldBytes","maxJwtHeaderB64Bytes","maxIssValBytes","maxCommitedEpkBytes","res","config","Groth16VerificationKey","_Groth16VerificationKey","alphaG1","betaG2","deltaG2","gammaAbcG1","gammaG2","sha3_256","proofA","proofB","proofC","vkAlpha1","vkBeta2","vkGamma2","vkDelta2","vkIC","g1","Fp12","accum","pairingAccumGamma","pairingAB","pairingAlphaBeta","pairingCDelta","product","memoizeAsync","vk","getKeylessConfigurationResource","getGroth16VerificationKeyResource","getIssAudAndUidVal","getErrorMessage","resourceType","getAptosFullNode","AccountAddress","resource","jwkMap","entry","jwks","jwkStruct","jwkData","MoveJWK","hexToAsciiString","_MoveJWK","kty","alg","e","n","struct","uint8Array","base64UrlToBytes","scalars","chunkInto24Bytes","chunk","chunks","i","paddedChunk","header"]}